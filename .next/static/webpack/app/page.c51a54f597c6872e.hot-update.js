/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app\\page",{

/***/ "./node_modules/next/client.js":
/*!*************************************!*\
  !*** ./node_modules/next/client.js ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/index */ \"./node_modules/next/dist/client/index.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9jbGllbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsMkdBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2NsaWVudC5qcz84MjQwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9pbmRleCcpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var e={204:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.onRefresh=n.onBeforeRefresh=n.unregister=n.register=n.onBuildError=n.onBuildOk=n.ReactDevOverlay=n.getServerError=n.getErrorByType=void 0;var i=o(t(851));var l=t(636);var s=false;var u=undefined;function onUnhandledError(e){var n=e===null||e===void 0?void 0:e.error;if(!n||!(n instanceof Error)||typeof n.stack!==\"string\"){return}if(n.message.match(/(hydration|content does not match|did not match)/i)){n.message+=\"\\n\\nSee more info here: https://nextjs.org/docs/messages/react-hydration-error\"}var t=n;i.emit({type:i.TYPE_UNHANDLED_ERROR,reason:n,frames:(0,l.parseStack)(t.stack)})}function onUnhandledRejection(e){var n=e===null||e===void 0?void 0:e.reason;if(!n||!(n instanceof Error)||typeof n.stack!==\"string\"){return}var t=n;i.emit({type:i.TYPE_UNHANDLED_REJECTION,reason:n,frames:(0,l.parseStack)(t.stack)})}function register(){if(s){return}s=true;try{var e=Error.stackTraceLimit;Error.stackTraceLimit=50;u=e}catch(e){}window.addEventListener(\"error\",onUnhandledError);window.addEventListener(\"unhandledrejection\",onUnhandledRejection)}n.register=register;function unregister(){if(!s){return}s=false;if(u!==undefined){try{Error.stackTraceLimit=u}catch(e){}u=undefined}window.removeEventListener(\"error\",onUnhandledError);window.removeEventListener(\"unhandledrejection\",onUnhandledRejection)}n.unregister=unregister;function onBuildOk(){i.emit({type:i.TYPE_BUILD_OK})}n.onBuildOk=onBuildOk;function onBuildError(e){i.emit({type:i.TYPE_BUILD_ERROR,message:e})}n.onBuildError=onBuildError;function onRefresh(){i.emit({type:i.TYPE_REFRESH})}n.onRefresh=onRefresh;function onBeforeRefresh(){i.emit({type:i.TYPE_BEFORE_REFRESH})}n.onBeforeRefresh=onBeforeRefresh;var c=t(403);r(n,c,\"getErrorByType\");var f=t(233);r(n,f,\"getServerError\");var d=t(222);r(n,d,\"default\",\"ReactDevOverlay\")},790:function(e,n,t){var r=this&&this.__extends||function(){var extendStatics=function(e,n){extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,n){e.__proto__=n}||function(e,n){for(var t in n)if(Object.prototype.hasOwnProperty.call(n,t))e[t]=n[t]};return extendStatics(e,n)};return function(e,n){if(typeof n!==\"function\"&&n!==null)throw new TypeError(\"Class extends value \"+String(n)+\" is not a constructor or null\");extendStatics(e,n);function __(){this.constructor=e}e.prototype=n===null?Object.create(n):(__.prototype=n.prototype,new __)}}();var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};n.__esModule=true;n.ErrorBoundary=void 0;var o=a(t(522));var i=function(e){r(ErrorBoundary,e);function ErrorBoundary(){var n=e!==null&&e.apply(this,arguments)||this;n.state={error:null};return n}ErrorBoundary.getDerivedStateFromError=function(e){return{error:e}};ErrorBoundary.prototype.componentDidCatch=function(e,n){this.props.onError(e,(n===null||n===void 0?void 0:n.componentStack)||null);if(!this.props.globalOverlay){this.setState({error:e})}};ErrorBoundary.prototype.render=function(){return this.state.error||this.props.globalOverlay&&this.props.isMounted?this.props.globalOverlay?o[\"default\"].createElement(\"html\",null,o[\"default\"].createElement(\"head\",null),o[\"default\"].createElement(\"body\",null)):null:this.props.children};return ErrorBoundary}(o[\"default\"].PureComponent);n.ErrorBoundary=i},222:function(e,n,t){var r=this&&this.__assign||function(){r=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return r.apply(this,arguments)};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};var l=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};var s=this&&this.__spreadArray||function(e,n,t){if(t||arguments.length===2)for(var r=0,a=n.length,o;r<a;r++){if(o||!(r in n)){if(!o)o=Array.prototype.slice.call(n,0,r);o[r]=n[r]}}return e.concat(o||Array.prototype.slice.call(n))};n.__esModule=true;var u=i(t(522));var c=i(t(851));var f=t(338);var d=t(936);var v=t(355);var p=t(790);var m=t(884);var b=t(464);var g=t(495);function pushErrorFilterDuplicates(e,n){return s(s([],l(e.filter((function(e){return e.event.reason!==n.event.reason}))),false),[n],false)}function reducer(e,n){switch(n.type){case c.TYPE_BUILD_OK:{return r(r({},e),{buildError:null})}case c.TYPE_BUILD_ERROR:{return r(r({},e),{buildError:n.message})}case c.TYPE_BEFORE_REFRESH:{return r(r({},e),{refreshState:{type:\"pending\",errors:[]}})}case c.TYPE_REFRESH:{return r(r({},e),{buildError:null,errors:e.refreshState.type===\"pending\"?e.refreshState.errors:[],refreshState:{type:\"idle\"}})}case c.TYPE_UNHANDLED_ERROR:case c.TYPE_UNHANDLED_REJECTION:{switch(e.refreshState.type){case\"idle\":{return r(r({},e),{nextId:e.nextId+1,errors:pushErrorFilterDuplicates(e.errors,{id:e.nextId,event:n})})}case\"pending\":{return r(r({},e),{nextId:e.nextId+1,refreshState:r(r({},e.refreshState),{errors:pushErrorFilterDuplicates(e.refreshState.errors,{id:e.nextId,event:n})})})}default:var t=e.refreshState;return e}}default:{var t=n;return e}}}var shouldPreventDisplay=function(e,n){if(!n||!e){return false}return n.includes(e)};var h=function ReactDevOverlay(e){var n=e.children,t=e.preventDisplay,r=e.globalOverlay;var a=l(u.useReducer(reducer,{nextId:1,buildError:null,errors:[],refreshState:{type:\"idle\"}}),2),o=a[0],i=a[1];u.useEffect((function(){c.on(i);return function(){c.off(i)}}),[i]);var s=u.useCallback((function(e,n){}),[]);var h=o.buildError!=null;var y=Boolean(o.errors.length);var x=h?\"build\":y?\"runtime\":null;var w=x!==null;return u.createElement(u.Fragment,null,u.createElement(p.ErrorBoundary,{globalOverlay:r,isMounted:w,onError:s},n!==null&&n!==void 0?n:null),w?u.createElement(f.ShadowPortal,{globalOverlay:r},u.createElement(g.CssReset,null),u.createElement(m.Base,null),u.createElement(b.ComponentStyles,null),shouldPreventDisplay(x,t)?null:h?u.createElement(d.BuildError,{message:o.buildError}):y?u.createElement(v.Errors,{errors:o.errors}):undefined):undefined)};n[\"default\"]=h},851:function(e,n){var t=this&&this.__assign||function(){t=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return t.apply(this,arguments)};n.__esModule=true;n.off=n.on=n.emit=n.TYPE_UNHANDLED_REJECTION=n.TYPE_UNHANDLED_ERROR=n.TYPE_BEFORE_REFRESH=n.TYPE_REFRESH=n.TYPE_BUILD_ERROR=n.TYPE_BUILD_OK=void 0;n.TYPE_BUILD_OK=\"build-ok\";n.TYPE_BUILD_ERROR=\"build-error\";n.TYPE_REFRESH=\"fast-refresh\";n.TYPE_BEFORE_REFRESH=\"before-fast-refresh\";n.TYPE_UNHANDLED_ERROR=\"unhandled-error\";n.TYPE_UNHANDLED_REJECTION=\"unhandled-rejection\";var r=new Set;var a=[];function drain(){setTimeout((function(){var _loop_1=function(){var e=a.shift();r.forEach((function(n){return n(e)}))};while(Boolean(a.length)&&Boolean(r.size)){_loop_1()}}),1)}function emit(e){a.push(Object.freeze(t({},e)));drain()}n.emit=emit;function on(e){if(r.has(e)){return false}r.add(e);drain();return true}n.on=on;function off(e){if(r.has(e)){r[\"delete\"](e);return true}return false}n.off=off},987:function(e,n,t){var r=this&&this.__assign||function(){r=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return r.apply(this,arguments)};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};var l=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};n.__esModule=true;n.CodeFrame=void 0;var s=l(t(997));var u=i(t(522));var c=l(t(518));var f=t(504);var d=function CodeFrame(e){var n=e.stackFrame,t=e.codeFrame;var a=u.useMemo((function(){var e=t.split(/\\r?\\n/g);var n=e.map((function(e){return/^>? +\\d+ +\\| [ ]+/.exec((0,c[\"default\"])(e))===null?null:/^>? +\\d+ +\\| ( *)/.exec((0,c[\"default\"])(e))})).filter(Boolean).map((function(e){return e.pop()})).reduce((function(e,n){return isNaN(e)?n.length:Math.min(e,n.length)}),NaN);if(n>1){var r=\" \".repeat(n);return e.map((function(e,n){return~(n=e.indexOf(\"|\"))?e.substring(0,n)+e.substring(n).replace(r,\"\"):e})).join(\"\\n\")}return e.join(\"\\n\")}),[t]);var o=u.useMemo((function(){return s[\"default\"].ansiToJson(a,{json:true,use_classes:true,remove_empty:true})}),[a]);var i=u.useCallback((function(){var e;var t=new URLSearchParams;for(var r in n){t.append(r,((e=n[r])!==null&&e!==void 0?e:\"\").toString())}self.fetch(\"\".concat( false||\"\",\"/__nextjs_launch-editor?\").concat(t.toString())).then((function(){}),(function(){console.error(\"There was an issue opening this code in your editor.\")}))}),[n]);return u.createElement(\"div\",{\"data-nextjs-codeframe\":true},u.createElement(\"div\",null,u.createElement(\"p\",{role:\"link\",onClick:i,tabIndex:1,title:\"Click to open in your editor\"},u.createElement(\"span\",null,(0,f.getFrameSource)(n),\" @ \",n.methodName),u.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",viewBox:\"0 0 24 24\",fill:\"none\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"},u.createElement(\"path\",{d:\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"}),u.createElement(\"polyline\",{points:\"15 3 21 3 21 9\"}),u.createElement(\"line\",{x1:\"10\",y1:\"14\",x2:\"21\",y2:\"3\"})))),u.createElement(\"pre\",null,o.map((function(e,n){return u.createElement(\"span\",{key:\"frame-\".concat(n),style:r({color:e.fg?\"var(--color-\".concat(e.fg,\")\"):undefined},e.decoration===\"bold\"?{fontWeight:800}:e.decoration===\"italic\"?{fontStyle:\"italic\"}:undefined)},e.content)}))))};n.CodeFrame=d},413:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});n.__esModule=true;n.CodeFrame=void 0;var a=t(987);r(n,a,\"CodeFrame\")},399:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};n.__esModule=true;n.styles=void 0;var a=t(910);var o=(0,a.noop)(i||(i=r([\"\\n  [data-nextjs-codeframe] {\\n    overflow: auto;\\n    border-radius: var(--size-gap-half);\\n    background-color: var(--color-ansi-bg);\\n    color: var(--color-ansi-fg);\\n  }\\n  [data-nextjs-codeframe]::selection,\\n  [data-nextjs-codeframe] *::selection {\\n    background-color: var(--color-ansi-selection);\\n  }\\n  [data-nextjs-codeframe] * {\\n    color: inherit;\\n    background-color: transparent;\\n    font-family: var(--font-stack-monospace);\\n  }\\n\\n  [data-nextjs-codeframe] > * {\\n    margin: 0;\\n    padding: calc(var(--size-gap) + var(--size-gap-half))\\n      calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n  [data-nextjs-codeframe] > div {\\n    display: inline-block;\\n    width: auto;\\n    min-width: 100%;\\n    border-bottom: 1px solid var(--color-ansi-bright-black);\\n  }\\n  [data-nextjs-codeframe] > div > p {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    cursor: pointer;\\n    margin: 0;\\n  }\\n  [data-nextjs-codeframe] > div > p:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-codeframe] div > p > svg {\\n    width: auto;\\n    height: 1em;\\n    margin-left: 8px;\\n  }\\n  [data-nextjs-codeframe] div > pre {\\n    overflow: hidden;\\n    display: inline-block;\\n  }\\n\"],[\"\\n  [data-nextjs-codeframe] {\\n    overflow: auto;\\n    border-radius: var(--size-gap-half);\\n    background-color: var(--color-ansi-bg);\\n    color: var(--color-ansi-fg);\\n  }\\n  [data-nextjs-codeframe]::selection,\\n  [data-nextjs-codeframe] *::selection {\\n    background-color: var(--color-ansi-selection);\\n  }\\n  [data-nextjs-codeframe] * {\\n    color: inherit;\\n    background-color: transparent;\\n    font-family: var(--font-stack-monospace);\\n  }\\n\\n  [data-nextjs-codeframe] > * {\\n    margin: 0;\\n    padding: calc(var(--size-gap) + var(--size-gap-half))\\n      calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n  [data-nextjs-codeframe] > div {\\n    display: inline-block;\\n    width: auto;\\n    min-width: 100%;\\n    border-bottom: 1px solid var(--color-ansi-bright-black);\\n  }\\n  [data-nextjs-codeframe] > div > p {\\n    display: flex;\\n    align-items: center;\\n    justify-content: space-between;\\n    cursor: pointer;\\n    margin: 0;\\n  }\\n  [data-nextjs-codeframe] > div > p:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-codeframe] div > p > svg {\\n    width: auto;\\n    height: 1em;\\n    margin-left: 8px;\\n  }\\n  [data-nextjs-codeframe] div > pre {\\n    overflow: hidden;\\n    display: inline-block;\\n  }\\n\"])));n.styles=o;var i},616:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};var i=this&&this.__rest||function(e,n){var t={};for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)&&n.indexOf(r)<0)t[r]=e[r];if(e!=null&&typeof Object.getOwnPropertySymbols===\"function\")for(var a=0,r=Object.getOwnPropertySymbols(e);a<r.length;a++){if(n.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a]))t[r[a]]=e[r[a]]}return t};var l=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};n.__esModule=true;n.Dialog=void 0;var s=o(t(522));var u=t(169);var c=function Dialog(e){var n=e.children,t=e.type,r=e.onClose,a=i(e,[\"children\",\"type\",\"onClose\"]);var o=l(s.useState(null),2),c=o[0],f=o[1];var d=s.useCallback((function(e){f(e)}),[]);(0,u.useOnClickOutside)(c,r);s.useEffect((function(){if(c==null){return}var e=c.getRootNode();if(!(e instanceof ShadowRoot)){return}var n=e;function handler(e){var t=n.activeElement;if(e.key===\"Enter\"&&t instanceof HTMLElement&&t.getAttribute(\"role\")===\"link\"){e.preventDefault();e.stopPropagation();t.click()}}n.addEventListener(\"keydown\",handler);return function(){return n.removeEventListener(\"keydown\",handler)}}),[c]);return s.createElement(\"div\",{ref:d,\"data-nextjs-dialog\":true,tabIndex:-1,role:\"dialog\",\"aria-labelledby\":a[\"aria-labelledby\"],\"aria-describedby\":a[\"aria-describedby\"],\"aria-modal\":\"true\"},s.createElement(\"div\",{\"data-nextjs-dialog-banner\":true,className:\"banner-\".concat(t)}),n)};n.Dialog=c},11:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.DialogBody=void 0;var i=o(t(522));var l=function DialogBody(e){var n=e.children,t=e.className;return i.createElement(\"div\",{\"data-nextjs-dialog-body\":true,className:t},n)};n.DialogBody=l},991:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.DialogContent=void 0;var i=o(t(522));var l=function DialogContent(e){var n=e.children,t=e.className;return i.createElement(\"div\",{\"data-nextjs-dialog-content\":true,className:t},n)};n.DialogContent=l},342:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.DialogHeader=void 0;var i=o(t(522));var l=function DialogHeader(e){var n=e.children,t=e.className;return i.createElement(\"div\",{\"data-nextjs-dialog-header\":true,className:t},n)};n.DialogHeader=l},651:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});n.__esModule=true;n.styles=n.DialogHeader=n.DialogContent=n.DialogBody=n.Dialog=void 0;var a=t(616);r(n,a,\"Dialog\");var o=t(11);r(n,o,\"DialogBody\");var i=t(991);r(n,i,\"DialogContent\");var l=t(342);r(n,l,\"DialogHeader\");var s=t(213);r(n,s,\"styles\")},213:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};n.__esModule=true;n.styles=void 0;var a=t(910);var o=(0,a.noop)(i||(i=r([\"\\n  [data-nextjs-dialog] {\\n    display: flex;\\n    flex-direction: column;\\n    width: 100%;\\n    margin-right: auto;\\n    margin-left: auto;\\n    outline: none;\\n    background: white;\\n    border-radius: var(--size-gap);\\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\\n      rgba(0, 0, 0, 0.25);\\n    max-height: calc(100% - 56px);\\n    overflow-y: hidden;\\n  }\\n\\n  @media (max-height: 812px) {\\n    [data-nextjs-dialog-overlay] {\\n      max-height: calc(100% - 15px);\\n    }\\n  }\\n\\n  @media (min-width: 576px) {\\n    [data-nextjs-dialog] {\\n      max-width: 540px;\\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\\n    }\\n  }\\n\\n  @media (min-width: 768px) {\\n    [data-nextjs-dialog] {\\n      max-width: 720px;\\n    }\\n  }\\n\\n  @media (min-width: 992px) {\\n    [data-nextjs-dialog] {\\n      max-width: 960px;\\n    }\\n  }\\n\\n  [data-nextjs-dialog-banner] {\\n    position: relative;\\n  }\\n  [data-nextjs-dialog-banner].banner-warning {\\n    border-color: var(--color-ansi-yellow);\\n  }\\n  [data-nextjs-dialog-banner].banner-error {\\n    border-color: var(--color-ansi-red);\\n  }\\n\\n  [data-nextjs-dialog-banner]::after {\\n    z-index: 2;\\n    content: '';\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    width: 100%;\\n    /* banner width: */\\n    border-top-width: var(--size-gap-half);\\n    border-bottom-width: 0;\\n    border-top-style: solid;\\n    border-bottom-style: solid;\\n    border-top-color: inherit;\\n    border-bottom-color: transparent;\\n  }\\n\\n  [data-nextjs-dialog-content] {\\n    overflow-y: auto;\\n    border: none;\\n    margin: 0;\\n    /* calc(padding + banner width offset) */\\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\\n      var(--size-gap-double);\\n    height: 100%;\\n    display: flex;\\n    flex-direction: column;\\n  }\\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\\n    flex-shrink: 0;\\n    margin-bottom: var(--size-gap-double);\\n  }\\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\\n    position: relative;\\n    flex: 1 1 auto;\\n  }\\n\"],[\"\\n  [data-nextjs-dialog] {\\n    display: flex;\\n    flex-direction: column;\\n    width: 100%;\\n    margin-right: auto;\\n    margin-left: auto;\\n    outline: none;\\n    background: white;\\n    border-radius: var(--size-gap);\\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\\n      rgba(0, 0, 0, 0.25);\\n    max-height: calc(100% - 56px);\\n    overflow-y: hidden;\\n  }\\n\\n  @media (max-height: 812px) {\\n    [data-nextjs-dialog-overlay] {\\n      max-height: calc(100% - 15px);\\n    }\\n  }\\n\\n  @media (min-width: 576px) {\\n    [data-nextjs-dialog] {\\n      max-width: 540px;\\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\\n    }\\n  }\\n\\n  @media (min-width: 768px) {\\n    [data-nextjs-dialog] {\\n      max-width: 720px;\\n    }\\n  }\\n\\n  @media (min-width: 992px) {\\n    [data-nextjs-dialog] {\\n      max-width: 960px;\\n    }\\n  }\\n\\n  [data-nextjs-dialog-banner] {\\n    position: relative;\\n  }\\n  [data-nextjs-dialog-banner].banner-warning {\\n    border-color: var(--color-ansi-yellow);\\n  }\\n  [data-nextjs-dialog-banner].banner-error {\\n    border-color: var(--color-ansi-red);\\n  }\\n\\n  [data-nextjs-dialog-banner]::after {\\n    z-index: 2;\\n    content: '';\\n    position: absolute;\\n    top: 0;\\n    right: 0;\\n    width: 100%;\\n    /* banner width: */\\n    border-top-width: var(--size-gap-half);\\n    border-bottom-width: 0;\\n    border-top-style: solid;\\n    border-bottom-style: solid;\\n    border-top-color: inherit;\\n    border-bottom-color: transparent;\\n  }\\n\\n  [data-nextjs-dialog-content] {\\n    overflow-y: auto;\\n    border: none;\\n    margin: 0;\\n    /* calc(padding + banner width offset) */\\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\\n      var(--size-gap-double);\\n    height: 100%;\\n    display: flex;\\n    flex-direction: column;\\n  }\\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\\n    flex-shrink: 0;\\n    margin-bottom: var(--size-gap-double);\\n  }\\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\\n    position: relative;\\n    flex: 1 1 auto;\\n  }\\n\"])));n.styles=o;var i},831:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};var i=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};n.__esModule=true;n.LeftRightDialogHeader=void 0;var l=o(t(522));var s=t(865);var u=function LeftRightDialogHeader(e){var n=e.children,t=e.className,r=e.previous,a=e.next,o=e.close;var u=l.useRef(null);var c=l.useRef(null);var f=l.useRef(null);var d=i(l.useState(null),2),v=d[0],p=d[1];var m=l.useCallback((function(e){p(e)}),[]);l.useEffect((function(){if(v==null){return}var e=v.getRootNode();var n=self.document;function handler(n){if(n.key===\"ArrowLeft\"){n.stopPropagation();if(u.current){u.current.focus()}r&&r()}else if(n.key===\"ArrowRight\"){n.stopPropagation();if(c.current){c.current.focus()}a&&a()}else if(n.key===\"Escape\"){n.stopPropagation();if(e instanceof ShadowRoot){var t=e.activeElement;if(t&&t!==f.current&&t instanceof HTMLElement){t.blur();return}}if(o){o()}}}e.addEventListener(\"keydown\",handler);if(e!==n){n.addEventListener(\"keydown\",handler)}return function(){e.removeEventListener(\"keydown\",handler);if(e!==n){n.removeEventListener(\"keydown\",handler)}}}),[o,v,a,r]);l.useEffect((function(){if(v==null){return}var e=v.getRootNode();if(e instanceof ShadowRoot){var n=e.activeElement;if(r==null){if(u.current&&n===u.current){u.current.blur()}}else if(a==null){if(c.current&&n===c.current){c.current.blur()}}}}),[v,a,r]);return l.createElement(\"div\",{\"data-nextjs-dialog-left-right\":true,className:t},l.createElement(\"nav\",{ref:m},l.createElement(\"button\",{ref:u,type:\"button\",disabled:r==null?true:undefined,\"aria-disabled\":r==null?true:undefined,onClick:r!==null&&r!==void 0?r:undefined},l.createElement(\"svg\",{viewBox:\"0 0 14 14\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},l.createElement(\"path\",{d:\"M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}))),l.createElement(\"button\",{ref:c,type:\"button\",disabled:a==null?true:undefined,\"aria-disabled\":a==null?true:undefined,onClick:a!==null&&a!==void 0?a:undefined},l.createElement(\"svg\",{viewBox:\"0 0 14 14\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},l.createElement(\"path\",{d:\"M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}))),\" \",n),o?l.createElement(\"button\",{\"data-nextjs-errors-dialog-left-right-close-button\":true,ref:f,type:\"button\",onClick:o,\"aria-label\":\"Close\"},l.createElement(\"span\",{\"aria-hidden\":\"true\"},l.createElement(s.CloseIcon,null))):null)};n.LeftRightDialogHeader=u},732:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});n.__esModule=true;n.styles=n.LeftRightDialogHeader=void 0;var a=t(831);r(n,a,\"LeftRightDialogHeader\");var o=t(543);r(n,o,\"styles\")},543:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};n.__esModule=true;n.styles=void 0;var a=t(910);var o=(0,a.noop)(i||(i=r([\"\\n  [data-nextjs-dialog-left-right] {\\n    display: flex;\\n    flex-direction: row;\\n    align-content: center;\\n    align-items: center;\\n    justify-content: space-between;\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button {\\n    display: inline-flex;\\n    align-items: center;\\n    justify-content: center;\\n\\n    width: calc(var(--size-gap-double) + var(--size-gap));\\n    height: calc(var(--size-gap-double) + var(--size-gap));\\n    font-size: 0;\\n    border: none;\\n    background-color: rgba(255, 85, 85, 0.1);\\n    color: var(--color-ansi-red);\\n    cursor: pointer;\\n    transition: background-color 0.25s ease;\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button > svg {\\n    width: auto;\\n    height: calc(var(--size-gap) + var(--size-gap-half));\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button:hover {\\n    background-color: rgba(255, 85, 85, 0.2);\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\\n    background-color: rgba(255, 85, 85, 0.1);\\n    color: rgba(255, 85, 85, 0.4);\\n    cursor: not-allowed;\\n  }\\n\\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\\n    margin-right: 1px;\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\\n  }\\n\\n  [data-nextjs-dialog-left-right] > button:last-of-type {\\n    border: 0;\\n    padding: 0;\\n\\n    background-color: transparent;\\n    appearance: none;\\n\\n    opacity: 0.4;\\n    transition: opacity 0.25s ease;\\n  }\\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\\n    opacity: 0.7;\\n  }\\n\"],[\"\\n  [data-nextjs-dialog-left-right] {\\n    display: flex;\\n    flex-direction: row;\\n    align-content: center;\\n    align-items: center;\\n    justify-content: space-between;\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button {\\n    display: inline-flex;\\n    align-items: center;\\n    justify-content: center;\\n\\n    width: calc(var(--size-gap-double) + var(--size-gap));\\n    height: calc(var(--size-gap-double) + var(--size-gap));\\n    font-size: 0;\\n    border: none;\\n    background-color: rgba(255, 85, 85, 0.1);\\n    color: var(--color-ansi-red);\\n    cursor: pointer;\\n    transition: background-color 0.25s ease;\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button > svg {\\n    width: auto;\\n    height: calc(var(--size-gap) + var(--size-gap-half));\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button:hover {\\n    background-color: rgba(255, 85, 85, 0.2);\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\\n    background-color: rgba(255, 85, 85, 0.1);\\n    color: rgba(255, 85, 85, 0.4);\\n    cursor: not-allowed;\\n  }\\n\\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\\n    margin-right: 1px;\\n  }\\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\\n  }\\n\\n  [data-nextjs-dialog-left-right] > button:last-of-type {\\n    border: 0;\\n    padding: 0;\\n\\n    background-color: transparent;\\n    appearance: none;\\n\\n    opacity: 0.4;\\n    transition: opacity 0.25s ease;\\n  }\\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\\n    opacity: 0.7;\\n  }\\n\"])));n.styles=o;var i},17:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};var i=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};var l=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};n.__esModule=true;n.Overlay=void 0;var s=l(t(975));var u=o(t(522));var c=t(800);var f=function Overlay(e){var n=e.className,t=e.children,r=e.fixed;u.useEffect((function(){(0,c.lock)();return function(){(0,c.unlock)()}}),[]);var a=i(u.useState(null),2),o=a[0],l=a[1];var f=u.useCallback((function(e){l(e)}),[]);u.useEffect((function(){if(o==null){return}var e=(0,s[\"default\"])({context:o});return function(){e.disengage()}}),[o]);return u.createElement(\"div\",{\"data-nextjs-dialog-overlay\":true,className:n,ref:f},u.createElement(\"div\",{\"data-nextjs-dialog-backdrop\":true,\"data-nextjs-dialog-backdrop-fixed\":r?true:undefined}),t)};n.Overlay=f},800:function(e,n){n.__esModule=true;n.unlock=n.lock=void 0;var t;var r;var a=0;function lock(){setTimeout((function(){if(a++>0){return}var e=window.innerWidth-document.documentElement.clientWidth;if(e>0){t=document.body.style.paddingRight;document.body.style.paddingRight=\"\".concat(e,\"px\")}r=document.body.style.overflow;document.body.style.overflow=\"hidden\"}))}n.lock=lock;function unlock(){setTimeout((function(){if(a===0||--a!==0){return}if(t!==undefined){document.body.style.paddingRight=t;t=undefined}if(r!==undefined){document.body.style.overflow=r;r=undefined}}))}n.unlock=unlock},278:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});n.__esModule=true;n.Overlay=void 0;var a=t(17);r(n,a,\"Overlay\")},975:function(e,n,t){var r=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};n.__esModule=true;var a=r(t(709));var o=r(t(292));function nodeArray(e){if(!e){return[]}if(Array.isArray(e)){return e}if(e.nodeType!==undefined){return[e]}if(typeof e===\"string\"){e=document.querySelectorAll(e)}if(e.length!==undefined){return[].slice.call(e,0)}throw new TypeError(\"unexpected input \"+String(e))}function contextToElement(e){var n=e.context,t=e.label,r=t===undefined?\"context-to-element\":t,a=e.resolveDocument,o=e.defaultToDocument;var i=nodeArray(n)[0];if(a&&i&&i.nodeType===Node.DOCUMENT_NODE){i=i.documentElement}if(!i&&o){return document.documentElement}if(!i){throw new TypeError(r+\" requires valid options.context\")}if(i.nodeType!==Node.ELEMENT_NODE&&i.nodeType!==Node.DOCUMENT_FRAGMENT_NODE){throw new TypeError(r+\" requires options.context to be an Element\")}return i}function getShadowHost(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context;var t=contextToElement({label:\"get/shadow-host\",context:n});var r=null;while(t){r=t;t=t.parentNode}if(r.nodeType===r.DOCUMENT_FRAGMENT_NODE&&r.host){return r.host}return null}function getDocument(e){if(!e){return document}if(e.nodeType===Node.DOCUMENT_NODE){return e}return e.ownerDocument||document}function isActiveElement(e){var n=contextToElement({label:\"is/active-element\",resolveDocument:true,context:e});var t=getDocument(n);if(t.activeElement===n){return true}var r=getShadowHost({context:n});if(r&&r.shadowRoot.activeElement===n){return true}return false}function getParents(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context;var t=[];var r=contextToElement({label:\"get/parents\",context:n});while(r){t.push(r);r=r.parentNode;if(r&&r.nodeType!==Node.ELEMENT_NODE){r=null}}return t}var i=[\"matches\",\"webkitMatchesSelector\",\"mozMatchesSelector\",\"msMatchesSelector\"];var l=null;function findMethodName(e){i.some((function(n){if(!e[n]){return false}l=n;return true}))}function elementMatches(e,n){if(!l){findMethodName(e)}return e[l](n)}var s=JSON.parse(JSON.stringify(a[\"default\"]));var u=s.os.family||\"\";var c=u===\"Android\";var f=u.slice(0,7)===\"Windows\";var d=u===\"OS X\";var v=u===\"iOS\";var p=s.layout===\"Blink\";var m=s.layout===\"Gecko\";var b=s.layout===\"Trident\";var g=s.layout===\"EdgeHTML\";var h=s.layout===\"WebKit\";var y=parseFloat(s.version);var x=Math.floor(y);s.majorVersion=x;s.is={ANDROID:c,WINDOWS:f,OSX:d,IOS:v,BLINK:p,GECKO:m,TRIDENT:b,EDGE:g,WEBKIT:h,IE9:b&&x===9,IE10:b&&x===10,IE11:b&&x===11};function before(){var e={activeElement:document.activeElement,windowScrollTop:window.scrollTop,windowScrollLeft:window.scrollLeft,bodyScrollTop:document.body.scrollTop,bodyScrollLeft:document.body.scrollLeft};var n=document.createElement(\"iframe\");n.setAttribute(\"style\",\"position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;\");n.setAttribute(\"aria-live\",\"off\");n.setAttribute(\"aria-busy\",\"true\");n.setAttribute(\"aria-hidden\",\"true\");document.body.appendChild(n);var t=n.contentWindow;var r=t.document;r.open();r.close();var a=r.createElement(\"div\");r.body.appendChild(a);e.iframe=n;e.wrapper=a;e.window=t;e.document=r;return e}function test(e,n){e.wrapper.innerHTML=\"\";var t=typeof n.element===\"string\"?e.document.createElement(n.element):n.element(e.wrapper,e.document);var r=n.mutate&&n.mutate(t,e.wrapper,e.document);if(!r&&r!==false){r=t}!t.parentNode&&e.wrapper.appendChild(t);r&&r.focus&&r.focus();return n.validate?n.validate(t,r,e.document):e.document.activeElement===r}function after(e){if(e.activeElement===document.body){document.activeElement&&document.activeElement.blur&&document.activeElement.blur();if(s.is.IE10){document.body.focus()}}else{e.activeElement&&e.activeElement.focus&&e.activeElement.focus()}document.body.removeChild(e.iframe);window.scrollTop=e.windowScrollTop;window.scrollLeft=e.windowScrollLeft;document.body.scrollTop=e.bodyScrollTop;document.body.scrollLeft=e.bodyScrollLeft}function detectFocus(e){var n=before();var t={};Object.keys(e).map((function(r){t[r]=test(n,e[r])}));after(n);return t}var w=\"1.4.1\";function readLocalStorage(e){var n=void 0;try{n=window.localStorage&&window.localStorage.getItem(e);n=n?JSON.parse(n):{}}catch(e){n={}}return n}function writeLocalStorage(e,n){if(!document.hasFocus()){try{window.localStorage&&window.localStorage.removeItem(e)}catch(e){}return}try{window.localStorage&&window.localStorage.setItem(e,JSON.stringify(n))}catch(e){}}var _=typeof window!==\"undefined\"&&window.navigator.userAgent||\"\";var E=\"ally-supports-cache\";var j=readLocalStorage(E);if(j.userAgent!==_||j.version!==w){j={}}j.userAgent=_;j.version=w;var O={get:function get(){return j},set:function set(e){Object.keys(e).forEach((function(n){j[n]=e[n]}));j.time=(new Date).toISOString();writeLocalStorage(E,j)}};function cssShadowPiercingDeepCombinator(){var e=void 0;try{document.querySelector(\"html >>> :first-child\");e=\">>>\"}catch(n){try{document.querySelector(\"html /deep/ :first-child\");e=\"/deep/\"}catch(n){e=\"\"}}return e}var k=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";var S={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-tabindex-test\">'+'<area shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" src=\"'+k+'\">';return e.querySelector(\"area\")}};var T={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-tabindex-test\">'+'<area href=\"#void\" tabindex=\"-1\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-tabindex-test\" alt=\"\" src=\"'+k+'\">';return false},validate:function validate(e,n,t){if(s.is.GECKO){return true}var r=e.querySelector(\"area\");r.focus();return t.activeElement===r}};var C={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-area-href-test\">'+'<area shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-area-href-test\" alt=\"\" src=\"'+k+'\">';return e.querySelector(\"area\")},validate:function validate(e,n,t){if(s.is.GECKO){return true}return t.activeElement===n}};var D={name:\"can-focus-audio-without-controls\",element:\"audio\",mutate:function mutate(e){try{e.setAttribute(\"src\",k)}catch(e){}}};var M=\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ\";var P={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"broken-image-map-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#broken-image-map-test\" alt=\"\" src=\"'+M+'\">';return e.querySelector(\"area\")}};var z={element:\"div\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"-1\");e.setAttribute(\"style\",\"display: -webkit-flex; display: -ms-flexbox; display: flex;\");e.innerHTML='<span style=\"display: block;\">hello</span>';return e.querySelector(\"span\")}};var A={element:\"fieldset\",mutate:function mutate(e){e.setAttribute(\"tabindex\",0);e.setAttribute(\"disabled\",\"disabled\")}};var N={element:\"fieldset\",mutate:function mutate(e){e.innerHTML=\"<legend>legend</legend><p>content</p>\"}};var R={element:\"span\",mutate:function mutate(e){e.setAttribute(\"style\",\"display: -webkit-flex; display: -ms-flexbox; display: flex;\");e.innerHTML='<span style=\"display: block;\">hello</span>'}};var I={element:\"form\",mutate:function mutate(e){e.setAttribute(\"tabindex\",0);e.setAttribute(\"disabled\",\"disabled\")}};var F={element:\"a\",mutate:function mutate(e){e.href=\"#void\";e.innerHTML='<img ismap src=\"'+k+'\" alt=\"\">';return e.querySelector(\"img\")}};var L={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"image-map-tabindex-test\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#image-map-tabindex-test\" tabindex=\"-1\" alt=\"\" '+'src=\"'+k+'\">';return e.querySelector(\"img\")}};var B={element:function element(e,n){var t=n.createElement(\"iframe\");e.appendChild(t);var r=t.contentWindow.document;r.open();r.close();return t},mutate:function mutate(e){e.style.visibility=\"hidden\";var n=e.contentWindow.document;var t=n.createElement(\"input\");n.body.appendChild(t);return t},validate:function validate(e){var n=e.contentWindow.document;var t=n.querySelector(\"input\");return n.activeElement===t}};var H=!s.is.WEBKIT;function focusInZeroDimensionObject(){return H}var q={element:\"div\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"invalid-value\")}};var U={element:\"label\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"-1\")},validate:function validate(e,n,t){var r=e.offsetHeight;e.focus();return t.activeElement===e}};var W=\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb\"+\"G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ\"+\"zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==\";var V={element:\"object\",mutate:function mutate(e){e.setAttribute(\"type\",\"image/svg+xml\");e.setAttribute(\"data\",W);e.setAttribute(\"width\",\"200\");e.setAttribute(\"height\",\"50\");e.style.visibility=\"hidden\"}};var K={name:\"can-focus-object-svg\",element:\"object\",mutate:function mutate(e){e.setAttribute(\"type\",\"image/svg+xml\");e.setAttribute(\"data\",W);e.setAttribute(\"width\",\"200\");e.setAttribute(\"height\",\"50\")},validate:function validate(e,n,t){if(s.is.GECKO){return true}return t.activeElement===e}};var Z=!s.is.IE9;function focusObjectSwf(){return Z}var G={element:\"div\",mutate:function mutate(e){e.innerHTML='<map name=\"focus-redirect-img-usemap\"><area href=\"#void\" shape=\"rect\" coords=\"63,19,144,45\"></map>'+'<img usemap=\"#focus-redirect-img-usemap\" alt=\"\" '+'src=\"'+k+'\">';return e.querySelector(\"img\")},validate:function validate(e,n,t){var r=e.querySelector(\"area\");return t.activeElement===r}};var Y={element:\"fieldset\",mutate:function mutate(e){e.innerHTML='<legend>legend</legend><input tabindex=\"-1\"><input tabindex=\"0\">';return false},validate:function validate(e,n,t){var r=e.querySelector('input[tabindex=\"-1\"]');var a=e.querySelector('input[tabindex=\"0\"]');e.focus();e.querySelector(\"legend\").focus();return t.activeElement===r&&\"focusable\"||t.activeElement===a&&\"tabbable\"||\"\"}};var J={element:\"div\",mutate:function mutate(e){e.setAttribute(\"style\",\"width: 100px; height: 50px; overflow: auto;\");e.innerHTML='<div style=\"width: 500px; height: 40px;\">scrollable content</div>';return e.querySelector(\"div\")}};var $={element:\"div\",mutate:function mutate(e){e.setAttribute(\"style\",\"width: 100px; height: 50px;\");e.innerHTML='<div style=\"width: 500px; height: 40px;\">scrollable content</div>'}};var X={element:\"div\",mutate:function mutate(e){e.setAttribute(\"style\",\"width: 100px; height: 50px; overflow: auto;\");e.innerHTML='<div style=\"width: 500px; height: 40px;\">scrollable content</div>'}};var Q={element:\"details\",mutate:function mutate(e){e.innerHTML=\"<summary>foo</summary><p>content</p>\";return e.firstElementChild}};function makeFocusableForeignObject(){var e=document.createElementNS(\"http://www.w3.org/2000/svg\",\"foreignObject\");e.width.baseVal.value=30;e.height.baseVal.value=30;e.appendChild(document.createElement(\"input\"));e.lastChild.type=\"text\";return e}function focusSvgForeignObjectHack(e){var n=e.ownerSVGElement||e.nodeName.toLowerCase()===\"svg\";if(!n){return false}var t=makeFocusableForeignObject();e.appendChild(t);var r=t.querySelector(\"input\");r.focus();r.disabled=true;e.removeChild(t);return true}function generate(e){return'<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">'+e+\"</svg>\"}function focus(e){if(e.focus){return}try{HTMLElement.prototype.focus.call(e)}catch(n){focusSvgForeignObjectHack(e)}}function validate(e,n,t){focus(n);return t.activeElement===n}var ee={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<text focusable=\"true\">a</text>');return e.querySelector(\"text\")},validate:validate};var ne={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<text tabindex=\"0\">a</text>');return e.querySelector(\"text\")},validate:validate};var te={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<text tabindex=\"-1\">a</text>');return e.querySelector(\"text\")},validate:validate};var re={element:\"div\",mutate:function mutate(e){e.innerHTML=generate(['<g id=\"ally-test-target\"><a xlink:href=\"#void\"><text>link</text></a></g>','<use xlink:href=\"#ally-test-target\" x=\"0\" y=\"0\" tabindex=\"-1\" />'].join(\"\"));return e.querySelector(\"use\")},validate:validate};var ae={element:\"div\",mutate:function mutate(e){e.innerHTML=generate('<foreignObject tabindex=\"-1\"><input type=\"text\" /></foreignObject>');return e.querySelector(\"foreignObject\")||e.getElementsByTagName(\"foreignObject\")[0]},validate:validate};var oe=Boolean(s.is.GECKO&&typeof SVGElement!==\"undefined\"&&SVGElement.prototype.focus);function focusSvgInIframe(){return oe}var ie={element:\"div\",mutate:function mutate(e){e.innerHTML=generate(\"\");return e.firstChild},validate:validate};var le={element:\"div\",mutate:function mutate(e){e.setAttribute(\"tabindex\",\"3x\")}};var se={element:\"table\",mutate:function mutate(e,n,t){var r=t.createDocumentFragment();r.innerHTML=\"<tr><td>cell</td></tr>\";e.appendChild(r)}};var ue={element:\"video\",mutate:function mutate(e){try{e.setAttribute(\"src\",k)}catch(e){}}};var ce=s.is.GECKO||s.is.TRIDENT||s.is.EDGE;function tabsequenceAreaAtImgPosition(){return ce}var fe={cssShadowPiercingDeepCombinator:cssShadowPiercingDeepCombinator,focusInZeroDimensionObject:focusInZeroDimensionObject,focusObjectSwf:focusObjectSwf,focusSvgInIframe:focusSvgInIframe,tabsequenceAreaAtImgPosition:tabsequenceAreaAtImgPosition};var de={focusAreaImgTabindex:S,focusAreaTabindex:T,focusAreaWithoutHref:C,focusAudioWithoutControls:D,focusBrokenImageMap:P,focusChildrenOfFocusableFlexbox:z,focusFieldsetDisabled:A,focusFieldset:N,focusFlexboxContainer:R,focusFormDisabled:I,focusImgIsmap:F,focusImgUsemapTabindex:L,focusInHiddenIframe:B,focusInvalidTabindex:q,focusLabelTabindex:U,focusObjectSvg:K,focusObjectSvgHidden:V,focusRedirectImgUsemap:G,focusRedirectLegend:Y,focusScrollBody:J,focusScrollContainerWithoutOverflow:$,focusScrollContainer:X,focusSummary:Q,focusSvgFocusableAttribute:ee,focusSvgTabindexAttribute:ne,focusSvgNegativeTabindexAttribute:te,focusSvgUseTabindex:re,focusSvgForeignobjectTabindex:ae,focusSvg:ie,focusTabindexTrailingCharacters:le,focusTable:se,focusVideoWithoutControls:ue};function executeTests(){var e=detectFocus(de);Object.keys(fe).forEach((function(n){e[n]=fe[n]()}));return e}var ve=null;function _supports(){if(ve){return ve}ve=O.get();if(!ve.time){O.set(executeTests());ve=O.get()}return ve}var pe=void 0;var me=/^\\s*(-|\\+)?[0-9]+\\s*$/;var be=/^\\s*(-|\\+)?[0-9]+.*$/;function isValidTabindex(e){if(!pe){pe=_supports()}var n=pe.focusTabindexTrailingCharacters?be:me;var t=contextToElement({label:\"is/valid-tabindex\",resolveDocument:true,context:e});var r=t.hasAttribute(\"tabindex\");var a=t.hasAttribute(\"tabIndex\");if(!r&&!a){return false}var o=t.ownerSVGElement||t.nodeName.toLowerCase()===\"svg\";if(o&&!pe.focusSvgTabindexAttribute){return false}if(pe.focusInvalidTabindex){return true}var i=t.getAttribute(r?\"tabindex\":\"tabIndex\");if(i===\"-32768\"){return false}return Boolean(i&&n.test(i))}function tabindexValue(e){if(!isValidTabindex(e)){return null}var n=e.hasAttribute(\"tabindex\");var t=n?\"tabindex\":\"tabIndex\";var r=parseInt(e.getAttribute(t),10);return isNaN(r)?-1:r}function isUserModifyWritable(e){var n=e.webkitUserModify||\"\";return Boolean(n&&n.indexOf(\"write\")!==-1)}function hasCssOverflowScroll(e){return[e.getPropertyValue(\"overflow\"),e.getPropertyValue(\"overflow-x\"),e.getPropertyValue(\"overflow-y\")].some((function(e){return e===\"auto\"||e===\"scroll\"}))}function hasCssDisplayFlex(e){return e.display.indexOf(\"flex\")>-1}function isScrollableContainer(e,n,t,r){if(n!==\"div\"&&n!==\"span\"){return false}if(t&&t!==\"div\"&&t!==\"span\"&&!hasCssOverflowScroll(r)){return false}return e.offsetHeight<e.scrollHeight||e.offsetWidth<e.scrollWidth}var ge=void 0;function isFocusRelevantRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.except,r=t===undefined?{flexbox:false,scrollable:false,shadow:false}:t;if(!ge){ge=_supports()}var a=contextToElement({label:\"is/focus-relevant\",resolveDocument:true,context:n});if(!r.shadow&&a.shadowRoot){return true}var o=a.nodeName.toLowerCase();if(o===\"input\"&&a.type===\"hidden\"){return false}if(o===\"input\"||o===\"select\"||o===\"button\"||o===\"textarea\"){return true}if(o===\"legend\"&&ge.focusRedirectLegend){return true}if(o===\"label\"){return true}if(o===\"area\"){return true}if(o===\"a\"&&a.hasAttribute(\"href\")){return true}if(o===\"object\"&&a.hasAttribute(\"usemap\")){return false}if(o===\"object\"){var i=a.getAttribute(\"type\");if(!ge.focusObjectSvg&&i===\"image/svg+xml\"){return false}else if(!ge.focusObjectSwf&&i===\"application/x-shockwave-flash\"){return false}}if(o===\"iframe\"||o===\"object\"){return true}if(o===\"embed\"||o===\"keygen\"){return true}if(a.hasAttribute(\"contenteditable\")){return true}if(o===\"audio\"&&(ge.focusAudioWithoutControls||a.hasAttribute(\"controls\"))){return true}if(o===\"video\"&&(ge.focusVideoWithoutControls||a.hasAttribute(\"controls\"))){return true}if(ge.focusSummary&&o===\"summary\"){return true}var l=isValidTabindex(a);if(o===\"img\"&&a.hasAttribute(\"usemap\")){return l&&ge.focusImgUsemapTabindex||ge.focusRedirectImgUsemap}if(ge.focusTable&&(o===\"table\"||o===\"td\")){return true}if(ge.focusFieldset&&o===\"fieldset\"){return true}var s=o===\"svg\";var u=a.ownerSVGElement;var c=a.getAttribute(\"focusable\");var f=tabindexValue(a);if(o===\"use\"&&f!==null&&!ge.focusSvgUseTabindex){return false}if(o===\"foreignobject\"){return f!==null&&ge.focusSvgForeignobjectTabindex}if(elementMatches(a,\"svg a\")&&a.hasAttribute(\"xlink:href\")){return true}if((s||u)&&a.focus&&!ge.focusSvgNegativeTabindexAttribute&&f<0){return false}if(s){return l||ge.focusSvg||ge.focusSvgInIframe||Boolean(ge.focusSvgFocusableAttribute&&c&&c===\"true\")}if(u){if(ge.focusSvgTabindexAttribute&&l){return true}if(ge.focusSvgFocusableAttribute){return c===\"true\"}}if(l){return true}var d=window.getComputedStyle(a,null);if(isUserModifyWritable(d)){return true}if(ge.focusImgIsmap&&o===\"img\"&&a.hasAttribute(\"ismap\")){var v=getParents({context:a}).some((function(e){return e.nodeName.toLowerCase()===\"a\"&&e.hasAttribute(\"href\")}));if(v){return true}}if(!r.scrollable&&ge.focusScrollContainer){if(ge.focusScrollContainerWithoutOverflow){if(isScrollableContainer(a,o)){return true}}else if(hasCssOverflowScroll(d)){return true}}if(!r.flexbox&&ge.focusFlexboxContainer&&hasCssDisplayFlex(d)){return true}var p=a.parentElement;if(!r.scrollable&&p){var m=p.nodeName.toLowerCase();var b=window.getComputedStyle(p,null);if(ge.focusScrollBody&&isScrollableContainer(p,o,m,b)){return true}if(ge.focusChildrenOfFocusableFlexbox){if(hasCssDisplayFlex(b)){return true}}}return false}isFocusRelevantRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var n=function isFocusRelevant(n){return isFocusRelevantRules({context:n,except:e})};n.rules=isFocusRelevantRules;return n};var he=isFocusRelevantRules.except({});function findIndex(e,n){if(e.findIndex){return e.findIndex(n)}var t=e.length;if(t===0){return-1}for(var r=0;r<t;r++){if(n(e[r],r,e)){return r}}return-1}function getContentDocument(e){try{return e.contentDocument||e.contentWindow&&e.contentWindow.document||e.getSVGDocument&&e.getSVGDocument()||null}catch(e){return null}}function getWindow(e){var n=getDocument(e);return n.defaultView||window}var ye=void 0;function selectInShadows(e){if(typeof ye!==\"string\"){var n=cssShadowPiercingDeepCombinator();if(n){ye=\", html \"+n+\" \"}}if(!ye){return e}return e+ye+e.replace(/\\s*,\\s*/g,\",\").split(\",\").join(ye)}var xe=void 0;function findDocumentHostElement(e){if(!xe){xe=selectInShadows(\"object, iframe\")}if(e._frameElement!==undefined){return e._frameElement}e._frameElement=null;var n=e.parent.document.querySelectorAll(xe);[].some.call(n,(function(n){var t=getContentDocument(n);if(t!==e.document){return false}e._frameElement=n;return true}));return e._frameElement}function getFrameElement(e){var n=getWindow(e);if(!n.parent||n.parent===n){return null}try{return n.frameElement||findDocumentHostElement(n)}catch(e){return null}}var we=/^(area)$/;function computedStyle(e,n){return window.getComputedStyle(e,null).getPropertyValue(n)}function notDisplayed(e){return e.some((function(e){return computedStyle(e,\"display\")===\"none\"}))}function notVisible(e){var n=findIndex(e,(function(e){var n=computedStyle(e,\"visibility\");return n===\"hidden\"||n===\"collapse\"}));if(n===-1){return false}var t=findIndex(e,(function(e){return computedStyle(e,\"visibility\")===\"visible\"}));if(t===-1){return true}if(n<t){return true}return false}function collapsedParent(e){var n=1;if(e[0].nodeName.toLowerCase()===\"summary\"){n=2}return e.slice(n).some((function(e){return e.nodeName.toLowerCase()===\"details\"&&e.open===false}))}function isVisibleRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.except,r=t===undefined?{notRendered:false,cssDisplay:false,cssVisibility:false,detailsElement:false,browsingContext:false}:t;var a=contextToElement({label:\"is/visible\",resolveDocument:true,context:n});var o=a.nodeName.toLowerCase();if(!r.notRendered&&we.test(o)){return true}var i=getParents({context:a});var l=o===\"audio\"&&!a.hasAttribute(\"controls\");if(!r.cssDisplay&&notDisplayed(l?i.slice(1):i)){return false}if(!r.cssVisibility&&notVisible(i)){return false}if(!r.detailsElement&&collapsedParent(i)){return false}if(!r.browsingContext){var s=getFrameElement(a);var u=isVisibleRules.except(r);if(s&&!u(s)){return false}}return true}isVisibleRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var n=function isVisible(n){return isVisibleRules({context:n,except:e})};n.rules=isVisibleRules;return n};var _e=isVisibleRules.except({});function getMapByName(e,n){var t=n.querySelector('map[name=\"'+(0,o[\"default\"])(e)+'\"]');return t||null}function getImageOfArea(e){var n=e.parentElement;if(!n.name||n.nodeName.toLowerCase()!==\"map\"){return null}var t=getDocument(e);return t.querySelector('img[usemap=\"#'+(0,o[\"default\"])(n.name)+'\"]')||null}var Ee=void 0;function isValidArea(e){if(!Ee){Ee=_supports()}var n=contextToElement({label:\"is/valid-area\",context:e});var t=n.nodeName.toLowerCase();if(t!==\"area\"){return false}var r=n.hasAttribute(\"tabindex\");if(!Ee.focusAreaTabindex&&r){return false}var a=getImageOfArea(n);if(!a||!_e(a)){return false}if(!Ee.focusBrokenImageMap&&(!a.complete||!a.naturalHeight||a.offsetWidth<=0||a.offsetHeight<=0)){return false}if(!Ee.focusAreaWithoutHref&&!n.href){return Ee.focusAreaTabindex&&r||Ee.focusAreaImgTabindex&&a.hasAttribute(\"tabindex\")}var o=getParents({context:a}).slice(1).some((function(e){var n=e.nodeName.toLowerCase();return n===\"button\"||n===\"a\"}));if(o){return false}return true}var je=void 0;var Oe=void 0;var ke={input:true,select:true,textarea:true,button:true,fieldset:true,form:true};function isNativeDisabledSupported(e){if(!je){je=_supports();if(je.focusFieldsetDisabled){delete ke.fieldset}if(je.focusFormDisabled){delete ke.form}Oe=new RegExp(\"^(\"+Object.keys(ke).join(\"|\")+\")$\")}var n=contextToElement({label:\"is/native-disabled-supported\",context:e});var t=n.nodeName.toLowerCase();return Boolean(Oe.test(t))}var Se=void 0;function isDisabledFieldset(e){var n=e.nodeName.toLowerCase();return n===\"fieldset\"&&e.disabled}function isDisabledForm(e){var n=e.nodeName.toLowerCase();return n===\"form\"&&e.disabled}function isDisabled(e){if(!Se){Se=_supports()}var n=contextToElement({label:\"is/disabled\",context:e});if(n.hasAttribute(\"data-ally-disabled\")){return true}if(!isNativeDisabledSupported(n)){return false}if(n.disabled){return true}var t=getParents({context:n});if(t.some(isDisabledFieldset)){return true}if(!Se.focusFormDisabled&&t.some(isDisabledForm)){return true}return false}function isOnlyTabbableRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.except,r=t===undefined?{onlyFocusableBrowsingContext:false,visible:false}:t;var a=contextToElement({label:\"is/only-tabbable\",resolveDocument:true,context:n});if(!r.visible&&!_e(a)){return false}if(!r.onlyFocusableBrowsingContext&&(s.is.GECKO||s.is.TRIDENT||s.is.EDGE)){var o=getFrameElement(a);if(o){if(tabindexValue(o)<0){return false}}}var i=a.nodeName.toLowerCase();var l=tabindexValue(a);if(i===\"label\"&&s.is.GECKO){return l!==null&&l>=0}if(s.is.GECKO&&a.ownerSVGElement&&!a.focus){if(i===\"a\"&&a.hasAttribute(\"xlink:href\")){if(s.is.GECKO){return true}}}return false}isOnlyTabbableRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var n=function isOnlyTabbable(n){return isOnlyTabbableRules({context:n,except:e})};n.rules=isOnlyTabbableRules;return n};var Te=isOnlyTabbableRules.except({});var Ce=void 0;function isOnlyFocusRelevant(e){var n=e.nodeName.toLowerCase();if(n===\"embed\"||n===\"keygen\"){return true}var t=tabindexValue(e);if(e.shadowRoot&&t===null){return true}if(n===\"label\"){return!Ce.focusLabelTabindex||t===null}if(n===\"legend\"){return t===null}if(Ce.focusSvgFocusableAttribute&&(e.ownerSVGElement||n===\"svg\")){var r=e.getAttribute(\"focusable\");return r&&r===\"false\"}if(n===\"img\"&&e.hasAttribute(\"usemap\")){return t===null||!Ce.focusImgUsemapTabindex}if(n===\"area\"){return!isValidArea(e)}return false}function isFocusableRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.except,r=t===undefined?{disabled:false,visible:false,onlyTabbable:false}:t;if(!Ce){Ce=_supports()}var a=Te.rules.except({onlyFocusableBrowsingContext:true,visible:r.visible});var o=contextToElement({label:\"is/focusable\",resolveDocument:true,context:n});var i=he.rules({context:o,except:r});if(!i||isOnlyFocusRelevant(o)){return false}if(!r.disabled&&isDisabled(o)){return false}if(!r.onlyTabbable&&a(o)){return false}if(!r.visible){var l={context:o,except:{}};if(Ce.focusInHiddenIframe){l.except.browsingContext=true}if(Ce.focusObjectSvgHidden){var s=o.nodeName.toLowerCase();if(s===\"object\"){l.except.cssVisibility=true}}if(!_e.rules(l)){return false}}var u=getFrameElement(o);if(u){var c=u.nodeName.toLowerCase();if(c===\"object\"&&!Ce.focusInZeroDimensionObject){if(!u.offsetWidth||!u.offsetHeight){return false}}}var f=o.nodeName.toLowerCase();if(f===\"svg\"&&Ce.focusSvgInIframe&&!u&&o.getAttribute(\"tabindex\")===null){return false}return true}isFocusableRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var n=function isFocusable(n){return isFocusableRules({context:n,except:e})};n.rules=isFocusableRules;return n};var De=isFocusableRules.except({});function createFilter(e){var n=function filter(n){if(n.shadowRoot){return NodeFilter.FILTER_ACCEPT}if(e(n)){return NodeFilter.FILTER_ACCEPT}return NodeFilter.FILTER_SKIP};n.acceptNode=n;return n}var Me=createFilter(he);function queryFocusableStrict(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.includeContext,r=e.includeOnlyTabbable,a=e.strategy;if(!n){n=document.documentElement}var o=De.rules.except({onlyTabbable:r});var i=getDocument(n);var l=i.createTreeWalker(n,NodeFilter.SHOW_ELEMENT,a===\"all\"?Me:createFilter(o),false);var s=[];while(l.nextNode()){if(l.currentNode.shadowRoot){if(o(l.currentNode)){s.push(l.currentNode)}s=s.concat(queryFocusableStrict({context:l.currentNode.shadowRoot,includeOnlyTabbable:r,strategy:a}))}else{s.push(l.currentNode)}}if(t){if(a===\"all\"){if(he(n)){s.unshift(n)}}else if(o(n)){s.unshift(n)}}return s}var Pe=void 0;var ze=void 0;function selector$2(){if(!Pe){Pe=_supports()}if(typeof ze===\"string\"){return ze}ze=\"\"+(Pe.focusTable?\"table, td,\":\"\")+(Pe.focusFieldset?\"fieldset,\":\"\")+\"svg a,\"+\"a[href],\"+\"area[href],\"+\"input, select, textarea, button,\"+\"iframe, object, embed,\"+\"keygen,\"+(Pe.focusAudioWithoutControls?\"audio,\":\"audio[controls],\")+(Pe.focusVideoWithoutControls?\"video,\":\"video[controls],\")+(Pe.focusSummary?\"summary,\":\"\")+\"[tabindex],\"+\"[contenteditable]\";ze=selectInShadows(ze);return ze}function queryFocusableQuick(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.includeContext,r=e.includeOnlyTabbable;var a=selector$2();var o=n.querySelectorAll(a);var i=De.rules.except({onlyTabbable:r});var l=[].filter.call(o,i);if(t&&i(n)){l.unshift(n)}return l}function queryFocusable(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.includeContext,r=e.includeOnlyTabbable,a=e.strategy,o=a===undefined?\"quick\":a;var i=contextToElement({label:\"query/focusable\",resolveDocument:true,defaultToDocument:true,context:n});var l={context:i,includeContext:t,includeOnlyTabbable:r,strategy:o};if(o===\"quick\"){return queryFocusableQuick(l)}else if(o===\"strict\"||o===\"all\"){return queryFocusableStrict(l)}throw new TypeError('query/focusable requires option.strategy to be one of [\"quick\", \"strict\", \"all\"]')}var Ae=void 0;var Ne=/^(fieldset|table|td|body)$/;function isTabbableRules(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.except,r=t===undefined?{flexbox:false,scrollable:false,shadow:false,visible:false,onlyTabbable:false}:t;if(!Ae){Ae=_supports()}var a=contextToElement({label:\"is/tabbable\",resolveDocument:true,context:n});if(s.is.BLINK&&s.is.ANDROID&&s.majorVersion>42){return false}var o=getFrameElement(a);if(o){if(s.is.WEBKIT&&s.is.IOS){return false}if(tabindexValue(o)<0){return false}if(!r.visible&&(s.is.BLINK||s.is.WEBKIT)&&!_e(o)){return false}var i=o.nodeName.toLowerCase();if(i===\"object\"){var l=s.name===\"Chrome\"&&s.majorVersion>=54||s.name===\"Opera\"&&s.majorVersion>=41;if(s.is.WEBKIT||s.is.BLINK&&!l){return false}}}var u=a.nodeName.toLowerCase();var c=tabindexValue(a);var f=c===null?null:c>=0;if(s.is.EDGE&&s.majorVersion>=14&&o&&a.ownerSVGElement&&c<0){return true}var d=f!==false;var v=c!==null&&c>=0;if(a.hasAttribute(\"contenteditable\")){return d}if(Ne.test(u)&&f!==true){return false}if(s.is.WEBKIT&&s.is.IOS){var p=u===\"input\"&&a.type===\"text\"||a.type===\"password\"||u===\"select\"||u===\"textarea\"||a.hasAttribute(\"contenteditable\");if(!p){var m=window.getComputedStyle(a,null);p=isUserModifyWritable(m)}if(!p){return false}}if(u===\"use\"&&c!==null){if(s.is.BLINK||s.is.WEBKIT&&s.majorVersion===9){return true}}if(elementMatches(a,\"svg a\")&&a.hasAttribute(\"xlink:href\")){if(d){return true}if(a.focus&&!Ae.focusSvgNegativeTabindexAttribute){return true}}if(u===\"svg\"&&Ae.focusSvgInIframe&&d){return true}if(s.is.TRIDENT||s.is.EDGE){if(u===\"svg\"){if(Ae.focusSvg){return true}return a.hasAttribute(\"focusable\")||v}if(a.ownerSVGElement){if(Ae.focusSvgTabindexAttribute&&v){return true}return a.hasAttribute(\"focusable\")}}if(a.tabIndex===undefined){return Boolean(r.onlyTabbable)}if(u===\"audio\"){if(!a.hasAttribute(\"controls\")){return false}else if(s.is.BLINK){return true}}if(u===\"video\"){if(!a.hasAttribute(\"controls\")){if(s.is.TRIDENT||s.is.EDGE){return false}}else if(s.is.BLINK||s.is.GECKO){return true}}if(u===\"object\"){if(s.is.BLINK||s.is.WEBKIT){return false}}if(u===\"iframe\"){return false}if(!r.scrollable&&s.is.GECKO){var b=window.getComputedStyle(a,null);if(hasCssOverflowScroll(b)){return d}}if(s.is.TRIDENT||s.is.EDGE){if(u===\"area\"){var g=getImageOfArea(a);if(g&&tabindexValue(g)<0){return false}}var h=window.getComputedStyle(a,null);if(isUserModifyWritable(h)){return a.tabIndex>=0}if(!r.flexbox&&hasCssDisplayFlex(h)){if(c!==null){return v}return Re(a)&&Ie(a)}if(isScrollableContainer(a,u)){return false}var y=a.parentElement;if(y){var x=y.nodeName.toLowerCase();var w=window.getComputedStyle(y,null);if(isScrollableContainer(y,u,x,w)){return false}if(hasCssDisplayFlex(w)){return v}}}return a.tabIndex>=0}isTabbableRules.except=function(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var n=function isTabbable(n){return isTabbableRules({context:n,except:e})};n.rules=isTabbableRules;return n};var Re=he.rules.except({flexbox:true});var Ie=isTabbableRules.except({flexbox:true});var Fe=isTabbableRules.except({});function queryTabbable(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.includeContext,r=e.includeOnlyTabbable,a=e.strategy;var o=Fe.rules.except({onlyTabbable:r});return queryFocusable({context:n,includeContext:t,includeOnlyTabbable:r,strategy:a}).filter(o)}function compareDomPosition(e,n){return e.compareDocumentPosition(n)&Node.DOCUMENT_POSITION_FOLLOWING?-1:1}function sortDomOrder(e){return e.sort(compareDomPosition)}function getFirstSuccessorOffset(e,n){return findIndex(e,(function(e){return n.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING}))}function findInsertionOffsets(e,n,t){var r=[];n.forEach((function(n){var a=true;var o=e.indexOf(n);if(o===-1){o=getFirstSuccessorOffset(e,n);a=false}if(o===-1){o=e.length}var i=nodeArray(t?t(n):n);if(!i.length){return}r.push({offset:o,replace:a,elements:i})}));return r}function insertElementsAtOffsets(e,n){var t=0;n.sort((function(e,n){return e.offset-n.offset}));n.forEach((function(n){var r=n.replace?1:0;var a=[n.offset+t,r].concat(n.elements);e.splice.apply(e,a);t+=n.elements.length-r}))}function mergeInDomOrder(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.list,t=e.elements,r=e.resolveElement;var a=n.slice(0);var o=nodeArray(t).slice(0);sortDomOrder(o);var i=findInsertionOffsets(a,o,r);insertElementsAtOffsets(a,i);return a}var Le=function(){function defineProperties(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||false;r.configurable=true;if(\"value\"in r)r.writable=true;Object.defineProperty(e,r.key,r)}}return function(e,n,t){if(n)defineProperties(e.prototype,n);if(t)defineProperties(e,t);return e}}();function _classCallCheck(e,n){if(!(e instanceof n)){throw new TypeError(\"Cannot call a class as a function\")}}var Be=function(){function Maps(e){_classCallCheck(this,Maps);this._document=getDocument(e);this.maps={}}Le(Maps,[{key:\"getAreasFor\",value:function getAreasFor(e){if(!this.maps[e]){this.addMapByName(e)}return this.maps[e]}},{key:\"addMapByName\",value:function addMapByName(e){var n=getMapByName(e,this._document);if(!n){return}this.maps[n.name]=queryTabbable({context:n})}},{key:\"extractAreasFromList\",value:function extractAreasFromList(e){return e.filter((function(e){var n=e.nodeName.toLowerCase();if(n!==\"area\"){return true}var t=e.parentNode;if(!this.maps[t.name]){this.maps[t.name]=[]}this.maps[t.name].push(e);return false}),this)}}]);return Maps}();function sortArea(e,n){var t=n.querySelectorAll(\"img[usemap]\");var r=new Be(n);var a=r.extractAreasFromList(e);if(!t.length){return a}return mergeInDomOrder({list:a,elements:t,resolveElement:function resolveElement(e){var n=e.getAttribute(\"usemap\").slice(1);return r.getAreasFor(n)}})}var He=function(){function defineProperties(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||false;r.configurable=true;if(\"value\"in r)r.writable=true;Object.defineProperty(e,r.key,r)}}return function(e,n,t){if(n)defineProperties(e.prototype,n);if(t)defineProperties(e,t);return e}}();function _classCallCheck$1(e,n){if(!(e instanceof n)){throw new TypeError(\"Cannot call a class as a function\")}}var qe=function(){function Shadows(e,n){_classCallCheck$1(this,Shadows);this.context=e;this.sortElements=n;this.hostCounter=1;this.inHost={};this.inDocument=[];this.hosts={};this.elements={}}He(Shadows,[{key:\"_registerHost\",value:function _registerHost(e){if(e._sortingId){return}e._sortingId=\"shadow-\"+this.hostCounter++;this.hosts[e._sortingId]=e;var n=getShadowHost({context:e});if(n){this._registerHost(n);this._registerHostParent(e,n)}else{this.inDocument.push(e)}}},{key:\"_registerHostParent\",value:function _registerHostParent(e,n){if(!this.inHost[n._sortingId]){this.inHost[n._sortingId]=[]}this.inHost[n._sortingId].push(e)}},{key:\"_registerElement\",value:function _registerElement(e,n){if(!this.elements[n._sortingId]){this.elements[n._sortingId]=[]}this.elements[n._sortingId].push(e)}},{key:\"extractElements\",value:function extractElements(e){return e.filter((function(e){var n=getShadowHost({context:e});if(!n){return true}this._registerHost(n);this._registerElement(e,n);return false}),this)}},{key:\"sort\",value:function sort(e){var n=this._injectHosts(e);n=this._replaceHosts(n);this._cleanup();return n}},{key:\"_injectHosts\",value:function _injectHosts(e){Object.keys(this.hosts).forEach((function(e){var n=this.elements[e];var t=this.inHost[e];var r=this.hosts[e].shadowRoot;this.elements[e]=this._merge(n,t,r)}),this);return this._merge(e,this.inDocument,this.context)}},{key:\"_merge\",value:function _merge(e,n,t){var r=mergeInDomOrder({list:e,elements:n});return this.sortElements(r,t)}},{key:\"_replaceHosts\",value:function _replaceHosts(e){return mergeInDomOrder({list:e,elements:this.inDocument,resolveElement:this._resolveHostElement.bind(this)})}},{key:\"_resolveHostElement\",value:function _resolveHostElement(e){var n=mergeInDomOrder({list:this.elements[e._sortingId],elements:this.inHost[e._sortingId],resolveElement:this._resolveHostElement.bind(this)});var t=tabindexValue(e);if(t!==null&&t>-1){return[e].concat(n)}return n}},{key:\"_cleanup\",value:function _cleanup(){Object.keys(this.hosts).forEach((function(e){delete this.hosts[e]._sortingId}),this)}}]);return Shadows}();function sortShadowed(e,n,t){var r=new qe(n,t);var a=r.extractElements(e);if(a.length===e.length){return t(e)}return r.sort(a)}function sortTabindex(e){var n={};var t=[];var r=e.filter((function(e){var r=e.tabIndex;if(r===undefined){r=tabindexValue(e)}if(r<=0||r===null||r===undefined){return true}if(!n[r]){n[r]=[];t.push(r)}n[r].push(e);return false}));var a=t.sort().map((function(e){return n[e]})).reduceRight((function(e,n){return n.concat(e)}),r);return a}var Ue=void 0;function moveContextToBeginning(e,n){var t=e.indexOf(n);if(t>0){var r=e.splice(t,1);return r.concat(e)}return e}function sortElements(e,n){if(Ue.tabsequenceAreaAtImgPosition){e=sortArea(e,n)}e=sortTabindex(e);return e}function queryTabsequence(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.context,t=e.includeContext,r=e.includeOnlyTabbable,a=e.strategy;if(!Ue){Ue=_supports()}var o=nodeArray(n)[0]||document.documentElement;var i=queryTabbable({context:o,includeContext:t,includeOnlyTabbable:r,strategy:a});if(document.body.createShadowRoot&&s.is.BLINK){i=sortShadowed(i,o,sortElements)}else{i=sortElements(i,o)}if(t){i=moveContextToBeginning(i,o)}return i}var We={tab:9,left:37,up:38,right:39,down:40,pageUp:33,\"page-up\":33,pageDown:34,\"page-down\":34,end:35,home:36,enter:13,escape:27,space:32,shift:16,capsLock:20,\"caps-lock\":20,ctrl:17,alt:18,meta:91,pause:19,insert:45,delete:46,backspace:8,_alias:{91:[92,93,224]}};for(var Ve=1;Ve<26;Ve++){We[\"f\"+Ve]=Ve+111}for(var Ke=0;Ke<10;Ke++){var Ze=Ke+48;var Ge=Ke+96;We[Ke]=Ze;We[\"num-\"+Ke]=Ge;We._alias[Ze]=[Ge]}for(var Ye=0;Ye<26;Ye++){var Je=Ye+65;var $e=String.fromCharCode(Je).toLowerCase();We[$e]=Je}var Xe={alt:\"altKey\",ctrl:\"ctrlKey\",meta:\"metaKey\",shift:\"shiftKey\"};var Qe=Object.keys(Xe).map((function(e){return Xe[e]}));function createExpectedModifiers(e){var n=e?null:false;return{altKey:n,ctrlKey:n,metaKey:n,shiftKey:n}}function resolveModifiers(e){var n=e.indexOf(\"*\")!==-1;var t=createExpectedModifiers(n);e.forEach((function(e){if(e===\"*\"){return}var n=true;var r=e.slice(0,1);if(r===\"?\"){n=null}else if(r===\"!\"){n=false}if(n!==true){e=e.slice(1)}var a=Xe[e];if(!a){throw new TypeError('Unknown modifier \"'+e+'\"')}t[a]=n}));return t}function resolveKey(e){var n=We[e]||parseInt(e,10);if(!n||typeof n!==\"number\"||isNaN(n)){throw new TypeError('Unknown key \"'+e+'\"')}return[n].concat(We._alias[n]||[])}function matchModifiers(e,n){return!Qe.some((function(t){return typeof e[t]===\"boolean\"&&Boolean(n[t])!==e[t]}))}function keyBinding(e){return e.split(/\\s+/).map((function(e){var n=e.split(\"+\");var t=resolveModifiers(n.slice(0,-1));var r=resolveKey(n.slice(-1));return{keyCodes:r,modifiers:t,matchModifiers:matchModifiers.bind(null,t)}}))}function getParentComparator(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{},n=e.parent,t=e.element,r=e.includeSelf;if(n){return function isChildOf(e){return Boolean(r&&e===n||n.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_CONTAINED_BY)}}else if(t){return function isParentOf(e){return Boolean(r&&t===e||e.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_CONTAINED_BY)}}throw new TypeError(\"util/compare-position#getParentComparator required either options.parent or options.element\")}function whenKey(){var e=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var n={};var t=nodeArray(e.context)[0]||document.documentElement;delete e.context;var r=nodeArray(e.filter);delete e.filter;var a=Object.keys(e);if(!a.length){throw new TypeError(\"when/key requires at least one option key\")}var o=function registerBinding(e){e.keyCodes.forEach((function(t){if(!n[t]){n[t]=[]}n[t].push(e)}))};a.forEach((function(n){if(typeof e[n]!==\"function\"){throw new TypeError('when/key requires option[\"'+n+'\"] to be a function')}var t=function addCallback(t){t.callback=e[n];return t};keyBinding(n).map(t).forEach(o)}));var i=function handleKeyDown(e){if(e.defaultPrevented){return}if(r.length){var a=getParentComparator({element:e.target,includeSelf:true});if(r.some(a)){return}}var o=e.keyCode||e.which;if(!n[o]){return}n[o].forEach((function(n){if(!n.matchModifiers(e)){return}n.callback.call(t,e,l)}))};t.addEventListener(\"keydown\",i,false);var l=function disengage(){t.removeEventListener(\"keydown\",i,false)};return{disengage:l}}function default_1(e){var n=e===void 0?{}:e,t=n.context;if(!t){t=document.documentElement}queryTabsequence();return whenKey({\"?alt+?shift+tab\":function altShiftTab(e){e.preventDefault();var n=queryTabsequence({context:t});var r=e.shiftKey;var a=n[0];var o=n[n.length-1];var i=r?a:o;var l=r?o:a;if(isActiveElement(i)){l.focus();return}var s=void 0;var u=n.some((function(e,n){if(!isActiveElement(e)){return false}s=n;return true}));if(!u){a.focus();return}var c=r?-1:1;n[s+c].focus()}})}n[\"default\"]=default_1},993:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};n.__esModule=true;n.styles=void 0;var a=t(910);var o=(0,a.noop)(i||(i=r([\"\\n  [data-nextjs-dialog-overlay] {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    overflow: auto;\\n    z-index: 9000;\\n\\n    display: flex;\\n    align-content: center;\\n    align-items: center;\\n    flex-direction: column;\\n    padding: 10vh 15px 0;\\n  }\\n\\n  @media (max-height: 812px) {\\n    [data-nextjs-dialog-overlay] {\\n      padding: 15px 15px 0;\\n    }\\n  }\\n\\n  [data-nextjs-dialog-backdrop] {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    background-color: rgba(17, 17, 17, 0.2);\\n    pointer-events: all;\\n    z-index: -1;\\n  }\\n\\n  [data-nextjs-dialog-backdrop-fixed] {\\n    cursor: not-allowed;\\n    -webkit-backdrop-filter: blur(8px);\\n    backdrop-filter: blur(8px);\\n  }\\n\"],[\"\\n  [data-nextjs-dialog-overlay] {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    overflow: auto;\\n    z-index: 9000;\\n\\n    display: flex;\\n    align-content: center;\\n    align-items: center;\\n    flex-direction: column;\\n    padding: 10vh 15px 0;\\n  }\\n\\n  @media (max-height: 812px) {\\n    [data-nextjs-dialog-overlay] {\\n      padding: 15px 15px 0;\\n    }\\n  }\\n\\n  [data-nextjs-dialog-backdrop] {\\n    position: fixed;\\n    top: 0;\\n    right: 0;\\n    bottom: 0;\\n    left: 0;\\n    background-color: rgba(17, 17, 17, 0.2);\\n    pointer-events: all;\\n    z-index: -1;\\n  }\\n\\n  [data-nextjs-dialog-backdrop-fixed] {\\n    cursor: not-allowed;\\n    -webkit-backdrop-filter: blur(8px);\\n    backdrop-filter: blur(8px);\\n  }\\n\"])));n.styles=o;var i},338:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};var i=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};n.__esModule=true;n.ShadowPortal=void 0;var l=o(t(522));var s=t(255);var u=function Portal(e){var n=e.children,t=e.globalOverlay;var r=l.useRef(null);var a=l.useRef(null);var o=l.useRef(null);var u=i(l.useState(),2),c=u[1];l.useLayoutEffect((function(){var e=t?document:r.current.ownerDocument;a.current=e.createElement(\"nextjs-portal\");o.current=a.current.attachShadow({mode:\"open\"});e.body.appendChild(a.current);c({});return function(){if(a.current&&a.current.ownerDocument){a.current.ownerDocument.body.removeChild(a.current)}}}),[t]);return o.current?(0,s.createPortal)(n,o.current):t?null:l.createElement(\"span\",{ref:r})};n.ShadowPortal=u},215:function(e,n,t){var r=this&&this.__assign||function(){r=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return r.apply(this,arguments)};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};var l=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};n.__esModule=true;n.Terminal=void 0;var s=l(t(997));var u=i(t(522));var c=function Terminal(e){var n=e.content;var t=u.useMemo((function(){return s[\"default\"].ansiToJson(n,{json:true,use_classes:true,remove_empty:true})}),[n]);return u.createElement(\"div\",{\"data-nextjs-terminal\":true},u.createElement(\"pre\",null,t.map((function(e,n){return u.createElement(\"span\",{key:\"terminal-entry-\".concat(n),style:r({color:e.fg?\"var(--color-\".concat(e.fg,\")\"):undefined},e.decoration===\"bold\"?{fontWeight:800}:e.decoration===\"italic\"?{fontStyle:\"italic\"}:undefined)},e.content)}))))};n.Terminal=c},236:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});n.__esModule=true;n.Terminal=void 0;var a=t(215);r(n,a,\"Terminal\")},488:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};n.__esModule=true;n.styles=void 0;var a=t(910);var o=(0,a.noop)(i||(i=r([\"\\n  [data-nextjs-terminal] {\\n    border-radius: var(--size-gap-half);\\n    background-color: var(--color-ansi-bg);\\n    color: var(--color-ansi-fg);\\n  }\\n  [data-nextjs-terminal]::selection,\\n  [data-nextjs-terminal] *::selection {\\n    background-color: var(--color-ansi-selection);\\n  }\\n  [data-nextjs-terminal] * {\\n    color: inherit;\\n    background-color: transparent;\\n    font-family: var(--font-stack-monospace);\\n  }\\n  [data-nextjs-terminal] > * {\\n    margin: 0;\\n    padding: calc(var(--size-gap) + var(--size-gap-half))\\n      calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n\\n  [data-nextjs-terminal] pre {\\n    white-space: pre-wrap;\\n    word-break: break-word;\\n  }\\n\"],[\"\\n  [data-nextjs-terminal] {\\n    border-radius: var(--size-gap-half);\\n    background-color: var(--color-ansi-bg);\\n    color: var(--color-ansi-fg);\\n  }\\n  [data-nextjs-terminal]::selection,\\n  [data-nextjs-terminal] *::selection {\\n    background-color: var(--color-ansi-selection);\\n  }\\n  [data-nextjs-terminal] * {\\n    color: inherit;\\n    background-color: transparent;\\n    font-family: var(--font-stack-monospace);\\n  }\\n  [data-nextjs-terminal] > * {\\n    margin: 0;\\n    padding: calc(var(--size-gap) + var(--size-gap-half))\\n      calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n\\n  [data-nextjs-terminal] pre {\\n    white-space: pre-wrap;\\n    word-break: break-word;\\n  }\\n\"])));n.styles=o;var i},683:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.Toast=void 0;var i=o(t(522));var l=function Toast(e){var n=e.onClick,t=e.children,r=e.className;return i.createElement(\"div\",{\"data-nextjs-toast\":true,onClick:n,className:r},i.createElement(\"div\",{\"data-nextjs-toast-wrapper\":true},t))};n.Toast=l},120:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});n.__esModule=true;n.Toast=n.styles=void 0;var a=t(69);r(n,a,\"styles\");var o=t(683);r(n,o,\"Toast\")},69:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};n.__esModule=true;n.styles=void 0;var a=t(910);var o=(0,a.noop)(i||(i=r([\"\\n  [data-nextjs-toast] {\\n    position: fixed;\\n    bottom: var(--size-gap-double);\\n    left: var(--size-gap-double);\\n    max-width: 420px;\\n    z-index: 9000;\\n  }\\n\\n  @media (max-width: 440px) {\\n    [data-nextjs-toast] {\\n      max-width: 90vw;\\n      left: 5vw;\\n    }\\n  }\\n\\n  [data-nextjs-toast-wrapper] {\\n    padding: 16px;\\n    border-radius: var(--size-gap-half);\\n    font-weight: 500;\\n    color: var(--color-ansi-bright-white);\\n    background-color: var(--color-ansi-red);\\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\\n      rgba(0, 0, 0, 0.25);\\n  }\\n\"],[\"\\n  [data-nextjs-toast] {\\n    position: fixed;\\n    bottom: var(--size-gap-double);\\n    left: var(--size-gap-double);\\n    max-width: 420px;\\n    z-index: 9000;\\n  }\\n\\n  @media (max-width: 440px) {\\n    [data-nextjs-toast] {\\n      max-width: 90vw;\\n      left: 5vw;\\n    }\\n  }\\n\\n  [data-nextjs-toast-wrapper] {\\n    padding: 16px;\\n    border-radius: var(--size-gap-half);\\n    font-weight: 500;\\n    color: var(--color-ansi-bright-white);\\n    background-color: var(--color-ansi-red);\\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\\n      rgba(0, 0, 0, 0.25);\\n  }\\n\"])));n.styles=o;var i},936:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.styles=n.BuildError=void 0;var l=i(t(522));var s=t(651);var u=t(278);var c=t(236);var f=t(910);var d=function BuildError(e){var n=e.message;var t=l.useCallback((function(){}),[]);return l.createElement(u.Overlay,{fixed:true},l.createElement(s.Dialog,{type:\"error\",\"aria-labelledby\":\"nextjs__container_build_error_label\",\"aria-describedby\":\"nextjs__container_build_error_desc\",onClose:t},l.createElement(s.DialogContent,null,l.createElement(s.DialogHeader,{className:\"nextjs-container-build-error-header\"},l.createElement(\"h4\",{id:\"nextjs__container_build_error_label\"},\"Failed to compile\")),l.createElement(s.DialogBody,{className:\"nextjs-container-build-error-body\"},l.createElement(c.Terminal,{content:n}),l.createElement(\"footer\",null,l.createElement(\"p\",{id:\"nextjs__container_build_error_desc\"},l.createElement(\"small\",null,\"This error occurred during the build process and can only be dismissed by fixing the error.\")))))))};n.BuildError=d;n.styles=(0,f.noop)(v||(v=r([\"\\n  .nextjs-container-build-error-header > h4 {\\n    line-height: 1.5;\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  .nextjs-container-build-error-body footer {\\n    margin-top: var(--size-gap);\\n  }\\n  .nextjs-container-build-error-body footer p {\\n    margin: 0;\\n  }\\n\\n  .nextjs-container-build-error-body small {\\n    color: #757575;\\n  }\\n\"],[\"\\n  .nextjs-container-build-error-header > h4 {\\n    line-height: 1.5;\\n    margin: 0;\\n    padding: 0;\\n  }\\n\\n  .nextjs-container-build-error-body footer {\\n    margin-top: var(--size-gap);\\n  }\\n  .nextjs-container-build-error-body footer p {\\n    margin: 0;\\n  }\\n\\n  .nextjs-container-build-error-body small {\\n    color: #757575;\\n  }\\n\"])));var v},355:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__assign||function(){a=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return a.apply(this,arguments)};var o=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var i=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var l=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))o(n,e,t);i(n,e);return n};var s=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};n.__esModule=true;n.styles=n.Errors=void 0;var u=l(t(522));var c=t(851);var f=t(651);var d=t(732);var v=t(278);var p=t(120);var m=t(403);var b=t(233);var g=t(910);var h=t(865);var y=t(484);function getErrorSignature(e){var n=e.event;switch(n.type){case c.TYPE_UNHANDLED_ERROR:case c.TYPE_UNHANDLED_REJECTION:{return\"\".concat(n.reason.name,\"::\").concat(n.reason.message,\"::\").concat(n.reason.stack)}default:{}}var t=n;return\"\"}var x=function HotlinkedText(e){var n=e.text;var t=/https?:\\/\\/[^\\s/$.?#].[^\\s\"]*/i;return u.createElement(u.Fragment,null,t.test(n)?n.split(\" \").map((function(e,n,r){if(t.test(e)){return u.createElement(u.Fragment,{key:\"link-\".concat(n)},u.createElement(\"a\",{href:e},e),n===r.length-1?\"\":\" \")}return n===r.length-1?u.createElement(u.Fragment,{key:\"text-\".concat(n)},e):u.createElement(u.Fragment,{key:\"text-\".concat(n)},e,\" \")})):n)};var w=function Errors(e){var n=e.errors;var t=s(u.useState({}),2),r=t[0],o=t[1];var i=s(u.useMemo((function(){var e=[];var t=null;for(var a=0;a<n.length;++a){var o=n[a];var i=o.id;if(i in r){e.push(r[i]);continue}if(a>0){var l=n[a-1];if(getErrorSignature(l)===getErrorSignature(o)){continue}}t=o;break}return[e,t]}),[n,r]),2),l=i[0],c=i[1];var g=u.useMemo((function(){return l.length<1&&Boolean(n.length)}),[n.length,l.length]);u.useEffect((function(){if(c==null){return}var e=true;(0,m.getErrorByType)(c).then((function(n){if(e){o((function(e){var t;return a(a({},e),(t={},t[n.id]=n,t))}))}}),(function(){}));return function(){e=false}}),[c]);var w=s(u.useState(\"fullscreen\"),2),_=w[0],E=w[1];var j=s(u.useState(0),2),O=j[0],k=j[1];var S=u.useCallback((function(e){e===null||e===void 0?void 0:e.preventDefault();k((function(e){return Math.max(0,e-1)}))}),[]);var T=u.useCallback((function(e){e===null||e===void 0?void 0:e.preventDefault();k((function(e){return Math.max(0,Math.min(l.length-1,e+1))}))}),[l.length]);var C=u.useMemo((function(){var e;return(e=l[O])!==null&&e!==void 0?e:null}),[O,l]);u.useEffect((function(){if(n.length<1){o({});E(\"hidden\");k(0)}}),[n.length]);var D=u.useCallback((function(e){e===null||e===void 0?void 0:e.preventDefault();E(\"minimized\")}),[]);var M=u.useCallback((function(e){e===null||e===void 0?void 0:e.preventDefault();E(\"hidden\")}),[]);var P=u.useCallback((function(e){e===null||e===void 0?void 0:e.preventDefault();E(\"fullscreen\")}),[]);if(n.length<1||C==null){return null}if(g){return u.createElement(v.Overlay,null)}if(_===\"hidden\"){return null}if(_===\"minimized\"){return u.createElement(p.Toast,{className:\"nextjs-toast-errors-parent\",onClick:P},u.createElement(\"div\",{className:\"nextjs-toast-errors\"},u.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",width:\"24\",height:\"24\",viewBox:\"0 0 24 24\",fill:\"none\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"},u.createElement(\"circle\",{cx:\"12\",cy:\"12\",r:\"10\"}),u.createElement(\"line\",{x1:\"12\",y1:\"8\",x2:\"12\",y2:\"12\"}),u.createElement(\"line\",{x1:\"12\",y1:\"16\",x2:\"12.01\",y2:\"16\"})),u.createElement(\"span\",null,l.length,\" error\",l.length>1?\"s\":\"\"),u.createElement(\"button\",{\"data-nextjs-toast-errors-hide-button\":true,className:\"nextjs-toast-errors-hide-button\",type:\"button\",onClick:function(e){e.stopPropagation();M()},\"aria-label\":\"Hide Errors\"},u.createElement(h.CloseIcon,null))))}var z=[\"server\",\"edge-server\"].includes((0,b.getErrorSource)(C.error)||\"\");return u.createElement(v.Overlay,null,u.createElement(f.Dialog,{type:\"error\",\"aria-labelledby\":\"nextjs__container_errors_label\",\"aria-describedby\":\"nextjs__container_errors_desc\",onClose:z?undefined:D},u.createElement(f.DialogContent,null,u.createElement(f.DialogHeader,{className:\"nextjs-container-errors-header\"},u.createElement(d.LeftRightDialogHeader,{previous:O>0?S:null,next:O<l.length-1?T:null,close:z?undefined:D},u.createElement(\"small\",null,u.createElement(\"span\",null,O+1),\" of\",\" \",u.createElement(\"span\",null,l.length),\" unhandled error\",l.length<2?\"\":\"s\")),u.createElement(\"h1\",{id:\"nextjs__container_errors_label\"},z?\"Server Error\":\"Unhandled Runtime Error\"),u.createElement(\"p\",{id:\"nextjs__container_errors_desc\"},C.error.name,\":\",\" \",u.createElement(x,{text:C.error.message})),z?u.createElement(\"div\",null,u.createElement(\"small\",null,\"This error happened while generating the page. Any console logs will be displayed in the terminal window.\")):undefined),u.createElement(f.DialogBody,{className:\"nextjs-container-errors-body\"},u.createElement(y.RuntimeError,{key:C.id.toString(),error:C})))))};n.Errors=w;n.styles=(0,g.noop)(_||(_=r([\"\\n  .nextjs-container-errors-header > h1 {\\n    font-size: var(--size-font-big);\\n    line-height: var(--size-font-bigger);\\n    font-weight: bold;\\n    margin: 0;\\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n  .nextjs-container-errors-header small {\\n    font-size: var(--size-font-small);\\n    color: var(--color-accents-1);\\n    margin-left: var(--size-gap-double);\\n  }\\n  .nextjs-container-errors-header small > span {\\n    font-family: var(--font-stack-monospace);\\n  }\\n  .nextjs-container-errors-header > p {\\n    font-family: var(--font-stack-monospace);\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-big);\\n    font-weight: bold;\\n    margin: 0;\\n    margin-top: var(--size-gap-half);\\n    color: var(--color-ansi-red);\\n    white-space: pre-wrap;\\n  }\\n  .nextjs-container-errors-header > div > small {\\n    margin: 0;\\n    margin-top: var(--size-gap-half);\\n  }\\n  .nextjs-container-errors-header > p > a {\\n    color: var(--color-ansi-red);\\n  }\\n\\n  .nextjs-container-errors-body > h5:not(:first-child) {\\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\\n  }\\n  .nextjs-container-errors-body > h5 {\\n    margin-bottom: var(--size-gap);\\n  }\\n\\n  .nextjs-toast-errors-parent {\\n    cursor: pointer;\\n    transition: transform 0.2s ease;\\n  }\\n  .nextjs-toast-errors-parent:hover {\\n    transform: scale(1.1);\\n  }\\n  .nextjs-toast-errors {\\n    display: flex;\\n    align-items: center;\\n    justify-content: flex-start;\\n  }\\n  .nextjs-toast-errors > svg {\\n    margin-right: var(--size-gap);\\n  }\\n  .nextjs-toast-errors-hide-button {\\n    margin-left: var(--size-gap-triple);\\n    border: none;\\n    background: none;\\n    color: var(--color-ansi-bright-white);\\n    padding: 0;\\n    transition: opacity 0.25s ease;\\n    opacity: 0.7;\\n  }\\n  .nextjs-toast-errors-hide-button:hover {\\n    opacity: 1;\\n  }\\n\"],[\"\\n  .nextjs-container-errors-header > h1 {\\n    font-size: var(--size-font-big);\\n    line-height: var(--size-font-bigger);\\n    font-weight: bold;\\n    margin: 0;\\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\\n  }\\n  .nextjs-container-errors-header small {\\n    font-size: var(--size-font-small);\\n    color: var(--color-accents-1);\\n    margin-left: var(--size-gap-double);\\n  }\\n  .nextjs-container-errors-header small > span {\\n    font-family: var(--font-stack-monospace);\\n  }\\n  .nextjs-container-errors-header > p {\\n    font-family: var(--font-stack-monospace);\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-big);\\n    font-weight: bold;\\n    margin: 0;\\n    margin-top: var(--size-gap-half);\\n    color: var(--color-ansi-red);\\n    white-space: pre-wrap;\\n  }\\n  .nextjs-container-errors-header > div > small {\\n    margin: 0;\\n    margin-top: var(--size-gap-half);\\n  }\\n  .nextjs-container-errors-header > p > a {\\n    color: var(--color-ansi-red);\\n  }\\n\\n  .nextjs-container-errors-body > h5:not(:first-child) {\\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\\n  }\\n  .nextjs-container-errors-body > h5 {\\n    margin-bottom: var(--size-gap);\\n  }\\n\\n  .nextjs-toast-errors-parent {\\n    cursor: pointer;\\n    transition: transform 0.2s ease;\\n  }\\n  .nextjs-toast-errors-parent:hover {\\n    transform: scale(1.1);\\n  }\\n  .nextjs-toast-errors {\\n    display: flex;\\n    align-items: center;\\n    justify-content: flex-start;\\n  }\\n  .nextjs-toast-errors > svg {\\n    margin-right: var(--size-gap);\\n  }\\n  .nextjs-toast-errors-hide-button {\\n    margin-left: var(--size-gap-triple);\\n    border: none;\\n    background: none;\\n    color: var(--color-ansi-bright-white);\\n    padding: 0;\\n    transition: opacity 0.25s ease;\\n    opacity: 0.7;\\n  }\\n  .nextjs-toast-errors-hide-button:hover {\\n    opacity: 1;\\n  }\\n\"])));var _},484:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};var l=this&&this.__read||function(e,n){var t=typeof Symbol===\"function\"&&e[Symbol.iterator];if(!t)return e;var r=t.call(e),a,o=[],i;try{while((n===void 0||n-- >0)&&!(a=r.next()).done)o.push(a.value)}catch(e){i={error:e}}finally{try{if(a&&!a.done&&(t=r[\"return\"]))t.call(r)}finally{if(i)throw i.error}}return o};n.__esModule=true;n.RuntimeError=n.styles=void 0;var s=i(t(522));var u=t(413);var c=t(910);var f=t(504);var d=function CallStackFrame(e){var n;var t=e.frame;var r=(n=t.originalStackFrame)!==null&&n!==void 0?n:t.sourceStackFrame;var a=Boolean(t.originalCodeFrame);var o=s.useCallback((function(){var e;if(!a)return;var n=new URLSearchParams;for(var t in r){n.append(t,((e=r[t])!==null&&e!==void 0?e:\"\").toString())}self.fetch(\"\".concat( false||\"\",\"/__nextjs_launch-editor?\").concat(n.toString())).then((function(){}),(function(){console.error(\"There was an issue opening this code in your editor.\")}))}),[a,r]);return s.createElement(\"div\",{\"data-nextjs-call-stack-frame\":true},s.createElement(\"h6\",{\"data-nextjs-frame-expanded\":Boolean(t.expanded)},r.methodName),s.createElement(\"div\",{\"data-has-source\":a?\"true\":undefined,tabIndex:a?10:undefined,role:a?\"link\":undefined,onClick:o,title:a?\"Click to open in your editor\":undefined},s.createElement(\"span\",null,(0,f.getFrameSource)(r)),s.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",viewBox:\"0 0 24 24\",fill:\"none\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"},s.createElement(\"path\",{d:\"M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6\"}),s.createElement(\"polyline\",{points:\"15 3 21 3 21 9\"}),s.createElement(\"line\",{x1:\"10\",y1:\"14\",x2:\"21\",y2:\"3\"}))))};var v=function RuntimeError(e){var n=e.error;var t=s.useMemo((function(){return n.frames.findIndex((function(e){return e.expanded&&Boolean(e.originalCodeFrame)&&Boolean(e.originalStackFrame)}))}),[n.frames]);var r=s.useMemo((function(){var e;return(e=n.frames[t])!==null&&e!==void 0?e:null}),[n.frames,t]);var a=s.useMemo((function(){return t<0?[]:n.frames.slice(0,t)}),[n.frames,t]);var o=l(s.useState(r==null),2),i=o[0],c=o[1];var f=s.useCallback((function(){c((function(e){return!e}))}),[]);var v=s.useMemo((function(){return a.filter((function(e){return e.expanded||i}))}),[i,a]);var p=s.useMemo((function(){return n.frames.slice(t+1)}),[n.frames,t]);var m=s.useMemo((function(){return p.filter((function(e){return e.expanded||i}))}),[i,p]);var b=s.useMemo((function(){return p.length!==m.length||i&&r!=null}),[i,p.length,r,m.length]);return s.createElement(s.Fragment,null,r?s.createElement(s.Fragment,null,s.createElement(\"h5\",null,\"Source\"),v.map((function(e,n){return s.createElement(d,{key:\"leading-frame-\".concat(n,\"-\").concat(i),frame:e})})),s.createElement(u.CodeFrame,{stackFrame:r.originalStackFrame,codeFrame:r.originalCodeFrame})):undefined,m.length?s.createElement(s.Fragment,null,s.createElement(\"h5\",null,\"Call Stack\"),m.map((function(e,n){return s.createElement(d,{key:\"call-stack-\".concat(n,\"-\").concat(i),frame:e})}))):undefined,b?s.createElement(s.Fragment,null,s.createElement(\"button\",{tabIndex:10,\"data-nextjs-data-runtime-error-collapsed-action\":true,type:\"button\",onClick:f},i?\"Hide\":\"Show\",\" collapsed frames\")):undefined)};n.RuntimeError=v;n.styles=(0,c.noop)(p||(p=r([\"\\n  button[data-nextjs-data-runtime-error-collapsed-action] {\\n    background: none;\\n    border: none;\\n    padding: 0;\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-bigger);\\n    color: var(--color-accents-3);\\n  }\\n\\n  [data-nextjs-call-stack-frame]:not(:last-child) {\\n    margin-bottom: var(--size-gap-double);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"],[\"\\n  button[data-nextjs-data-runtime-error-collapsed-action] {\\n    background: none;\\n    border: none;\\n    padding: 0;\\n    font-size: var(--size-font-small);\\n    line-height: var(--size-font-bigger);\\n    color: var(--color-accents-3);\\n  }\\n\\n  [data-nextjs-call-stack-frame]:not(:last-child) {\\n    margin-bottom: var(--size-gap-double);\\n  }\\n\\n  [data-nextjs-call-stack-frame] > h6 {\\n    margin-top: 0;\\n    margin-bottom: var(--size-gap);\\n    font-family: var(--font-stack-monospace);\\n    color: #222;\\n  }\\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\\n    color: #666;\\n  }\\n  [data-nextjs-call-stack-frame] > div {\\n    display: flex;\\n    align-items: center;\\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\\n    font-size: var(--size-font-small);\\n    color: #999;\\n  }\\n  [data-nextjs-call-stack-frame] > div > svg {\\n    width: auto;\\n    height: var(--size-font-small);\\n    margin-left: var(--size-gap);\\n\\n    display: none;\\n  }\\n\\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\\n    cursor: pointer;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\\n    text-decoration: underline dotted;\\n  }\\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\\n    display: unset;\\n  }\\n\"])));var p},403:function(e,n,t){var r=this&&this.__awaiter||function(e,n,t,r){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,a){function fulfilled(e){try{step(r.next(e))}catch(e){a(e)}}function rejected(e){try{step(r[\"throw\"](e))}catch(e){a(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((r=r.apply(e,n||[])).next())}))};var a=this&&this.__generator||function(e,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},r,a,o,i;return i={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol===\"function\"&&(i[Symbol.iterator]=function(){return this}),i;function verb(e){return function(n){return step([e,n])}}function step(i){if(r)throw new TypeError(\"Generator is already executing.\");while(t)try{if(r=1,a&&(o=i[0]&2?a[\"return\"]:i[0]?a[\"throw\"]||((o=a[\"return\"])&&o.call(a),0):a.next)&&!(o=o.call(a,i[1])).done)return o;if(a=0,o)i=[i[0]&2,o.value];switch(i[0]){case 0:case 1:o=i;break;case 4:t.label++;return{value:i[1],done:false};case 5:t.label++;a=i[1];i=[0];continue;case 7:i=t.ops.pop();t.trys.pop();continue;default:if(!(o=t.trys,o=o.length>0&&o[o.length-1])&&(i[0]===6||i[0]===2)){t=0;continue}if(i[0]===3&&(!o||i[1]>o[0]&&i[1]<o[3])){t.label=i[1];break}if(i[0]===6&&t.label<o[1]){t.label=o[1];o=i;break}if(o&&t.label<o[2]){t.label=o[2];t.ops.push(i);break}if(o[2])t.ops.pop();t.trys.pop();continue}i=n.call(e,t)}catch(e){i=[6,e];a=0}finally{r=o=0}if(i[0]&5)throw i[1];return{value:i[0]?i[1]:void 0,done:true}}};n.__esModule=true;n.getErrorByType=void 0;var o=t(851);var i=t(233);var l=t(504);function getErrorByType(e){return r(this,void 0,void 0,(function(){var n,t,r,s;var u;return a(this,(function(a){switch(a.label){case 0:n=e.id,t=e.event;r=t.type;switch(r){case o.TYPE_UNHANDLED_ERROR:return[3,1];case o.TYPE_UNHANDLED_REJECTION:return[3,1]}return[3,3];case 1:u={id:n,runtime:true,error:t.reason};return[4,(0,l.getOriginalStackFrames)(t.frames,(0,i.getErrorSource)(t.reason),t.reason.toString())];case 2:return[2,(u.frames=a.sent(),u)];case 3:{return[3,4]}a.label=4;case 4:s=t;throw new Error(\"type system invariant violation\")}}))}))}n.getErrorByType=getErrorByType},233:function(e,n,t){var r=this&&this.__assign||function(){r=Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)if(Object.prototype.hasOwnProperty.call(n,a))e[a]=n[a]}return e};return r.apply(this,arguments)};n.__esModule=true;n.getServerError=n.decorateServerError=n.getErrorSource=n.getFilesystemFrame=void 0;var a=t(974);function getFilesystemFrame(e){var n=r({},e);if(typeof n.file===\"string\"){if(n.file.startsWith(\"/\")||/^[a-z]:\\\\/i.test(n.file)||n.file.startsWith(\"\\\\\\\\\")){n.file=\"file://\".concat(n.file)}}return n}n.getFilesystemFrame=getFilesystemFrame;var o=Symbol(\"NextjsError\");function getErrorSource(e){return e[o]||null}n.getErrorSource=getErrorSource;function decorateServerError(e,n){Object.defineProperty(e,o,{writable:false,enumerable:false,configurable:false,value:n})}n.decorateServerError=decorateServerError;function getServerError(e,n){var t;try{throw new Error(e.message)}catch(e){t=e}t.name=e.name;try{t.stack=\"\".concat(t.toString(),\"\\n\").concat((0,a.parse)(e.stack).map(getFilesystemFrame).map((function(e){var n=\"    at \".concat(e.methodName);if(e.file){var t=e.file;if(e.lineNumber){t+=\":\".concat(e.lineNumber);if(e.column){t+=\":\".concat(e.column)}}n+=\" (\".concat(t,\")\")}return n})).join(\"\\n\"))}catch(n){t.stack=e.stack}decorateServerError(t,n);return t}n.getServerError=getServerError},910:function(e,n){n.__esModule=true;n.noop=void 0;function noop(e){var n=[];for(var t=1;t<arguments.length;t++){n[t-1]=arguments[t]}var r=e.length-1;return e.slice(0,r).reduce((function(e,t,r){return e+t+n[r]}),\"\")+e[r]}n.noop=noop},636:function(e,n,t){n.__esModule=true;n.parseStack=void 0;var r=t(974);var a=/\\/_next(\\/static\\/.+)/g;function parseStack(e){var n=(0,r.parse)(e);return n.map((function(e){var n,t;try{var r=new URL(e.file);var o=a.exec(r.pathname);if(o){var i=(t=(n=\"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\.next\")===null||n===void 0?void 0:n.replace(/\\\\/g,\"/\"))===null||t===void 0?void 0:t.replace(/\\/$/,\"\");if(i){e.file=\"file://\"+i.concat(o.pop())}}}catch(e){}return e}))}n.parseStack=parseStack},504:function(e,n){var t=this&&this.__awaiter||function(e,n,t,r){function adopt(e){return e instanceof t?e:new t((function(n){n(e)}))}return new(t||(t=Promise))((function(t,a){function fulfilled(e){try{step(r.next(e))}catch(e){a(e)}}function rejected(e){try{step(r[\"throw\"](e))}catch(e){a(e)}}function step(e){e.done?t(e.value):adopt(e.value).then(fulfilled,rejected)}step((r=r.apply(e,n||[])).next())}))};var r=this&&this.__generator||function(e,n){var t={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},r,a,o,i;return i={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol===\"function\"&&(i[Symbol.iterator]=function(){return this}),i;function verb(e){return function(n){return step([e,n])}}function step(i){if(r)throw new TypeError(\"Generator is already executing.\");while(t)try{if(r=1,a&&(o=i[0]&2?a[\"return\"]:i[0]?a[\"throw\"]||((o=a[\"return\"])&&o.call(a),0):a.next)&&!(o=o.call(a,i[1])).done)return o;if(a=0,o)i=[i[0]&2,o.value];switch(i[0]){case 0:case 1:o=i;break;case 4:t.label++;return{value:i[1],done:false};case 5:t.label++;a=i[1];i=[0];continue;case 7:i=t.ops.pop();t.trys.pop();continue;default:if(!(o=t.trys,o=o.length>0&&o[o.length-1])&&(i[0]===6||i[0]===2)){t=0;continue}if(i[0]===3&&(!o||i[1]>o[0]&&i[1]<o[3])){t.label=i[1];break}if(i[0]===6&&t.label<o[1]){t.label=o[1];o=i;break}if(o&&t.label<o[2]){t.label=o[2];t.ops.push(i);break}if(o[2])t.ops.pop();t.trys.pop();continue}i=n.call(e,t)}catch(e){i=[6,e];a=0}finally{r=o=0}if(i[0]&5)throw i[1];return{value:i[0]?i[1]:void 0,done:true}}};n.__esModule=true;n.getFrameSource=n.getOriginalStackFrames=n.getOriginalStackFrame=void 0;function getOriginalStackFrame(e,n,a){var o,i;function _getOriginalStackFrame(){var o,i,l,s,u;return t(this,void 0,void 0,(function(){var t,c,f,d,v,p,m,b,g;return r(this,(function(r){switch(r.label){case 0:t=new URLSearchParams;t.append(\"isServer\",String(n===\"server\"));t.append(\"isEdgeServer\",String(n===\"edge-server\"));t.append(\"errorMessage\",a);for(c in e){t.append(c,((o=e[c])!==null&&o!==void 0?o:\"\").toString())}f=new AbortController;d=setTimeout((function(){return f.abort()}),3e3);return[4,self.fetch(\"\".concat( false||\"\",\"/__nextjs_original-stack-frame?\").concat(t.toString()),{signal:f.signal})[\"finally\"]((function(){clearTimeout(d)}))];case 1:v=r.sent();if(!(!v.ok||v.status===204))return[3,3];m=(p=Promise).reject;b=Error.bind;return[4,v.text()];case 2:return[2,m.apply(p,[new(b.apply(Error,[void 0,r.sent()]))])];case 3:return[4,v.json()];case 4:g=r.sent();return[2,{error:false,reason:null,external:false,expanded:!Boolean((u=((i=e.file)===null||i===void 0?void 0:i.includes(\"node_modules\"))||((s=(l=g.originalStackFrame)===null||l===void 0?void 0:l.file)===null||s===void 0?void 0:s.includes(\"node_modules\")))!==null&&u!==void 0?u:true),sourceStackFrame:e,originalStackFrame:g.originalStackFrame,originalCodeFrame:g.originalCodeFrame||null}]}}))}))}if(!(((o=e.file)===null||o===void 0?void 0:o.startsWith(\"webpack-internal:\"))||((i=e.file)===null||i===void 0?void 0:i.startsWith(\"file:\")))){return Promise.resolve({error:false,reason:null,external:true,expanded:false,sourceStackFrame:e,originalStackFrame:null,originalCodeFrame:null})}return _getOriginalStackFrame()[\"catch\"]((function(n){var t,r;return{error:true,reason:(r=(t=n===null||n===void 0?void 0:n.message)!==null&&t!==void 0?t:n===null||n===void 0?void 0:n.toString())!==null&&r!==void 0?r:\"Unknown Error\",external:false,expanded:false,sourceStackFrame:e,originalStackFrame:null,originalCodeFrame:null}}))}n.getOriginalStackFrame=getOriginalStackFrame;function getOriginalStackFrames(e,n,t){return Promise.all(e.map((function(e){return getOriginalStackFrame(e,n,t)})))}n.getOriginalStackFrames=getOriginalStackFrames;function getFrameSource(e){var n;var t=\"\";try{var r=new URL(e.file);if(typeof globalThis!==\"undefined\"&&((n=globalThis.location)===null||n===void 0?void 0:n.origin)!==r.origin){if(r.origin===\"null\"){t+=r.protocol}else{t+=r.origin}}t+=r.pathname;t+=\" \"}catch(n){t+=(e.file||\"(unknown)\")+\" \"}if(e.lineNumber!=null){if(e.column!=null){t+=\"(\".concat(e.lineNumber,\":\").concat(e.column,\") \")}else{t+=\"(\".concat(e.lineNumber,\") \")}}return t.slice(0,-1)}n.getFrameSource=getFrameSource},169:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.useOnClickOutside=void 0;var i=o(t(522));function useOnClickOutside(e,n){i.useEffect((function(){if(e==null||n==null){return}var listener=function(t){if(!e||e.contains(t.target)){return}n(t)};var t=e.getRootNode();t.addEventListener(\"mousedown\",listener);t.addEventListener(\"touchstart\",listener);return function(){t.removeEventListener(\"mousedown\",listener);t.removeEventListener(\"touchstart\",listener)}}),[n,e])}n.useOnClickOutside=useOnClickOutside},865:function(e,n,t){var r=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var a=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))r(n,e,t);a(n,e);return n};n.__esModule=true;n.CloseIcon=void 0;var i=o(t(522));var CloseIcon=function(){return i.createElement(\"svg\",{width:\"24\",height:\"24\",viewBox:\"0 0 24 24\",fill:\"none\",xmlns:\"http://www.w3.org/2000/svg\"},i.createElement(\"path\",{d:\"M18 6L6 18\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}),i.createElement(\"path\",{d:\"M6 6L18 18\",stroke:\"currentColor\",strokeWidth:\"2\",strokeLinecap:\"round\",strokeLinejoin:\"round\"}))};n.CloseIcon=CloseIcon},884:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.Base=void 0;var l=i(t(522));var s=t(910);function Base(){return l.createElement(\"style\",null,(0,s.noop)(u||(u=r([\"\\n        :host {\\n          --size-gap-half: 4px;\\n          --size-gap: 8px;\\n          --size-gap-double: 16px;\\n          --size-gap-triple: 24px;\\n          --size-gap-quad: 32px;\\n\\n          --size-font-small: 14px;\\n          --size-font: 16px;\\n          --size-font-big: 20px;\\n          --size-font-bigger: 24px;\\n\\n          --color-accents-1: #808080;\\n          --color-accents-2: #222222;\\n          --color-accents-3: #404040;\\n\\n          --font-stack-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono',\\n            Menlo, Courier, monospace;\\n\\n          --color-ansi-selection: rgba(95, 126, 151, 0.48);\\n          --color-ansi-bg: #111111;\\n          --color-ansi-fg: #cccccc;\\n\\n          --color-ansi-white: #777777;\\n          --color-ansi-black: #141414;\\n          --color-ansi-blue: #00aaff;\\n          --color-ansi-cyan: #88ddff;\\n          --color-ansi-green: #98ec65;\\n          --color-ansi-magenta: #aa88ff;\\n          --color-ansi-red: #ff5555;\\n          --color-ansi-yellow: #ffcc33;\\n          --color-ansi-bright-white: #ffffff;\\n          --color-ansi-bright-black: #777777;\\n          --color-ansi-bright-blue: #33bbff;\\n          --color-ansi-bright-cyan: #bbecff;\\n          --color-ansi-bright-green: #b6f292;\\n          --color-ansi-bright-magenta: #cebbff;\\n          --color-ansi-bright-red: #ff8888;\\n          --color-ansi-bright-yellow: #ffd966;\\n        }\\n\\n        .mono {\\n          font-family: var(--font-stack-monospace);\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-bottom: var(--size-gap);\\n          font-weight: 500;\\n          line-height: 1.5;\\n        }\\n\\n        h1 {\\n          font-size: 40px;\\n        }\\n        h2 {\\n          font-size: 32px;\\n        }\\n        h3 {\\n          font-size: 28px;\\n        }\\n        h4 {\\n          font-size: 24px;\\n        }\\n        h5 {\\n          font-size: 20px;\\n        }\\n        h6 {\\n          font-size: 16px;\\n        }\\n      \"],[\"\\n        :host {\\n          --size-gap-half: 4px;\\n          --size-gap: 8px;\\n          --size-gap-double: 16px;\\n          --size-gap-triple: 24px;\\n          --size-gap-quad: 32px;\\n\\n          --size-font-small: 14px;\\n          --size-font: 16px;\\n          --size-font-big: 20px;\\n          --size-font-bigger: 24px;\\n\\n          --color-accents-1: #808080;\\n          --color-accents-2: #222222;\\n          --color-accents-3: #404040;\\n\\n          --font-stack-monospace: 'SFMono-Regular', Consolas, 'Liberation Mono',\\n            Menlo, Courier, monospace;\\n\\n          --color-ansi-selection: rgba(95, 126, 151, 0.48);\\n          --color-ansi-bg: #111111;\\n          --color-ansi-fg: #cccccc;\\n\\n          --color-ansi-white: #777777;\\n          --color-ansi-black: #141414;\\n          --color-ansi-blue: #00aaff;\\n          --color-ansi-cyan: #88ddff;\\n          --color-ansi-green: #98ec65;\\n          --color-ansi-magenta: #aa88ff;\\n          --color-ansi-red: #ff5555;\\n          --color-ansi-yellow: #ffcc33;\\n          --color-ansi-bright-white: #ffffff;\\n          --color-ansi-bright-black: #777777;\\n          --color-ansi-bright-blue: #33bbff;\\n          --color-ansi-bright-cyan: #bbecff;\\n          --color-ansi-bright-green: #b6f292;\\n          --color-ansi-bright-magenta: #cebbff;\\n          --color-ansi-bright-red: #ff8888;\\n          --color-ansi-bright-yellow: #ffd966;\\n        }\\n\\n        .mono {\\n          font-family: var(--font-stack-monospace);\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-bottom: var(--size-gap);\\n          font-weight: 500;\\n          line-height: 1.5;\\n        }\\n\\n        h1 {\\n          font-size: 40px;\\n        }\\n        h2 {\\n          font-size: 32px;\\n        }\\n        h3 {\\n          font-size: 28px;\\n        }\\n        h4 {\\n          font-size: 24px;\\n        }\\n        h5 {\\n          font-size: 20px;\\n        }\\n        h6 {\\n          font-size: 16px;\\n        }\\n      \"]))))}n.Base=Base;var u},464:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.ComponentStyles=void 0;var l=i(t(522));var s=t(399);var u=t(651);var c=t(543);var f=t(993);var d=t(488);var v=t(120);var p=t(936);var m=t(355);var b=t(484);var g=t(910);function ComponentStyles(){return l.createElement(\"style\",null,(0,g.noop)(h||(h=r([\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \\n        \",\"\\n        \",\"\\n        \",\"\\n      \"],[\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \",\"\\n        \\n        \",\"\\n        \",\"\\n        \",\"\\n      \"])),f.styles,v.styles,u.styles,c.styles,s.styles,d.styles,p.styles,m.styles,b.styles))}n.ComponentStyles=ComponentStyles;var h},495:function(e,n,t){var r=this&&this.__makeTemplateObject||function(e,n){if(Object.defineProperty){Object.defineProperty(e,\"raw\",{value:n})}else{e.raw=n}return e};var a=this&&this.__createBinding||(Object.create?function(e,n,t,r){if(r===undefined)r=t;var a=Object.getOwnPropertyDescriptor(n,t);if(!a||(\"get\"in a?!n.__esModule:a.writable||a.configurable)){a={enumerable:true,get:function(){return n[t]}}}Object.defineProperty(e,r,a)}:function(e,n,t,r){if(r===undefined)r=t;e[r]=n[t]});var o=this&&this.__setModuleDefault||(Object.create?function(e,n){Object.defineProperty(e,\"default\",{enumerable:true,value:n})}:function(e,n){e[\"default\"]=n});var i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(e!=null)for(var t in e)if(t!==\"default\"&&Object.prototype.hasOwnProperty.call(e,t))a(n,e,t);o(n,e);return n};n.__esModule=true;n.CssReset=void 0;var l=i(t(522));var s=t(910);function CssReset(){return l.createElement(\"style\",null,(0,s.noop)(u||(u=r([\"\\n        :host {\\n          all: initial;\\n\\n          /* the direction property is not reset by 'all' */\\n          direction: ltr;\\n        }\\n\\n        /*!\\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\\n         * Copyright 2011-2019 The Bootstrap Authors\\n         * Copyright 2011-2019 Twitter, Inc.\\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\\n         */\\n        *,\\n        *::before,\\n        *::after {\\n          box-sizing: border-box;\\n        }\\n\\n        :host {\\n          font-family: sans-serif;\\n          line-height: 1.15;\\n          -webkit-text-size-adjust: 100%;\\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n        }\\n\\n        article,\\n        aside,\\n        figcaption,\\n        figure,\\n        footer,\\n        header,\\n        hgroup,\\n        main,\\n        nav,\\n        section {\\n          display: block;\\n        }\\n\\n        :host {\\n          margin: 0;\\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\\n            'Noto Color Emoji';\\n          font-size: 16px;\\n          font-weight: 400;\\n          line-height: 1.5;\\n          color: #212529;\\n          text-align: left;\\n          background-color: #fff;\\n        }\\n\\n        [tabindex='-1']:focus:not(:focus-visible) {\\n          outline: 0 !important;\\n        }\\n\\n        hr {\\n          box-sizing: content-box;\\n          height: 0;\\n          overflow: visible;\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-top: 0;\\n          margin-bottom: 8px;\\n        }\\n\\n        p {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        abbr[title],\\n        abbr[data-original-title] {\\n          text-decoration: underline;\\n          -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n          cursor: help;\\n          border-bottom: 0;\\n          -webkit-text-decoration-skip-ink: none;\\n          text-decoration-skip-ink: none;\\n        }\\n\\n        address {\\n          margin-bottom: 16px;\\n          font-style: normal;\\n          line-height: inherit;\\n        }\\n\\n        ol,\\n        ul,\\n        dl {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        ol ol,\\n        ul ul,\\n        ol ul,\\n        ul ol {\\n          margin-bottom: 0;\\n        }\\n\\n        dt {\\n          font-weight: 700;\\n        }\\n\\n        dd {\\n          margin-bottom: 8px;\\n          margin-left: 0;\\n        }\\n\\n        blockquote {\\n          margin: 0 0 16px;\\n        }\\n\\n        b,\\n        strong {\\n          font-weight: bolder;\\n        }\\n\\n        small {\\n          font-size: 80%;\\n        }\\n\\n        sub,\\n        sup {\\n          position: relative;\\n          font-size: 75%;\\n          line-height: 0;\\n          vertical-align: baseline;\\n        }\\n\\n        sub {\\n          bottom: -0.25em;\\n        }\\n\\n        sup {\\n          top: -0.5em;\\n        }\\n\\n        a {\\n          color: #007bff;\\n          text-decoration: none;\\n          background-color: transparent;\\n        }\\n\\n        a:hover {\\n          color: #0056b3;\\n          text-decoration: underline;\\n        }\\n\\n        a:not([href]) {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        a:not([href]):hover {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        pre,\\n        code,\\n        kbd,\\n        samp {\\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\\n            'Liberation Mono', 'Courier New', monospace;\\n          font-size: 1em;\\n        }\\n\\n        pre {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n          overflow: auto;\\n        }\\n\\n        figure {\\n          margin: 0 0 16px;\\n        }\\n\\n        img {\\n          vertical-align: middle;\\n          border-style: none;\\n        }\\n\\n        svg {\\n          overflow: hidden;\\n          vertical-align: middle;\\n        }\\n\\n        table {\\n          border-collapse: collapse;\\n        }\\n\\n        caption {\\n          padding-top: 12px;\\n          padding-bottom: 12px;\\n          color: #6c757d;\\n          text-align: left;\\n          caption-side: bottom;\\n        }\\n\\n        th {\\n          text-align: inherit;\\n        }\\n\\n        label {\\n          display: inline-block;\\n          margin-bottom: 8px;\\n        }\\n\\n        button {\\n          border-radius: 0;\\n        }\\n\\n        button:focus {\\n          outline: 1px dotted;\\n          outline: 5px auto -webkit-focus-ring-color;\\n        }\\n\\n        input,\\n        button,\\n        select,\\n        optgroup,\\n        textarea {\\n          margin: 0;\\n          font-family: inherit;\\n          font-size: inherit;\\n          line-height: inherit;\\n        }\\n\\n        button,\\n        input {\\n          overflow: visible;\\n        }\\n\\n        button,\\n        select {\\n          text-transform: none;\\n        }\\n\\n        select {\\n          word-wrap: normal;\\n        }\\n\\n        button,\\n        [type='button'],\\n        [type='reset'],\\n        [type='submit'] {\\n          -webkit-appearance: button;\\n        }\\n\\n        button:not(:disabled),\\n        [type='button']:not(:disabled),\\n        [type='reset']:not(:disabled),\\n        [type='submit']:not(:disabled) {\\n          cursor: pointer;\\n        }\\n\\n        button::-moz-focus-inner,\\n        [type='button']::-moz-focus-inner,\\n        [type='reset']::-moz-focus-inner,\\n        [type='submit']::-moz-focus-inner {\\n          padding: 0;\\n          border-style: none;\\n        }\\n\\n        input[type='radio'],\\n        input[type='checkbox'] {\\n          box-sizing: border-box;\\n          padding: 0;\\n        }\\n\\n        input[type='date'],\\n        input[type='time'],\\n        input[type='datetime-local'],\\n        input[type='month'] {\\n          -webkit-appearance: listbox;\\n        }\\n\\n        textarea {\\n          overflow: auto;\\n          resize: vertical;\\n        }\\n\\n        fieldset {\\n          min-width: 0;\\n          padding: 0;\\n          margin: 0;\\n          border: 0;\\n        }\\n\\n        legend {\\n          display: block;\\n          width: 100%;\\n          max-width: 100%;\\n          padding: 0;\\n          margin-bottom: 8px;\\n          font-size: 24px;\\n          line-height: inherit;\\n          color: inherit;\\n          white-space: normal;\\n        }\\n\\n        progress {\\n          vertical-align: baseline;\\n        }\\n\\n        [type='number']::-webkit-inner-spin-button,\\n        [type='number']::-webkit-outer-spin-button {\\n          height: auto;\\n        }\\n\\n        [type='search'] {\\n          outline-offset: -2px;\\n          -webkit-appearance: none;\\n        }\\n\\n        [type='search']::-webkit-search-decoration {\\n          -webkit-appearance: none;\\n        }\\n\\n        ::-webkit-file-upload-button {\\n          font: inherit;\\n          -webkit-appearance: button;\\n        }\\n\\n        output {\\n          display: inline-block;\\n        }\\n\\n        summary {\\n          display: list-item;\\n          cursor: pointer;\\n        }\\n\\n        template {\\n          display: none;\\n        }\\n\\n        [hidden] {\\n          display: none !important;\\n        }\\n      \"],[\"\\n        :host {\\n          all: initial;\\n\\n          /* the direction property is not reset by 'all' */\\n          direction: ltr;\\n        }\\n\\n        /*!\\n         * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\\n         * Copyright 2011-2019 The Bootstrap Authors\\n         * Copyright 2011-2019 Twitter, Inc.\\n         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n         * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\\n         */\\n        *,\\n        *::before,\\n        *::after {\\n          box-sizing: border-box;\\n        }\\n\\n        :host {\\n          font-family: sans-serif;\\n          line-height: 1.15;\\n          -webkit-text-size-adjust: 100%;\\n          -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\\n        }\\n\\n        article,\\n        aside,\\n        figcaption,\\n        figure,\\n        footer,\\n        header,\\n        hgroup,\\n        main,\\n        nav,\\n        section {\\n          display: block;\\n        }\\n\\n        :host {\\n          margin: 0;\\n          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\\n            'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\\n            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\\n            'Noto Color Emoji';\\n          font-size: 16px;\\n          font-weight: 400;\\n          line-height: 1.5;\\n          color: #212529;\\n          text-align: left;\\n          background-color: #fff;\\n        }\\n\\n        [tabindex='-1']:focus:not(:focus-visible) {\\n          outline: 0 !important;\\n        }\\n\\n        hr {\\n          box-sizing: content-box;\\n          height: 0;\\n          overflow: visible;\\n        }\\n\\n        h1,\\n        h2,\\n        h3,\\n        h4,\\n        h5,\\n        h6 {\\n          margin-top: 0;\\n          margin-bottom: 8px;\\n        }\\n\\n        p {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        abbr[title],\\n        abbr[data-original-title] {\\n          text-decoration: underline;\\n          -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n          cursor: help;\\n          border-bottom: 0;\\n          -webkit-text-decoration-skip-ink: none;\\n          text-decoration-skip-ink: none;\\n        }\\n\\n        address {\\n          margin-bottom: 16px;\\n          font-style: normal;\\n          line-height: inherit;\\n        }\\n\\n        ol,\\n        ul,\\n        dl {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n        }\\n\\n        ol ol,\\n        ul ul,\\n        ol ul,\\n        ul ol {\\n          margin-bottom: 0;\\n        }\\n\\n        dt {\\n          font-weight: 700;\\n        }\\n\\n        dd {\\n          margin-bottom: 8px;\\n          margin-left: 0;\\n        }\\n\\n        blockquote {\\n          margin: 0 0 16px;\\n        }\\n\\n        b,\\n        strong {\\n          font-weight: bolder;\\n        }\\n\\n        small {\\n          font-size: 80%;\\n        }\\n\\n        sub,\\n        sup {\\n          position: relative;\\n          font-size: 75%;\\n          line-height: 0;\\n          vertical-align: baseline;\\n        }\\n\\n        sub {\\n          bottom: -0.25em;\\n        }\\n\\n        sup {\\n          top: -0.5em;\\n        }\\n\\n        a {\\n          color: #007bff;\\n          text-decoration: none;\\n          background-color: transparent;\\n        }\\n\\n        a:hover {\\n          color: #0056b3;\\n          text-decoration: underline;\\n        }\\n\\n        a:not([href]) {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        a:not([href]):hover {\\n          color: inherit;\\n          text-decoration: none;\\n        }\\n\\n        pre,\\n        code,\\n        kbd,\\n        samp {\\n          font-family: SFMono-Regular, Menlo, Monaco, Consolas,\\n            'Liberation Mono', 'Courier New', monospace;\\n          font-size: 1em;\\n        }\\n\\n        pre {\\n          margin-top: 0;\\n          margin-bottom: 16px;\\n          overflow: auto;\\n        }\\n\\n        figure {\\n          margin: 0 0 16px;\\n        }\\n\\n        img {\\n          vertical-align: middle;\\n          border-style: none;\\n        }\\n\\n        svg {\\n          overflow: hidden;\\n          vertical-align: middle;\\n        }\\n\\n        table {\\n          border-collapse: collapse;\\n        }\\n\\n        caption {\\n          padding-top: 12px;\\n          padding-bottom: 12px;\\n          color: #6c757d;\\n          text-align: left;\\n          caption-side: bottom;\\n        }\\n\\n        th {\\n          text-align: inherit;\\n        }\\n\\n        label {\\n          display: inline-block;\\n          margin-bottom: 8px;\\n        }\\n\\n        button {\\n          border-radius: 0;\\n        }\\n\\n        button:focus {\\n          outline: 1px dotted;\\n          outline: 5px auto -webkit-focus-ring-color;\\n        }\\n\\n        input,\\n        button,\\n        select,\\n        optgroup,\\n        textarea {\\n          margin: 0;\\n          font-family: inherit;\\n          font-size: inherit;\\n          line-height: inherit;\\n        }\\n\\n        button,\\n        input {\\n          overflow: visible;\\n        }\\n\\n        button,\\n        select {\\n          text-transform: none;\\n        }\\n\\n        select {\\n          word-wrap: normal;\\n        }\\n\\n        button,\\n        [type='button'],\\n        [type='reset'],\\n        [type='submit'] {\\n          -webkit-appearance: button;\\n        }\\n\\n        button:not(:disabled),\\n        [type='button']:not(:disabled),\\n        [type='reset']:not(:disabled),\\n        [type='submit']:not(:disabled) {\\n          cursor: pointer;\\n        }\\n\\n        button::-moz-focus-inner,\\n        [type='button']::-moz-focus-inner,\\n        [type='reset']::-moz-focus-inner,\\n        [type='submit']::-moz-focus-inner {\\n          padding: 0;\\n          border-style: none;\\n        }\\n\\n        input[type='radio'],\\n        input[type='checkbox'] {\\n          box-sizing: border-box;\\n          padding: 0;\\n        }\\n\\n        input[type='date'],\\n        input[type='time'],\\n        input[type='datetime-local'],\\n        input[type='month'] {\\n          -webkit-appearance: listbox;\\n        }\\n\\n        textarea {\\n          overflow: auto;\\n          resize: vertical;\\n        }\\n\\n        fieldset {\\n          min-width: 0;\\n          padding: 0;\\n          margin: 0;\\n          border: 0;\\n        }\\n\\n        legend {\\n          display: block;\\n          width: 100%;\\n          max-width: 100%;\\n          padding: 0;\\n          margin-bottom: 8px;\\n          font-size: 24px;\\n          line-height: inherit;\\n          color: inherit;\\n          white-space: normal;\\n        }\\n\\n        progress {\\n          vertical-align: baseline;\\n        }\\n\\n        [type='number']::-webkit-inner-spin-button,\\n        [type='number']::-webkit-outer-spin-button {\\n          height: auto;\\n        }\\n\\n        [type='search'] {\\n          outline-offset: -2px;\\n          -webkit-appearance: none;\\n        }\\n\\n        [type='search']::-webkit-search-decoration {\\n          -webkit-appearance: none;\\n        }\\n\\n        ::-webkit-file-upload-button {\\n          font: inherit;\\n          -webkit-appearance: button;\\n        }\\n\\n        output {\\n          display: inline-block;\\n        }\\n\\n        summary {\\n          display: list-item;\\n          cursor: pointer;\\n        }\\n\\n        template {\\n          display: none;\\n        }\\n\\n        [hidden] {\\n          display: none !important;\\n        }\\n      \"]))))}n.CssReset=CssReset;var u},997:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/anser */ \"./node_modules/next/dist/compiled/anser/index.js\")},292:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/css.escape */ \"./node_modules/next/dist/compiled/css.escape/css.escape.js\")},709:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/platform */ \"./node_modules/next/dist/compiled/platform/platform.js\")},974:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/stacktrace-parser */ \"./node_modules/next/dist/compiled/stacktrace-parser/stack-trace-parser.cjs.js\")},518:function(e){e.exports=__webpack_require__(/*! next/dist/compiled/strip-ansi */ \"./node_modules/next/dist/compiled/strip-ansi/index.js\")},522:function(e){e.exports=__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\")},255:function(e){e.exports=__webpack_require__(/*! react-dom */ \"./node_modules/next/dist/compiled/react-dom/index.js\")}};var n={};function __nccwpck_require__(t){var r=n[t];if(r!==undefined){return r.exports}var a=n[t]={exports:{}};var o=true;try{e[t].call(a.exports,a,a.exports,__nccwpck_require__);o=false}finally{if(o)delete n[t]}return a.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(204);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2Rpc3QvY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLGFBQWEsT0FBTyxvQkFBb0IsbUVBQW1FLHFCQUFxQiwyQ0FBMkMsNkRBQTZELEdBQUcsK0JBQStCLGNBQWMsNkJBQTZCLG1CQUFtQixxQkFBcUIsVUFBVSxFQUFFLGtFQUFrRSxtQ0FBbUMsd0JBQXdCLEVBQUUsZUFBZSxlQUFlLEVBQUUsMkNBQTJDLDRCQUE0QixTQUFTLCtGQUErRixPQUFPLFVBQVUsa0JBQWtCLDRJQUE0SSxnQkFBZ0IsYUFBYSxZQUFZLGdCQUFnQiw2QkFBNkIsMENBQTBDLHlEQUF5RCxPQUFPLHlFQUF5RSw0RkFBNEYsUUFBUSxRQUFRLHNFQUFzRSxFQUFFLGlDQUFpQywyQ0FBMkMseURBQXlELE9BQU8sUUFBUSxRQUFRLDBFQUEwRSxFQUFFLG9CQUFvQixNQUFNLE9BQU8sT0FBTyxJQUFJLDRCQUE0Qix5QkFBeUIsSUFBSSxVQUFVLGtEQUFrRCxtRUFBbUUsb0JBQW9CLHNCQUFzQixPQUFPLE9BQU8sUUFBUSxrQkFBa0IsSUFBSSx3QkFBd0IsVUFBVSxZQUFZLHFEQUFxRCxzRUFBc0Usd0JBQXdCLHFCQUFxQixRQUFRLHFCQUFxQixFQUFFLHNCQUFzQix5QkFBeUIsUUFBUSxrQ0FBa0MsRUFBRSw0QkFBNEIscUJBQXFCLFFBQVEsb0JBQW9CLEVBQUUsc0JBQXNCLDJCQUEyQixRQUFRLDJCQUEyQixFQUFFLGtDQUFrQyxhQUFhLHdCQUF3QixhQUFhLHdCQUF3QixhQUFhLG1DQUFtQyxxQkFBcUIsdUNBQXVDLGdDQUFnQyxzQ0FBc0MsYUFBYSxnQ0FBZ0MsY0FBYyxnQkFBZ0IsdUVBQXVFLDJCQUEyQixxQkFBcUIseUhBQXlILG1CQUFtQixjQUFjLG1CQUFtQix5RUFBeUUsR0FBRyw4Q0FBOEMsMEJBQTBCLFlBQVksa0JBQWtCLHVCQUF1QixnQkFBZ0Isa0JBQWtC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LFVBQVUsbUJBQU8sQ0FBQyw0RkFBK0IsRUFBRSxpQkFBaUIsVUFBVSxtQkFBTyxDQUFDLCtEQUFPLEVBQUUsaUJBQWlCLFVBQVUsbUJBQU8sQ0FBQyx1RUFBVyxJQUFJLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHFEQUFxRCxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudC5qcz80ZDMwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBlPXsyMDQ6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKXIobixlLHQpO2EobixlKTtyZXR1cm4gbn07bi5fX2VzTW9kdWxlPXRydWU7bi5vblJlZnJlc2g9bi5vbkJlZm9yZVJlZnJlc2g9bi51bnJlZ2lzdGVyPW4ucmVnaXN0ZXI9bi5vbkJ1aWxkRXJyb3I9bi5vbkJ1aWxkT2s9bi5SZWFjdERldk92ZXJsYXk9bi5nZXRTZXJ2ZXJFcnJvcj1uLmdldEVycm9yQnlUeXBlPXZvaWQgMDt2YXIgaT1vKHQoODUxKSk7dmFyIGw9dCg2MzYpO3ZhciBzPWZhbHNlO3ZhciB1PXVuZGVmaW5lZDtmdW5jdGlvbiBvblVuaGFuZGxlZEVycm9yKGUpe3ZhciBuPWU9PT1udWxsfHxlPT09dm9pZCAwP3ZvaWQgMDplLmVycm9yO2lmKCFufHwhKG4gaW5zdGFuY2VvZiBFcnJvcil8fHR5cGVvZiBuLnN0YWNrIT09XCJzdHJpbmdcIil7cmV0dXJufWlmKG4ubWVzc2FnZS5tYXRjaCgvKGh5ZHJhdGlvbnxjb250ZW50IGRvZXMgbm90IG1hdGNofGRpZCBub3QgbWF0Y2gpL2kpKXtuLm1lc3NhZ2UrPVwiXFxuXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9yZWFjdC1oeWRyYXRpb24tZXJyb3JcIn12YXIgdD1uO2kuZW1pdCh7dHlwZTppLlRZUEVfVU5IQU5ETEVEX0VSUk9SLHJlYXNvbjpuLGZyYW1lczooMCxsLnBhcnNlU3RhY2spKHQuc3RhY2spfSl9ZnVuY3Rpb24gb25VbmhhbmRsZWRSZWplY3Rpb24oZSl7dmFyIG49ZT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUucmVhc29uO2lmKCFufHwhKG4gaW5zdGFuY2VvZiBFcnJvcil8fHR5cGVvZiBuLnN0YWNrIT09XCJzdHJpbmdcIil7cmV0dXJufXZhciB0PW47aS5lbWl0KHt0eXBlOmkuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OLHJlYXNvbjpuLGZyYW1lczooMCxsLnBhcnNlU3RhY2spKHQuc3RhY2spfSl9ZnVuY3Rpb24gcmVnaXN0ZXIoKXtpZihzKXtyZXR1cm59cz10cnVlO3RyeXt2YXIgZT1FcnJvci5zdGFja1RyYWNlTGltaXQ7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0PTUwO3U9ZX1jYXRjaChlKXt9d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLG9uVW5oYW5kbGVkRXJyb3IpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsb25VbmhhbmRsZWRSZWplY3Rpb24pfW4ucmVnaXN0ZXI9cmVnaXN0ZXI7ZnVuY3Rpb24gdW5yZWdpc3Rlcigpe2lmKCFzKXtyZXR1cm59cz1mYWxzZTtpZih1IT09dW5kZWZpbmVkKXt0cnl7RXJyb3Iuc3RhY2tUcmFjZUxpbWl0PXV9Y2F0Y2goZSl7fXU9dW5kZWZpbmVkfXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIixvblVuaGFuZGxlZEVycm9yKTt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVuaGFuZGxlZHJlamVjdGlvblwiLG9uVW5oYW5kbGVkUmVqZWN0aW9uKX1uLnVucmVnaXN0ZXI9dW5yZWdpc3RlcjtmdW5jdGlvbiBvbkJ1aWxkT2soKXtpLmVtaXQoe3R5cGU6aS5UWVBFX0JVSUxEX09LfSl9bi5vbkJ1aWxkT2s9b25CdWlsZE9rO2Z1bmN0aW9uIG9uQnVpbGRFcnJvcihlKXtpLmVtaXQoe3R5cGU6aS5UWVBFX0JVSUxEX0VSUk9SLG1lc3NhZ2U6ZX0pfW4ub25CdWlsZEVycm9yPW9uQnVpbGRFcnJvcjtmdW5jdGlvbiBvblJlZnJlc2goKXtpLmVtaXQoe3R5cGU6aS5UWVBFX1JFRlJFU0h9KX1uLm9uUmVmcmVzaD1vblJlZnJlc2g7ZnVuY3Rpb24gb25CZWZvcmVSZWZyZXNoKCl7aS5lbWl0KHt0eXBlOmkuVFlQRV9CRUZPUkVfUkVGUkVTSH0pfW4ub25CZWZvcmVSZWZyZXNoPW9uQmVmb3JlUmVmcmVzaDt2YXIgYz10KDQwMyk7cihuLGMsXCJnZXRFcnJvckJ5VHlwZVwiKTt2YXIgZj10KDIzMyk7cihuLGYsXCJnZXRTZXJ2ZXJFcnJvclwiKTt2YXIgZD10KDIyMik7cihuLGQsXCJkZWZhdWx0XCIsXCJSZWFjdERldk92ZXJsYXlcIil9LDc5MDpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIGV4dGVuZFN0YXRpY3M9ZnVuY3Rpb24oZSxuKXtleHRlbmRTdGF0aWNzPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihlLG4pe2UuX19wcm90b19fPW59fHxmdW5jdGlvbihlLG4pe2Zvcih2YXIgdCBpbiBuKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHQpKWVbdF09blt0XX07cmV0dXJuIGV4dGVuZFN0YXRpY3MoZSxuKX07cmV0dXJuIGZ1bmN0aW9uKGUsbil7aWYodHlwZW9mIG4hPT1cImZ1bmN0aW9uXCImJm4hPT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiK1N0cmluZyhuKStcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO2V4dGVuZFN0YXRpY3MoZSxuKTtmdW5jdGlvbiBfXygpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1uPT09bnVsbD9PYmplY3QuY3JlYXRlKG4pOihfXy5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IF9fKX19KCk7dmFyIGE9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07bi5fX2VzTW9kdWxlPXRydWU7bi5FcnJvckJvdW5kYXJ5PXZvaWQgMDt2YXIgbz1hKHQoNTIyKSk7dmFyIGk9ZnVuY3Rpb24oZSl7cihFcnJvckJvdW5kYXJ5LGUpO2Z1bmN0aW9uIEVycm9yQm91bmRhcnkoKXt2YXIgbj1lIT09bnVsbCYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7bi5zdGF0ZT17ZXJyb3I6bnVsbH07cmV0dXJuIG59RXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I9ZnVuY3Rpb24oZSl7cmV0dXJue2Vycm9yOmV9fTtFcnJvckJvdW5kYXJ5LnByb3RvdHlwZS5jb21wb25lbnREaWRDYXRjaD1mdW5jdGlvbihlLG4pe3RoaXMucHJvcHMub25FcnJvcihlLChuPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5jb21wb25lbnRTdGFjayl8fG51bGwpO2lmKCF0aGlzLnByb3BzLmdsb2JhbE92ZXJsYXkpe3RoaXMuc2V0U3RhdGUoe2Vycm9yOmV9KX19O0Vycm9yQm91bmRhcnkucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXRlLmVycm9yfHx0aGlzLnByb3BzLmdsb2JhbE92ZXJsYXkmJnRoaXMucHJvcHMuaXNNb3VudGVkP3RoaXMucHJvcHMuZ2xvYmFsT3ZlcmxheT9vW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLG51bGwsb1tcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImhlYWRcIixudWxsKSxvW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYm9keVwiLG51bGwpKTpudWxsOnRoaXMucHJvcHMuY2hpbGRyZW59O3JldHVybiBFcnJvckJvdW5kYXJ5fShvW1wiZGVmYXVsdFwiXS5QdXJlQ29tcG9uZW50KTtuLkVycm9yQm91bmRhcnk9aX0sMjIyOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3I9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKWEobixlLHQpO28obixlKTtyZXR1cm4gbn07dmFyIGw9dGhpcyYmdGhpcy5fX3JlYWR8fGZ1bmN0aW9uKGUsbil7dmFyIHQ9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciByPXQuY2FsbChlKSxhLG89W10saTt0cnl7d2hpbGUoKG49PT12b2lkIDB8fG4tLSA+MCkmJiEoYT1yLm5leHQoKSkuZG9uZSlvLnB1c2goYS52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7aWYoYSYmIWEuZG9uZSYmKHQ9cltcInJldHVyblwiXSkpdC5jYWxsKHIpfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gb307dmFyIHM9dGhpcyYmdGhpcy5fX3NwcmVhZEFycmF5fHxmdW5jdGlvbihlLG4sdCl7aWYodHx8YXJndW1lbnRzLmxlbmd0aD09PTIpZm9yKHZhciByPTAsYT1uLmxlbmd0aCxvO3I8YTtyKyspe2lmKG98fCEociBpbiBuKSl7aWYoIW8pbz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuLDAscik7b1tyXT1uW3JdfX1yZXR1cm4gZS5jb25jYXQob3x8QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobikpfTtuLl9fZXNNb2R1bGU9dHJ1ZTt2YXIgdT1pKHQoNTIyKSk7dmFyIGM9aSh0KDg1MSkpO3ZhciBmPXQoMzM4KTt2YXIgZD10KDkzNik7dmFyIHY9dCgzNTUpO3ZhciBwPXQoNzkwKTt2YXIgbT10KDg4NCk7dmFyIGI9dCg0NjQpO3ZhciBnPXQoNDk1KTtmdW5jdGlvbiBwdXNoRXJyb3JGaWx0ZXJEdXBsaWNhdGVzKGUsbil7cmV0dXJuIHMocyhbXSxsKGUuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5ldmVudC5yZWFzb24hPT1uLmV2ZW50LnJlYXNvbn0pKSksZmFsc2UpLFtuXSxmYWxzZSl9ZnVuY3Rpb24gcmVkdWNlcihlLG4pe3N3aXRjaChuLnR5cGUpe2Nhc2UgYy5UWVBFX0JVSUxEX09LOntyZXR1cm4gcihyKHt9LGUpLHtidWlsZEVycm9yOm51bGx9KX1jYXNlIGMuVFlQRV9CVUlMRF9FUlJPUjp7cmV0dXJuIHIocih7fSxlKSx7YnVpbGRFcnJvcjpuLm1lc3NhZ2V9KX1jYXNlIGMuVFlQRV9CRUZPUkVfUkVGUkVTSDp7cmV0dXJuIHIocih7fSxlKSx7cmVmcmVzaFN0YXRlOnt0eXBlOlwicGVuZGluZ1wiLGVycm9yczpbXX19KX1jYXNlIGMuVFlQRV9SRUZSRVNIOntyZXR1cm4gcihyKHt9LGUpLHtidWlsZEVycm9yOm51bGwsZXJyb3JzOmUucmVmcmVzaFN0YXRlLnR5cGU9PT1cInBlbmRpbmdcIj9lLnJlZnJlc2hTdGF0ZS5lcnJvcnM6W10scmVmcmVzaFN0YXRlOnt0eXBlOlwiaWRsZVwifX0pfWNhc2UgYy5UWVBFX1VOSEFORExFRF9FUlJPUjpjYXNlIGMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOntzd2l0Y2goZS5yZWZyZXNoU3RhdGUudHlwZSl7Y2FzZVwiaWRsZVwiOntyZXR1cm4gcihyKHt9LGUpLHtuZXh0SWQ6ZS5uZXh0SWQrMSxlcnJvcnM6cHVzaEVycm9yRmlsdGVyRHVwbGljYXRlcyhlLmVycm9ycyx7aWQ6ZS5uZXh0SWQsZXZlbnQ6bn0pfSl9Y2FzZVwicGVuZGluZ1wiOntyZXR1cm4gcihyKHt9LGUpLHtuZXh0SWQ6ZS5uZXh0SWQrMSxyZWZyZXNoU3RhdGU6cihyKHt9LGUucmVmcmVzaFN0YXRlKSx7ZXJyb3JzOnB1c2hFcnJvckZpbHRlckR1cGxpY2F0ZXMoZS5yZWZyZXNoU3RhdGUuZXJyb3JzLHtpZDplLm5leHRJZCxldmVudDpufSl9KX0pfWRlZmF1bHQ6dmFyIHQ9ZS5yZWZyZXNoU3RhdGU7cmV0dXJuIGV9fWRlZmF1bHQ6e3ZhciB0PW47cmV0dXJuIGV9fX12YXIgc2hvdWxkUHJldmVudERpc3BsYXk9ZnVuY3Rpb24oZSxuKXtpZighbnx8IWUpe3JldHVybiBmYWxzZX1yZXR1cm4gbi5pbmNsdWRlcyhlKX07dmFyIGg9ZnVuY3Rpb24gUmVhY3REZXZPdmVybGF5KGUpe3ZhciBuPWUuY2hpbGRyZW4sdD1lLnByZXZlbnREaXNwbGF5LHI9ZS5nbG9iYWxPdmVybGF5O3ZhciBhPWwodS51c2VSZWR1Y2VyKHJlZHVjZXIse25leHRJZDoxLGJ1aWxkRXJyb3I6bnVsbCxlcnJvcnM6W10scmVmcmVzaFN0YXRlOnt0eXBlOlwiaWRsZVwifX0pLDIpLG89YVswXSxpPWFbMV07dS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7Yy5vbihpKTtyZXR1cm4gZnVuY3Rpb24oKXtjLm9mZihpKX19KSxbaV0pO3ZhciBzPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUsbil7fSksW10pO3ZhciBoPW8uYnVpbGRFcnJvciE9bnVsbDt2YXIgeT1Cb29sZWFuKG8uZXJyb3JzLmxlbmd0aCk7dmFyIHg9aD9cImJ1aWxkXCI6eT9cInJ1bnRpbWVcIjpudWxsO3ZhciB3PXghPT1udWxsO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCxudWxsLHUuY3JlYXRlRWxlbWVudChwLkVycm9yQm91bmRhcnkse2dsb2JhbE92ZXJsYXk6cixpc01vdW50ZWQ6dyxvbkVycm9yOnN9LG4hPT1udWxsJiZuIT09dm9pZCAwP246bnVsbCksdz91LmNyZWF0ZUVsZW1lbnQoZi5TaGFkb3dQb3J0YWwse2dsb2JhbE92ZXJsYXk6cn0sdS5jcmVhdGVFbGVtZW50KGcuQ3NzUmVzZXQsbnVsbCksdS5jcmVhdGVFbGVtZW50KG0uQmFzZSxudWxsKSx1LmNyZWF0ZUVsZW1lbnQoYi5Db21wb25lbnRTdHlsZXMsbnVsbCksc2hvdWxkUHJldmVudERpc3BsYXkoeCx0KT9udWxsOmg/dS5jcmVhdGVFbGVtZW50KGQuQnVpbGRFcnJvcix7bWVzc2FnZTpvLmJ1aWxkRXJyb3J9KTp5P3UuY3JlYXRlRWxlbWVudCh2LkVycm9ycyx7ZXJyb3JzOm8uZXJyb3JzfSk6dW5kZWZpbmVkKTp1bmRlZmluZWQpfTtuW1wiZGVmYXVsdFwiXT1ofSw4NTE6ZnVuY3Rpb24oZSxuKXt2YXIgdD10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3Q9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O24uX19lc01vZHVsZT10cnVlO24ub2ZmPW4ub249bi5lbWl0PW4uVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OPW4uVFlQRV9VTkhBTkRMRURfRVJST1I9bi5UWVBFX0JFRk9SRV9SRUZSRVNIPW4uVFlQRV9SRUZSRVNIPW4uVFlQRV9CVUlMRF9FUlJPUj1uLlRZUEVfQlVJTERfT0s9dm9pZCAwO24uVFlQRV9CVUlMRF9PSz1cImJ1aWxkLW9rXCI7bi5UWVBFX0JVSUxEX0VSUk9SPVwiYnVpbGQtZXJyb3JcIjtuLlRZUEVfUkVGUkVTSD1cImZhc3QtcmVmcmVzaFwiO24uVFlQRV9CRUZPUkVfUkVGUkVTSD1cImJlZm9yZS1mYXN0LXJlZnJlc2hcIjtuLlRZUEVfVU5IQU5ETEVEX0VSUk9SPVwidW5oYW5kbGVkLWVycm9yXCI7bi5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT049XCJ1bmhhbmRsZWQtcmVqZWN0aW9uXCI7dmFyIHI9bmV3IFNldDt2YXIgYT1bXTtmdW5jdGlvbiBkcmFpbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dmFyIF9sb29wXzE9ZnVuY3Rpb24oKXt2YXIgZT1hLnNoaWZ0KCk7ci5mb3JFYWNoKChmdW5jdGlvbihuKXtyZXR1cm4gbihlKX0pKX07d2hpbGUoQm9vbGVhbihhLmxlbmd0aCkmJkJvb2xlYW4oci5zaXplKSl7X2xvb3BfMSgpfX0pLDEpfWZ1bmN0aW9uIGVtaXQoZSl7YS5wdXNoKE9iamVjdC5mcmVlemUodCh7fSxlKSkpO2RyYWluKCl9bi5lbWl0PWVtaXQ7ZnVuY3Rpb24gb24oZSl7aWYoci5oYXMoZSkpe3JldHVybiBmYWxzZX1yLmFkZChlKTtkcmFpbigpO3JldHVybiB0cnVlfW4ub249b247ZnVuY3Rpb24gb2ZmKGUpe2lmKHIuaGFzKGUpKXtyW1wiZGVsZXRlXCJdKGUpO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1uLm9mZj1vZmZ9LDk4NzpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2Fzc2lnbnx8ZnVuY3Rpb24oKXtyPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgbix0PTEscj1hcmd1bWVudHMubGVuZ3RoO3Q8cjt0Kyspe249YXJndW1lbnRzW3RdO2Zvcih2YXIgYSBpbiBuKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLGEpKWVbYV09blthXX1yZXR1cm4gZX07cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O3ZhciBsPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O24uX19lc01vZHVsZT10cnVlO24uQ29kZUZyYW1lPXZvaWQgMDt2YXIgcz1sKHQoOTk3KSk7dmFyIHU9aSh0KDUyMikpO3ZhciBjPWwodCg1MTgpKTt2YXIgZj10KDUwNCk7dmFyIGQ9ZnVuY3Rpb24gQ29kZUZyYW1lKGUpe3ZhciBuPWUuc3RhY2tGcmFtZSx0PWUuY29kZUZyYW1lO3ZhciBhPXUudXNlTWVtbygoZnVuY3Rpb24oKXt2YXIgZT10LnNwbGl0KC9cXHI/XFxuL2cpO3ZhciBuPWUubWFwKChmdW5jdGlvbihlKXtyZXR1cm4vXj4/ICtcXGQrICtcXHwgWyBdKy8uZXhlYygoMCxjW1wiZGVmYXVsdFwiXSkoZSkpPT09bnVsbD9udWxsOi9ePj8gK1xcZCsgK1xcfCAoICopLy5leGVjKCgwLGNbXCJkZWZhdWx0XCJdKShlKSl9KSkuZmlsdGVyKEJvb2xlYW4pLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUucG9wKCl9KSkucmVkdWNlKChmdW5jdGlvbihlLG4pe3JldHVybiBpc05hTihlKT9uLmxlbmd0aDpNYXRoLm1pbihlLG4ubGVuZ3RoKX0pLE5hTik7aWYobj4xKXt2YXIgcj1cIiBcIi5yZXBlYXQobik7cmV0dXJuIGUubWFwKChmdW5jdGlvbihlLG4pe3JldHVybn4obj1lLmluZGV4T2YoXCJ8XCIpKT9lLnN1YnN0cmluZygwLG4pK2Uuc3Vic3RyaW5nKG4pLnJlcGxhY2UocixcIlwiKTplfSkpLmpvaW4oXCJcXG5cIil9cmV0dXJuIGUuam9pbihcIlxcblwiKX0pLFt0XSk7dmFyIG89dS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBzW1wiZGVmYXVsdFwiXS5hbnNpVG9Kc29uKGEse2pzb246dHJ1ZSx1c2VfY2xhc3Nlczp0cnVlLHJlbW92ZV9lbXB0eTp0cnVlfSl9KSxbYV0pO3ZhciBpPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7dmFyIGU7dmFyIHQ9bmV3IFVSTFNlYXJjaFBhcmFtcztmb3IodmFyIHIgaW4gbil7dC5hcHBlbmQociwoKGU9bltyXSkhPT1udWxsJiZlIT09dm9pZCAwP2U6XCJcIikudG9TdHJpbmcoKSl9c2VsZi5mZXRjaChcIlwiLmNvbmNhdChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwiLFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIpLmNvbmNhdCh0LnRvU3RyaW5nKCkpKS50aGVuKChmdW5jdGlvbigpe30pLChmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUaGVyZSB3YXMgYW4gaXNzdWUgb3BlbmluZyB0aGlzIGNvZGUgaW4geW91ciBlZGl0b3IuXCIpfSkpfSksW25dKTtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtY29kZWZyYW1lXCI6dHJ1ZX0sdS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsbnVsbCx1LmNyZWF0ZUVsZW1lbnQoXCJwXCIse3JvbGU6XCJsaW5rXCIsb25DbGljazppLHRhYkluZGV4OjEsdGl0bGU6XCJDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yXCJ9LHUuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLCgwLGYuZ2V0RnJhbWVTb3VyY2UpKG4pLFwiIEAgXCIsbi5tZXRob2ROYW1lKSx1LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZpZXdCb3g6XCIwIDAgMjQgMjRcIixmaWxsOlwibm9uZVwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0sdS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIn0pLHUuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIse3BvaW50czpcIjE1IDMgMjEgMyAyMSA5XCJ9KSx1LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIse3gxOlwiMTBcIix5MTpcIjE0XCIseDI6XCIyMVwiLHkyOlwiM1wifSkpKSksdS5jcmVhdGVFbGVtZW50KFwicHJlXCIsbnVsbCxvLm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtrZXk6XCJmcmFtZS1cIi5jb25jYXQobiksc3R5bGU6cih7Y29sb3I6ZS5mZz9cInZhcigtLWNvbG9yLVwiLmNvbmNhdChlLmZnLFwiKVwiKTp1bmRlZmluZWR9LGUuZGVjb3JhdGlvbj09PVwiYm9sZFwiP3tmb250V2VpZ2h0OjgwMH06ZS5kZWNvcmF0aW9uPT09XCJpdGFsaWNcIj97Zm9udFN0eWxlOlwiaXRhbGljXCJ9OnVuZGVmaW5lZCl9LGUuY29udGVudCl9KSkpKX07bi5Db2RlRnJhbWU9ZH0sNDEzOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO24uX19lc01vZHVsZT10cnVlO24uQ29kZUZyYW1lPXZvaWQgMDt2YXIgYT10KDk4Nyk7cihuLGEsXCJDb2RlRnJhbWVcIil9LDM5OTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPXZvaWQgMDt2YXIgYT10KDkxMCk7dmFyIG89KDAsYS5ub29wKShpfHwoaT1yKFtcIlxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0ge1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIG1pbi13aWR0aDogMTAwJTtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gZGl2ID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGRpdiA+IHA6aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSBkaXYgPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gZGl2ID4gcHJlIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV06OnNlbGVjdGlvbixcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBtaW4td2lkdGg6IDEwMCU7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGRpdiA+IHAge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBkaXYgPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gZGl2ID4gcCA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIGRpdiA+IHByZSB7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIH1cXG5cIl0pKSk7bi5zdHlsZXM9bzt2YXIgaX0sNjE2OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O3ZhciBpPXRoaXMmJnRoaXMuX19yZXN0fHxmdW5jdGlvbihlLG4pe3ZhciB0PXt9O2Zvcih2YXIgciBpbiBlKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiZuLmluZGV4T2Yocik8MCl0W3JdPWVbcl07aWYoZSE9bnVsbCYmdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM9PT1cImZ1bmN0aW9uXCIpZm9yKHZhciBhPTAscj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2E8ci5sZW5ndGg7YSsrKXtpZihuLmluZGV4T2YoclthXSk8MCYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsclthXSkpdFtyW2FdXT1lW3JbYV1dfXJldHVybiB0fTt2YXIgbD10aGlzJiZ0aGlzLl9fcmVhZHx8ZnVuY3Rpb24oZSxuKXt2YXIgdD10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZlW1N5bWJvbC5pdGVyYXRvcl07aWYoIXQpcmV0dXJuIGU7dmFyIHI9dC5jYWxsKGUpLGEsbz1bXSxpO3RyeXt3aGlsZSgobj09PXZvaWQgMHx8bi0tID4wKSYmIShhPXIubmV4dCgpKS5kb25lKW8ucHVzaChhLnZhbHVlKX1jYXRjaChlKXtpPXtlcnJvcjplfX1maW5hbGx5e3RyeXtpZihhJiYhYS5kb25lJiYodD1yW1wicmV0dXJuXCJdKSl0LmNhbGwocil9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBvfTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZz12b2lkIDA7dmFyIHM9byh0KDUyMikpO3ZhciB1PXQoMTY5KTt2YXIgYz1mdW5jdGlvbiBEaWFsb2coZSl7dmFyIG49ZS5jaGlsZHJlbix0PWUudHlwZSxyPWUub25DbG9zZSxhPWkoZSxbXCJjaGlsZHJlblwiLFwidHlwZVwiLFwib25DbG9zZVwiXSk7dmFyIG89bChzLnVzZVN0YXRlKG51bGwpLDIpLGM9b1swXSxmPW9bMV07dmFyIGQ9cy51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7ZihlKX0pLFtdKTsoMCx1LnVzZU9uQ2xpY2tPdXRzaWRlKShjLHIpO3MudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKGM9PW51bGwpe3JldHVybn12YXIgZT1jLmdldFJvb3ROb2RlKCk7aWYoIShlIGluc3RhbmNlb2YgU2hhZG93Um9vdCkpe3JldHVybn12YXIgbj1lO2Z1bmN0aW9uIGhhbmRsZXIoZSl7dmFyIHQ9bi5hY3RpdmVFbGVtZW50O2lmKGUua2V5PT09XCJFbnRlclwiJiZ0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQmJnQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKT09PVwibGlua1wiKXtlLnByZXZlbnREZWZhdWx0KCk7ZS5zdG9wUHJvcGFnYXRpb24oKTt0LmNsaWNrKCl9fW4uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixoYW5kbGVyKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbi5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpfX0pLFtjXSk7cmV0dXJuIHMuY3JlYXRlRWxlbWVudChcImRpdlwiLHtyZWY6ZCxcImRhdGEtbmV4dGpzLWRpYWxvZ1wiOnRydWUsdGFiSW5kZXg6LTEscm9sZTpcImRpYWxvZ1wiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6YVtcImFyaWEtbGFiZWxsZWRieVwiXSxcImFyaWEtZGVzY3JpYmVkYnlcIjphW1wiYXJpYS1kZXNjcmliZWRieVwiXSxcImFyaWEtbW9kYWxcIjpcInRydWVcIn0scy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOnRydWUsY2xhc3NOYW1lOlwiYmFubmVyLVwiLmNvbmNhdCh0KX0pLG4pfTtuLkRpYWxvZz1jfSwxMTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZ0JvZHk9dm9pZCAwO3ZhciBpPW8odCg1MjIpKTt2YXIgbD1mdW5jdGlvbiBEaWFsb2dCb2R5KGUpe3ZhciBuPWUuY2hpbGRyZW4sdD1lLmNsYXNzTmFtZTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWJvZHlcIjp0cnVlLGNsYXNzTmFtZTp0fSxuKX07bi5EaWFsb2dCb2R5PWx9LDk5MTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZ0NvbnRlbnQ9dm9pZCAwO3ZhciBpPW8odCg1MjIpKTt2YXIgbD1mdW5jdGlvbiBEaWFsb2dDb250ZW50KGUpe3ZhciBuPWUuY2hpbGRyZW4sdD1lLmNsYXNzTmFtZTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRcIjp0cnVlLGNsYXNzTmFtZTp0fSxuKX07bi5EaWFsb2dDb250ZW50PWx9LDM0MjpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkRpYWxvZ0hlYWRlcj12b2lkIDA7dmFyIGk9byh0KDUyMikpO3ZhciBsPWZ1bmN0aW9uIERpYWxvZ0hlYWRlcihlKXt2YXIgbj1lLmNoaWxkcmVuLHQ9ZS5jbGFzc05hbWU7cmV0dXJuIGkuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJcIjp0cnVlLGNsYXNzTmFtZTp0fSxuKX07bi5EaWFsb2dIZWFkZXI9bH0sNjUxOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPW4uRGlhbG9nSGVhZGVyPW4uRGlhbG9nQ29udGVudD1uLkRpYWxvZ0JvZHk9bi5EaWFsb2c9dm9pZCAwO3ZhciBhPXQoNjE2KTtyKG4sYSxcIkRpYWxvZ1wiKTt2YXIgbz10KDExKTtyKG4sbyxcIkRpYWxvZ0JvZHlcIik7dmFyIGk9dCg5OTEpO3IobixpLFwiRGlhbG9nQ29udGVudFwiKTt2YXIgbD10KDM0Mik7cihuLGwsXCJEaWFsb2dIZWFkZXJcIik7dmFyIHM9dCgyMTMpO3IobixzLFwic3R5bGVzXCIpfSwyMTM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnN0eWxlcz12b2lkIDA7dmFyIGE9dCg5MTApO3ZhciBvPSgwLGEubm9vcCkoaXx8KGk9cihbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDU2cHgpO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdLFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1kb3VibGUpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gNTZweCk7XFxuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgICAgbWF4LWhlaWdodDogY2FsYygxMDAlIC0gMTVweCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA1NDBweDtcXG4gICAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwKSB2YXIoLS1zaXplLWdhcC1xdWFkKSByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNzIwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA5NjBweDtcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci13YXJuaW5nIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXllbGxvdyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLWVycm9yIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl06OmFmdGVyIHtcXG4gICAgei1pbmRleDogMjtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qIGJhbm5lciB3aWR0aDogKi9cXG4gICAgYm9yZGVyLXRvcC13aWR0aDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogaW5oZXJpdDtcXG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIC8qIGNhbGMocGFkZGluZyArIGJhbm5lciB3aWR0aCBvZmZzZXQpICovXFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlcl0ge1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWJvZHldIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gIH1cXG5cIl0pKSk7bi5zdHlsZXM9bzt2YXIgaX0sODMxOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O3ZhciBpPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcj10LmNhbGwoZSksYSxvPVtdLGk7dHJ5e3doaWxlKChuPT09dm9pZCAwfHxuLS0gPjApJiYhKGE9ci5uZXh0KCkpLmRvbmUpby5wdXNoKGEudmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e2lmKGEmJiFhLmRvbmUmJih0PXJbXCJyZXR1cm5cIl0pKXQuY2FsbChyKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIG99O24uX19lc01vZHVsZT10cnVlO24uTGVmdFJpZ2h0RGlhbG9nSGVhZGVyPXZvaWQgMDt2YXIgbD1vKHQoNTIyKSk7dmFyIHM9dCg4NjUpO3ZhciB1PWZ1bmN0aW9uIExlZnRSaWdodERpYWxvZ0hlYWRlcihlKXt2YXIgbj1lLmNoaWxkcmVuLHQ9ZS5jbGFzc05hbWUscj1lLnByZXZpb3VzLGE9ZS5uZXh0LG89ZS5jbG9zZTt2YXIgdT1sLnVzZVJlZihudWxsKTt2YXIgYz1sLnVzZVJlZihudWxsKTt2YXIgZj1sLnVzZVJlZihudWxsKTt2YXIgZD1pKGwudXNlU3RhdGUobnVsbCksMiksdj1kWzBdLHA9ZFsxXTt2YXIgbT1sLnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtwKGUpfSksW10pO2wudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKHY9PW51bGwpe3JldHVybn12YXIgZT12LmdldFJvb3ROb2RlKCk7dmFyIG49c2VsZi5kb2N1bWVudDtmdW5jdGlvbiBoYW5kbGVyKG4pe2lmKG4ua2V5PT09XCJBcnJvd0xlZnRcIil7bi5zdG9wUHJvcGFnYXRpb24oKTtpZih1LmN1cnJlbnQpe3UuY3VycmVudC5mb2N1cygpfXImJnIoKX1lbHNlIGlmKG4ua2V5PT09XCJBcnJvd1JpZ2h0XCIpe24uc3RvcFByb3BhZ2F0aW9uKCk7aWYoYy5jdXJyZW50KXtjLmN1cnJlbnQuZm9jdXMoKX1hJiZhKCl9ZWxzZSBpZihuLmtleT09PVwiRXNjYXBlXCIpe24uc3RvcFByb3BhZ2F0aW9uKCk7aWYoZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Qpe3ZhciB0PWUuYWN0aXZlRWxlbWVudDtpZih0JiZ0IT09Zi5jdXJyZW50JiZ0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpe3QuYmx1cigpO3JldHVybn19aWYobyl7bygpfX19ZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpO2lmKGUhPT1uKXtuLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaGFuZGxlcil9cmV0dXJuIGZ1bmN0aW9uKCl7ZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLGhhbmRsZXIpO2lmKGUhPT1uKXtuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaGFuZGxlcil9fX0pLFtvLHYsYSxyXSk7bC51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYodj09bnVsbCl7cmV0dXJufXZhciBlPXYuZ2V0Um9vdE5vZGUoKTtpZihlIGluc3RhbmNlb2YgU2hhZG93Um9vdCl7dmFyIG49ZS5hY3RpdmVFbGVtZW50O2lmKHI9PW51bGwpe2lmKHUuY3VycmVudCYmbj09PXUuY3VycmVudCl7dS5jdXJyZW50LmJsdXIoKX19ZWxzZSBpZihhPT1udWxsKXtpZihjLmN1cnJlbnQmJm49PT1jLmN1cnJlbnQpe2MuY3VycmVudC5ibHVyKCl9fX19KSxbdixhLHJdKTtyZXR1cm4gbC5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRcIjp0cnVlLGNsYXNzTmFtZTp0fSxsLmNyZWF0ZUVsZW1lbnQoXCJuYXZcIix7cmVmOm19LGwuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHtyZWY6dSx0eXBlOlwiYnV0dG9uXCIsZGlzYWJsZWQ6cj09bnVsbD90cnVlOnVuZGVmaW5lZCxcImFyaWEtZGlzYWJsZWRcIjpyPT1udWxsP3RydWU6dW5kZWZpbmVkLG9uQ2xpY2s6ciE9PW51bGwmJnIhPT12b2lkIDA/cjp1bmRlZmluZWR9LGwuY3JlYXRlRWxlbWVudChcInN2Z1wiLHt2aWV3Qm94OlwiMCAwIDE0IDE0XCIsZmlsbDpcIm5vbmVcIix4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9LGwuY3JlYXRlRWxlbWVudChcInBhdGhcIix7ZDpcIk02Ljk5OTk2IDEuMTY2NjZMMS4xNjY2MyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xMi44MzMzIDYuOTk5OTlIMS45OTk5NkgxMi44MzMzWlwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKSksbC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse3JlZjpjLHR5cGU6XCJidXR0b25cIixkaXNhYmxlZDphPT1udWxsP3RydWU6dW5kZWZpbmVkLFwiYXJpYS1kaXNhYmxlZFwiOmE9PW51bGw/dHJ1ZTp1bmRlZmluZWQsb25DbGljazphIT09bnVsbCYmYSE9PXZvaWQgMD9hOnVuZGVmaW5lZH0sbC5jcmVhdGVFbGVtZW50KFwic3ZnXCIse3ZpZXdCb3g6XCIwIDAgMTQgMTRcIixmaWxsOlwibm9uZVwiLHhtbG5zOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn0sbC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTYuOTk5OTYgMS4xNjY2NkwxMi44MzMzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEuMTY2NjMgNi45OTk5OUgxMkgxLjE2NjYzWlwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKSksXCLCoFwiLG4pLG8/bC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse1wiZGF0YS1uZXh0anMtZXJyb3JzLWRpYWxvZy1sZWZ0LXJpZ2h0LWNsb3NlLWJ1dHRvblwiOnRydWUscmVmOmYsdHlwZTpcImJ1dHRvblwiLG9uQ2xpY2s6byxcImFyaWEtbGFiZWxcIjpcIkNsb3NlXCJ9LGwuY3JlYXRlRWxlbWVudChcInNwYW5cIix7XCJhcmlhLWhpZGRlblwiOlwidHJ1ZVwifSxsLmNyZWF0ZUVsZW1lbnQocy5DbG9zZUljb24sbnVsbCkpKTpudWxsKX07bi5MZWZ0UmlnaHREaWFsb2dIZWFkZXI9dX0sNzMyOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPW4uTGVmdFJpZ2h0RGlhbG9nSGVhZGVyPXZvaWQgMDt2YXIgYT10KDgzMSk7cihuLGEsXCJMZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7dmFyIG89dCg1NDMpO3IobixvLFwic3R5bGVzXCIpfSw1NDM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnN0eWxlcz12b2lkIDA7dmFyIGE9dCg5MTApO3ZhciBvPSgwLGEubm9vcCkoaXx8KGk9cihbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSkpKTtuLnN0eWxlcz1vO3ZhciBpfSwxNzpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTt2YXIgaT10aGlzJiZ0aGlzLl9fcmVhZHx8ZnVuY3Rpb24oZSxuKXt2YXIgdD10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZlW1N5bWJvbC5pdGVyYXRvcl07aWYoIXQpcmV0dXJuIGU7dmFyIHI9dC5jYWxsKGUpLGEsbz1bXSxpO3RyeXt3aGlsZSgobj09PXZvaWQgMHx8bi0tID4wKSYmIShhPXIubmV4dCgpKS5kb25lKW8ucHVzaChhLnZhbHVlKX1jYXRjaChlKXtpPXtlcnJvcjplfX1maW5hbGx5e3RyeXtpZihhJiYhYS5kb25lJiYodD1yW1wicmV0dXJuXCJdKSl0LmNhbGwocil9ZmluYWxseXtpZihpKXRocm93IGkuZXJyb3J9fXJldHVybiBvfTt2YXIgbD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLk92ZXJsYXk9dm9pZCAwO3ZhciBzPWwodCg5NzUpKTt2YXIgdT1vKHQoNTIyKSk7dmFyIGM9dCg4MDApO3ZhciBmPWZ1bmN0aW9uIE92ZXJsYXkoZSl7dmFyIG49ZS5jbGFzc05hbWUsdD1lLmNoaWxkcmVuLHI9ZS5maXhlZDt1LnVzZUVmZmVjdCgoZnVuY3Rpb24oKXsoMCxjLmxvY2spKCk7cmV0dXJuIGZ1bmN0aW9uKCl7KDAsYy51bmxvY2spKCl9fSksW10pO3ZhciBhPWkodS51c2VTdGF0ZShudWxsKSwyKSxvPWFbMF0sbD1hWzFdO3ZhciBmPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe2woZSl9KSxbXSk7dS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYobz09bnVsbCl7cmV0dXJufXZhciBlPSgwLHNbXCJkZWZhdWx0XCJdKSh7Y29udGV4dDpvfSk7cmV0dXJuIGZ1bmN0aW9uKCl7ZS5kaXNlbmdhZ2UoKX19KSxbb10pO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheVwiOnRydWUsY2xhc3NOYW1lOm4scmVmOmZ9LHUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcFwiOnRydWUsXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjpyP3RydWU6dW5kZWZpbmVkfSksdCl9O24uT3ZlcmxheT1mfSw4MDA6ZnVuY3Rpb24oZSxuKXtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnVubG9jaz1uLmxvY2s9dm9pZCAwO3ZhciB0O3ZhciByO3ZhciBhPTA7ZnVuY3Rpb24gbG9jaygpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoYSsrPjApe3JldHVybn12YXIgZT13aW5kb3cuaW5uZXJXaWR0aC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7aWYoZT4wKXt0PWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O2RvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0PVwiXCIuY29uY2F0KGUsXCJweFwiKX1yPWRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7ZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwifSkpfW4ubG9jaz1sb2NrO2Z1bmN0aW9uIHVubG9jaygpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7aWYoYT09PTB8fC0tYSE9PTApe3JldHVybn1pZih0IT09dW5kZWZpbmVkKXtkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodD10O3Q9dW5kZWZpbmVkfWlmKHIhPT11bmRlZmluZWQpe2RvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c9cjtyPXVuZGVmaW5lZH19KSl9bi51bmxvY2s9dW5sb2NrfSwyNzg6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7bi5fX2VzTW9kdWxlPXRydWU7bi5PdmVybGF5PXZvaWQgMDt2YXIgYT10KDE3KTtyKG4sYSxcIk92ZXJsYXlcIil9LDk3NTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07bi5fX2VzTW9kdWxlPXRydWU7dmFyIGE9cih0KDcwOSkpO3ZhciBvPXIodCgyOTIpKTtmdW5jdGlvbiBub2RlQXJyYXkoZSl7aWYoIWUpe3JldHVybltdfWlmKEFycmF5LmlzQXJyYXkoZSkpe3JldHVybiBlfWlmKGUubm9kZVR5cGUhPT11bmRlZmluZWQpe3JldHVybltlXX1pZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChlKX1pZihlLmxlbmd0aCE9PXVuZGVmaW5lZCl7cmV0dXJuW10uc2xpY2UuY2FsbChlLDApfXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmV4cGVjdGVkIGlucHV0IFwiK1N0cmluZyhlKSl9ZnVuY3Rpb24gY29udGV4dFRvRWxlbWVudChlKXt2YXIgbj1lLmNvbnRleHQsdD1lLmxhYmVsLHI9dD09PXVuZGVmaW5lZD9cImNvbnRleHQtdG8tZWxlbWVudFwiOnQsYT1lLnJlc29sdmVEb2N1bWVudCxvPWUuZGVmYXVsdFRvRG9jdW1lbnQ7dmFyIGk9bm9kZUFycmF5KG4pWzBdO2lmKGEmJmkmJmkubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX05PREUpe2k9aS5kb2N1bWVudEVsZW1lbnR9aWYoIWkmJm8pe3JldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9aWYoIWkpe3Rocm93IG5ldyBUeXBlRXJyb3IocitcIiByZXF1aXJlcyB2YWxpZCBvcHRpb25zLmNvbnRleHRcIil9aWYoaS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFJiZpLm5vZGVUeXBlIT09Tm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXt0aHJvdyBuZXcgVHlwZUVycm9yKHIrXCIgcmVxdWlyZXMgb3B0aW9ucy5jb250ZXh0IHRvIGJlIGFuIEVsZW1lbnRcIil9cmV0dXJuIGl9ZnVuY3Rpb24gZ2V0U2hhZG93SG9zdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dDt2YXIgdD1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImdldC9zaGFkb3ctaG9zdFwiLGNvbnRleHQ6bn0pO3ZhciByPW51bGw7d2hpbGUodCl7cj10O3Q9dC5wYXJlbnROb2RlfWlmKHIubm9kZVR5cGU9PT1yLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJnIuaG9zdCl7cmV0dXJuIHIuaG9zdH1yZXR1cm4gbnVsbH1mdW5jdGlvbiBnZXREb2N1bWVudChlKXtpZighZSl7cmV0dXJuIGRvY3VtZW50fWlmKGUubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX05PREUpe3JldHVybiBlfXJldHVybiBlLm93bmVyRG9jdW1lbnR8fGRvY3VtZW50fWZ1bmN0aW9uIGlzQWN0aXZlRWxlbWVudChlKXt2YXIgbj1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL2FjdGl2ZS1lbGVtZW50XCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDplfSk7dmFyIHQ9Z2V0RG9jdW1lbnQobik7aWYodC5hY3RpdmVFbGVtZW50PT09bil7cmV0dXJuIHRydWV9dmFyIHI9Z2V0U2hhZG93SG9zdCh7Y29udGV4dDpufSk7aWYociYmci5zaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ9PT1uKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gZ2V0UGFyZW50cygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dDt2YXIgdD1bXTt2YXIgcj1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImdldC9wYXJlbnRzXCIsY29udGV4dDpufSk7d2hpbGUocil7dC5wdXNoKHIpO3I9ci5wYXJlbnROb2RlO2lmKHImJnIubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERSl7cj1udWxsfX1yZXR1cm4gdH12YXIgaT1bXCJtYXRjaGVzXCIsXCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3JcIixcIm1vek1hdGNoZXNTZWxlY3RvclwiLFwibXNNYXRjaGVzU2VsZWN0b3JcIl07dmFyIGw9bnVsbDtmdW5jdGlvbiBmaW5kTWV0aG9kTmFtZShlKXtpLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKCFlW25dKXtyZXR1cm4gZmFsc2V9bD1uO3JldHVybiB0cnVlfSkpfWZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGUsbil7aWYoIWwpe2ZpbmRNZXRob2ROYW1lKGUpfXJldHVybiBlW2xdKG4pfXZhciBzPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYVtcImRlZmF1bHRcIl0pKTt2YXIgdT1zLm9zLmZhbWlseXx8XCJcIjt2YXIgYz11PT09XCJBbmRyb2lkXCI7dmFyIGY9dS5zbGljZSgwLDcpPT09XCJXaW5kb3dzXCI7dmFyIGQ9dT09PVwiT1MgWFwiO3ZhciB2PXU9PT1cImlPU1wiO3ZhciBwPXMubGF5b3V0PT09XCJCbGlua1wiO3ZhciBtPXMubGF5b3V0PT09XCJHZWNrb1wiO3ZhciBiPXMubGF5b3V0PT09XCJUcmlkZW50XCI7dmFyIGc9cy5sYXlvdXQ9PT1cIkVkZ2VIVE1MXCI7dmFyIGg9cy5sYXlvdXQ9PT1cIldlYktpdFwiO3ZhciB5PXBhcnNlRmxvYXQocy52ZXJzaW9uKTt2YXIgeD1NYXRoLmZsb29yKHkpO3MubWFqb3JWZXJzaW9uPXg7cy5pcz17QU5EUk9JRDpjLFdJTkRPV1M6ZixPU1g6ZCxJT1M6dixCTElOSzpwLEdFQ0tPOm0sVFJJREVOVDpiLEVER0U6ZyxXRUJLSVQ6aCxJRTk6YiYmeD09PTksSUUxMDpiJiZ4PT09MTAsSUUxMTpiJiZ4PT09MTF9O2Z1bmN0aW9uIGJlZm9yZSgpe3ZhciBlPXthY3RpdmVFbGVtZW50OmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQsd2luZG93U2Nyb2xsVG9wOndpbmRvdy5zY3JvbGxUb3Asd2luZG93U2Nyb2xsTGVmdDp3aW5kb3cuc2Nyb2xsTGVmdCxib2R5U2Nyb2xsVG9wOmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLGJvZHlTY3JvbGxMZWZ0OmRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdH07dmFyIG49ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtuLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJwb3NpdGlvbjphYnNvbHV0ZTsgcG9zaXRpb246Zml4ZWQ7IHRvcDowOyBsZWZ0Oi0ycHg7IHdpZHRoOjFweDsgaGVpZ2h0OjFweDsgb3ZlcmZsb3c6aGlkZGVuO1wiKTtuLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLFwib2ZmXCIpO24uc2V0QXR0cmlidXRlKFwiYXJpYS1idXN5XCIsXCJ0cnVlXCIpO24uc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIixcInRydWVcIik7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuKTt2YXIgdD1uLmNvbnRlbnRXaW5kb3c7dmFyIHI9dC5kb2N1bWVudDtyLm9wZW4oKTtyLmNsb3NlKCk7dmFyIGE9ci5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO3IuYm9keS5hcHBlbmRDaGlsZChhKTtlLmlmcmFtZT1uO2Uud3JhcHBlcj1hO2Uud2luZG93PXQ7ZS5kb2N1bWVudD1yO3JldHVybiBlfWZ1bmN0aW9uIHRlc3QoZSxuKXtlLndyYXBwZXIuaW5uZXJIVE1MPVwiXCI7dmFyIHQ9dHlwZW9mIG4uZWxlbWVudD09PVwic3RyaW5nXCI/ZS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG4uZWxlbWVudCk6bi5lbGVtZW50KGUud3JhcHBlcixlLmRvY3VtZW50KTt2YXIgcj1uLm11dGF0ZSYmbi5tdXRhdGUodCxlLndyYXBwZXIsZS5kb2N1bWVudCk7aWYoIXImJnIhPT1mYWxzZSl7cj10fSF0LnBhcmVudE5vZGUmJmUud3JhcHBlci5hcHBlbmRDaGlsZCh0KTtyJiZyLmZvY3VzJiZyLmZvY3VzKCk7cmV0dXJuIG4udmFsaWRhdGU/bi52YWxpZGF0ZSh0LHIsZS5kb2N1bWVudCk6ZS5kb2N1bWVudC5hY3RpdmVFbGVtZW50PT09cn1mdW5jdGlvbiBhZnRlcihlKXtpZihlLmFjdGl2ZUVsZW1lbnQ9PT1kb2N1bWVudC5ib2R5KXtkb2N1bWVudC5hY3RpdmVFbGVtZW50JiZkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXImJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO2lmKHMuaXMuSUUxMCl7ZG9jdW1lbnQuYm9keS5mb2N1cygpfX1lbHNle2UuYWN0aXZlRWxlbWVudCYmZS5hY3RpdmVFbGVtZW50LmZvY3VzJiZlLmFjdGl2ZUVsZW1lbnQuZm9jdXMoKX1kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGUuaWZyYW1lKTt3aW5kb3cuc2Nyb2xsVG9wPWUud2luZG93U2Nyb2xsVG9wO3dpbmRvdy5zY3JvbGxMZWZ0PWUud2luZG93U2Nyb2xsTGVmdDtkb2N1bWVudC5ib2R5LnNjcm9sbFRvcD1lLmJvZHlTY3JvbGxUb3A7ZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0PWUuYm9keVNjcm9sbExlZnR9ZnVuY3Rpb24gZGV0ZWN0Rm9jdXMoZSl7dmFyIG49YmVmb3JlKCk7dmFyIHQ9e307T2JqZWN0LmtleXMoZSkubWFwKChmdW5jdGlvbihyKXt0W3JdPXRlc3QobixlW3JdKX0pKTthZnRlcihuKTtyZXR1cm4gdH12YXIgdz1cIjEuNC4xXCI7ZnVuY3Rpb24gcmVhZExvY2FsU3RvcmFnZShlKXt2YXIgbj12b2lkIDA7dHJ5e249d2luZG93LmxvY2FsU3RvcmFnZSYmd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpO249bj9KU09OLnBhcnNlKG4pOnt9fWNhdGNoKGUpe249e319cmV0dXJuIG59ZnVuY3Rpb24gd3JpdGVMb2NhbFN0b3JhZ2UoZSxuKXtpZighZG9jdW1lbnQuaGFzRm9jdXMoKSl7dHJ5e3dpbmRvdy5sb2NhbFN0b3JhZ2UmJndpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShlKX1jYXRjaChlKXt9cmV0dXJufXRyeXt3aW5kb3cubG9jYWxTdG9yYWdlJiZ3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZSxKU09OLnN0cmluZ2lmeShuKSl9Y2F0Y2goZSl7fX12YXIgXz10eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIiYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCI7dmFyIEU9XCJhbGx5LXN1cHBvcnRzLWNhY2hlXCI7dmFyIGo9cmVhZExvY2FsU3RvcmFnZShFKTtpZihqLnVzZXJBZ2VudCE9PV98fGoudmVyc2lvbiE9PXcpe2o9e319ai51c2VyQWdlbnQ9XztqLnZlcnNpb249dzt2YXIgTz17Z2V0OmZ1bmN0aW9uIGdldCgpe3JldHVybiBqfSxzZXQ6ZnVuY3Rpb24gc2V0KGUpe09iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKG4pe2pbbl09ZVtuXX0pKTtqLnRpbWU9KG5ldyBEYXRlKS50b0lTT1N0cmluZygpO3dyaXRlTG9jYWxTdG9yYWdlKEUsail9fTtmdW5jdGlvbiBjc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKCl7dmFyIGU9dm9pZCAwO3RyeXtkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaHRtbCA+Pj4gOmZpcnN0LWNoaWxkXCIpO2U9XCI+Pj5cIn1jYXRjaChuKXt0cnl7ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImh0bWwgL2RlZXAvIDpmaXJzdC1jaGlsZFwiKTtlPVwiL2RlZXAvXCJ9Y2F0Y2gobil7ZT1cIlwifX1yZXR1cm4gZX12YXIgaz1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1wiO3ZhciBTPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nKyc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nKyc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIHRhYmluZGV4PVwiLTFcIiBhbHQ9XCJcIiBzcmM9XCInK2srJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImFyZWFcIil9fTt2YXIgVD17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5pbm5lckhUTUw9JzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JysnPGFyZWEgaHJlZj1cIiN2b2lkXCIgdGFiaW5kZXg9XCItMVwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJytrKydcIj4nO3JldHVybiBmYWxzZX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe2lmKHMuaXMuR0VDS08pe3JldHVybiB0cnVlfXZhciByPWUucXVlcnlTZWxlY3RvcihcImFyZWFcIik7ci5mb2N1cygpO3JldHVybiB0LmFjdGl2ZUVsZW1lbnQ9PT1yfX07dmFyIEM9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIj4nKyc8YXJlYSBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nKyc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInK2srJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImFyZWFcIil9LHZhbGlkYXRlOmZ1bmN0aW9uIHZhbGlkYXRlKGUsbix0KXtpZihzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09bn19O3ZhciBEPXtuYW1lOlwiY2FuLWZvY3VzLWF1ZGlvLXdpdGhvdXQtY29udHJvbHNcIixlbGVtZW50OlwiYXVkaW9cIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe3RyeXtlLnNldEF0dHJpYnV0ZShcInNyY1wiLGspfWNhdGNoKGUpe319fTt2YXIgTT1cImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlwiO3ZhciBQPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiYnJva2VuLWltYWdlLW1hcC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JysnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJytNKydcIj4nO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJhcmVhXCIpfX07dmFyIHo9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIi0xXCIpO2Uuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcImRpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7XCIpO2UuaW5uZXJIVE1MPSc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInNwYW5cIil9fTt2YXIgQT17ZWxlbWVudDpcImZpZWxkc2V0XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsMCk7ZS5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLFwiZGlzYWJsZWRcIil9fTt2YXIgTj17ZWxlbWVudDpcImZpZWxkc2V0XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1cIjxsZWdlbmQ+bGVnZW5kPC9sZWdlbmQ+PHA+Y29udGVudDwvcD5cIn19O3ZhciBSPXtlbGVtZW50Olwic3BhblwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwiZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDtcIik7ZS5pbm5lckhUTUw9JzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+J319O3ZhciBJPXtlbGVtZW50OlwiZm9ybVwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLDApO2Uuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIixcImRpc2FibGVkXCIpfX07dmFyIEY9e2VsZW1lbnQ6XCJhXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmhyZWY9XCIjdm9pZFwiO2UuaW5uZXJIVE1MPSc8aW1nIGlzbWFwIHNyYz1cIicraysnXCIgYWx0PVwiXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpfX07dmFyIEw9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPSc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiICcrJ3NyYz1cIicraysnXCI+JztyZXR1cm4gZS5xdWVyeVNlbGVjdG9yKFwiaW1nXCIpfX07dmFyIEI9e2VsZW1lbnQ6ZnVuY3Rpb24gZWxlbWVudChlLG4pe3ZhciB0PW4uY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtlLmFwcGVuZENoaWxkKHQpO3ZhciByPXQuY29udGVudFdpbmRvdy5kb2N1bWVudDtyLm9wZW4oKTtyLmNsb3NlKCk7cmV0dXJuIHR9LG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCI7dmFyIG49ZS5jb250ZW50V2luZG93LmRvY3VtZW50O3ZhciB0PW4uY3JlYXRlRWxlbWVudChcImlucHV0XCIpO24uYm9keS5hcHBlbmRDaGlsZCh0KTtyZXR1cm4gdH0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSl7dmFyIG49ZS5jb250ZW50V2luZG93LmRvY3VtZW50O3ZhciB0PW4ucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO3JldHVybiBuLmFjdGl2ZUVsZW1lbnQ9PT10fX07dmFyIEg9IXMuaXMuV0VCS0lUO2Z1bmN0aW9uIGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0KCl7cmV0dXJuIEh9dmFyIHE9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcImludmFsaWQtdmFsdWVcIil9fTt2YXIgVT17ZWxlbWVudDpcImxhYmVsXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsXCItMVwiKX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe3ZhciByPWUub2Zmc2V0SGVpZ2h0O2UuZm9jdXMoKTtyZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09ZX19O3ZhciBXPVwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGJcIitcIkc1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQnBaRDBpYzNabklqNDhkR1Y0ZENCNFBTSXhNQ0lnZVQwaU1qQWlJR2xrUFNKXCIrXCJ6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT1cIjt2YXIgVj17ZWxlbWVudDpcIm9iamVjdFwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbWFnZS9zdmcreG1sXCIpO2Uuc2V0QXR0cmlidXRlKFwiZGF0YVwiLFcpO2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIixcIjIwMFwiKTtlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLFwiNTBcIik7ZS5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCJ9fTt2YXIgSz17bmFtZTpcImNhbi1mb2N1cy1vYmplY3Qtc3ZnXCIsZWxlbWVudDpcIm9iamVjdFwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbWFnZS9zdmcreG1sXCIpO2Uuc2V0QXR0cmlidXRlKFwiZGF0YVwiLFcpO2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIixcIjIwMFwiKTtlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLFwiNTBcIil9LHZhbGlkYXRlOmZ1bmN0aW9uIHZhbGlkYXRlKGUsbix0KXtpZihzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gdC5hY3RpdmVFbGVtZW50PT09ZX19O3ZhciBaPSFzLmlzLklFOTtmdW5jdGlvbiBmb2N1c09iamVjdFN3Zigpe3JldHVybiBafXZhciBHPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPG1hcCBuYW1lPVwiZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicrJzxpbWcgdXNlbWFwPVwiI2ZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIiBhbHQ9XCJcIiAnKydzcmM9XCInK2srJ1wiPic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImltZ1wiKX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe3ZhciByPWUucXVlcnlTZWxlY3RvcihcImFyZWFcIik7cmV0dXJuIHQuYWN0aXZlRWxlbWVudD09PXJ9fTt2YXIgWT17ZWxlbWVudDpcImZpZWxkc2V0XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD0nPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48aW5wdXQgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0YWJpbmRleD1cIjBcIj4nO3JldHVybiBmYWxzZX0sdmFsaWRhdGU6ZnVuY3Rpb24gdmFsaWRhdGUoZSxuLHQpe3ZhciByPWUucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCItMVwiXScpO3ZhciBhPWUucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCIwXCJdJyk7ZS5mb2N1cygpO2UucXVlcnlTZWxlY3RvcihcImxlZ2VuZFwiKS5mb2N1cygpO3JldHVybiB0LmFjdGl2ZUVsZW1lbnQ9PT1yJiZcImZvY3VzYWJsZVwifHx0LmFjdGl2ZUVsZW1lbnQ9PT1hJiZcInRhYmJhYmxlXCJ8fFwiXCJ9fTt2YXIgSj17ZWxlbWVudDpcImRpdlwiLG11dGF0ZTpmdW5jdGlvbiBtdXRhdGUoZSl7ZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLFwid2lkdGg6IDEwMHB4OyBoZWlnaHQ6IDUwcHg7IG92ZXJmbG93OiBhdXRvO1wiKTtlLmlubmVySFRNTD0nPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImRpdlwiKX19O3ZhciAkPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsXCJ3aWR0aDogMTAwcHg7IGhlaWdodDogNTBweDtcIik7ZS5pbm5lckhUTUw9JzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nfX07dmFyIFg9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwic3R5bGVcIixcIndpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bztcIik7ZS5pbm5lckhUTUw9JzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nfX07dmFyIFE9e2VsZW1lbnQ6XCJkZXRhaWxzXCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1cIjxzdW1tYXJ5PmZvbzwvc3VtbWFyeT48cD5jb250ZW50PC9wPlwiO3JldHVybiBlLmZpcnN0RWxlbWVudENoaWxkfX07ZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFwiZm9yZWlnbk9iamVjdFwiKTtlLndpZHRoLmJhc2VWYWwudmFsdWU9MzA7ZS5oZWlnaHQuYmFzZVZhbC52YWx1ZT0zMDtlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSk7ZS5sYXN0Q2hpbGQudHlwZT1cInRleHRcIjtyZXR1cm4gZX1mdW5jdGlvbiBmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrKGUpe3ZhciBuPWUub3duZXJTVkdFbGVtZW50fHxlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN2Z1wiO2lmKCFuKXtyZXR1cm4gZmFsc2V9dmFyIHQ9bWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKTtlLmFwcGVuZENoaWxkKHQpO3ZhciByPXQucXVlcnlTZWxlY3RvcihcImlucHV0XCIpO3IuZm9jdXMoKTtyLmRpc2FibGVkPXRydWU7ZS5yZW1vdmVDaGlsZCh0KTtyZXR1cm4gdHJ1ZX1mdW5jdGlvbiBnZW5lcmF0ZShlKXtyZXR1cm4nPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+JytlK1wiPC9zdmc+XCJ9ZnVuY3Rpb24gZm9jdXMoZSl7aWYoZS5mb2N1cyl7cmV0dXJufXRyeXtIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMuY2FsbChlKX1jYXRjaChuKXtmb2N1c1N2Z0ZvcmVpZ25PYmplY3RIYWNrKGUpfX1mdW5jdGlvbiB2YWxpZGF0ZShlLG4sdCl7Zm9jdXMobik7cmV0dXJuIHQuYWN0aXZlRWxlbWVudD09PW59dmFyIGVlPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1nZW5lcmF0ZSgnPHRleHQgZm9jdXNhYmxlPVwidHJ1ZVwiPmE8L3RleHQ+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInRleHRcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgbmU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKCc8dGV4dCB0YWJpbmRleD1cIjBcIj5hPC90ZXh0PicpO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpfSx2YWxpZGF0ZTp2YWxpZGF0ZX07dmFyIHRlPXtlbGVtZW50OlwiZGl2XCIsbXV0YXRlOmZ1bmN0aW9uIG11dGF0ZShlKXtlLmlubmVySFRNTD1nZW5lcmF0ZSgnPHRleHQgdGFiaW5kZXg9XCItMVwiPmE8L3RleHQ+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcInRleHRcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgcmU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKFsnPGcgaWQ9XCJhbGx5LXRlc3QtdGFyZ2V0XCI+PGEgeGxpbms6aHJlZj1cIiN2b2lkXCI+PHRleHQ+bGluazwvdGV4dD48L2E+PC9nPicsJzx1c2UgeGxpbms6aHJlZj1cIiNhbGx5LXRlc3QtdGFyZ2V0XCIgeD1cIjBcIiB5PVwiMFwiIHRhYmluZGV4PVwiLTFcIiAvPiddLmpvaW4oXCJcIikpO3JldHVybiBlLnF1ZXJ5U2VsZWN0b3IoXCJ1c2VcIil9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgYWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKCc8Zm9yZWlnbk9iamVjdCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz48L2ZvcmVpZ25PYmplY3Q+Jyk7cmV0dXJuIGUucXVlcnlTZWxlY3RvcihcImZvcmVpZ25PYmplY3RcIil8fGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmb3JlaWduT2JqZWN0XCIpWzBdfSx2YWxpZGF0ZTp2YWxpZGF0ZX07dmFyIG9lPUJvb2xlYW4ocy5pcy5HRUNLTyYmdHlwZW9mIFNWR0VsZW1lbnQhPT1cInVuZGVmaW5lZFwiJiZTVkdFbGVtZW50LnByb3RvdHlwZS5mb2N1cyk7ZnVuY3Rpb24gZm9jdXNTdmdJbklmcmFtZSgpe3JldHVybiBvZX12YXIgaWU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2UuaW5uZXJIVE1MPWdlbmVyYXRlKFwiXCIpO3JldHVybiBlLmZpcnN0Q2hpbGR9LHZhbGlkYXRlOnZhbGlkYXRlfTt2YXIgbGU9e2VsZW1lbnQ6XCJkaXZcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe2Uuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIixcIjN4XCIpfX07dmFyIHNlPXtlbGVtZW50OlwidGFibGVcIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUsbix0KXt2YXIgcj10LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtyLmlubmVySFRNTD1cIjx0cj48dGQ+Y2VsbDwvdGQ+PC90cj5cIjtlLmFwcGVuZENoaWxkKHIpfX07dmFyIHVlPXtlbGVtZW50OlwidmlkZW9cIixtdXRhdGU6ZnVuY3Rpb24gbXV0YXRlKGUpe3RyeXtlLnNldEF0dHJpYnV0ZShcInNyY1wiLGspfWNhdGNoKGUpe319fTt2YXIgY2U9cy5pcy5HRUNLT3x8cy5pcy5UUklERU5UfHxzLmlzLkVER0U7ZnVuY3Rpb24gdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbigpe3JldHVybiBjZX12YXIgZmU9e2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3I6Y3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcixmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdDpmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCxmb2N1c09iamVjdFN3Zjpmb2N1c09iamVjdFN3Zixmb2N1c1N2Z0luSWZyYW1lOmZvY3VzU3ZnSW5JZnJhbWUsdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjp0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9ufTt2YXIgZGU9e2ZvY3VzQXJlYUltZ1RhYmluZGV4OlMsZm9jdXNBcmVhVGFiaW5kZXg6VCxmb2N1c0FyZWFXaXRob3V0SHJlZjpDLGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM6RCxmb2N1c0Jyb2tlbkltYWdlTWFwOlAsZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDp6LGZvY3VzRmllbGRzZXREaXNhYmxlZDpBLGZvY3VzRmllbGRzZXQ6Tixmb2N1c0ZsZXhib3hDb250YWluZXI6Uixmb2N1c0Zvcm1EaXNhYmxlZDpJLGZvY3VzSW1nSXNtYXA6Rixmb2N1c0ltZ1VzZW1hcFRhYmluZGV4OkwsZm9jdXNJbkhpZGRlbklmcmFtZTpCLGZvY3VzSW52YWxpZFRhYmluZGV4OnEsZm9jdXNMYWJlbFRhYmluZGV4OlUsZm9jdXNPYmplY3RTdmc6Syxmb2N1c09iamVjdFN2Z0hpZGRlbjpWLGZvY3VzUmVkaXJlY3RJbWdVc2VtYXA6Ryxmb2N1c1JlZGlyZWN0TGVnZW5kOlksZm9jdXNTY3JvbGxCb2R5OkosZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3c6JCxmb2N1c1Njcm9sbENvbnRhaW5lcjpYLGZvY3VzU3VtbWFyeTpRLGZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlOmVlLGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGU6bmUsZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlOnRlLGZvY3VzU3ZnVXNlVGFiaW5kZXg6cmUsZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXg6YWUsZm9jdXNTdmc6aWUsZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczpsZSxmb2N1c1RhYmxlOnNlLGZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHM6dWV9O2Z1bmN0aW9uIGV4ZWN1dGVUZXN0cygpe3ZhciBlPWRldGVjdEZvY3VzKGRlKTtPYmplY3Qua2V5cyhmZSkuZm9yRWFjaCgoZnVuY3Rpb24obil7ZVtuXT1mZVtuXSgpfSkpO3JldHVybiBlfXZhciB2ZT1udWxsO2Z1bmN0aW9uIF9zdXBwb3J0cygpe2lmKHZlKXtyZXR1cm4gdmV9dmU9Ty5nZXQoKTtpZighdmUudGltZSl7Ty5zZXQoZXhlY3V0ZVRlc3RzKCkpO3ZlPU8uZ2V0KCl9cmV0dXJuIHZlfXZhciBwZT12b2lkIDA7dmFyIG1lPS9eXFxzKigtfFxcKyk/WzAtOV0rXFxzKiQvO3ZhciBiZT0vXlxccyooLXxcXCspP1swLTldKy4qJC87ZnVuY3Rpb24gaXNWYWxpZFRhYmluZGV4KGUpe2lmKCFwZSl7cGU9X3N1cHBvcnRzKCl9dmFyIG49cGUuZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycz9iZTptZTt2YXIgdD1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3ZhbGlkLXRhYmluZGV4XCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDplfSk7dmFyIHI9dC5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTt2YXIgYT10Lmhhc0F0dHJpYnV0ZShcInRhYkluZGV4XCIpO2lmKCFyJiYhYSl7cmV0dXJuIGZhbHNlfXZhciBvPXQub3duZXJTVkdFbGVtZW50fHx0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN2Z1wiO2lmKG8mJiFwZS5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKXtyZXR1cm4gZmFsc2V9aWYocGUuZm9jdXNJbnZhbGlkVGFiaW5kZXgpe3JldHVybiB0cnVlfXZhciBpPXQuZ2V0QXR0cmlidXRlKHI/XCJ0YWJpbmRleFwiOlwidGFiSW5kZXhcIik7aWYoaT09PVwiLTMyNzY4XCIpe3JldHVybiBmYWxzZX1yZXR1cm4gQm9vbGVhbihpJiZuLnRlc3QoaSkpfWZ1bmN0aW9uIHRhYmluZGV4VmFsdWUoZSl7aWYoIWlzVmFsaWRUYWJpbmRleChlKSl7cmV0dXJuIG51bGx9dmFyIG49ZS5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTt2YXIgdD1uP1widGFiaW5kZXhcIjpcInRhYkluZGV4XCI7dmFyIHI9cGFyc2VJbnQoZS5nZXRBdHRyaWJ1dGUodCksMTApO3JldHVybiBpc05hTihyKT8tMTpyfWZ1bmN0aW9uIGlzVXNlck1vZGlmeVdyaXRhYmxlKGUpe3ZhciBuPWUud2Via2l0VXNlck1vZGlmeXx8XCJcIjtyZXR1cm4gQm9vbGVhbihuJiZuLmluZGV4T2YoXCJ3cml0ZVwiKSE9PS0xKX1mdW5jdGlvbiBoYXNDc3NPdmVyZmxvd1Njcm9sbChlKXtyZXR1cm5bZS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3dcIiksZS5nZXRQcm9wZXJ0eVZhbHVlKFwib3ZlcmZsb3cteFwiKSxlLmdldFByb3BlcnR5VmFsdWUoXCJvdmVyZmxvdy15XCIpXS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gZT09PVwiYXV0b1wifHxlPT09XCJzY3JvbGxcIn0pKX1mdW5jdGlvbiBoYXNDc3NEaXNwbGF5RmxleChlKXtyZXR1cm4gZS5kaXNwbGF5LmluZGV4T2YoXCJmbGV4XCIpPi0xfWZ1bmN0aW9uIGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihlLG4sdCxyKXtpZihuIT09XCJkaXZcIiYmbiE9PVwic3BhblwiKXtyZXR1cm4gZmFsc2V9aWYodCYmdCE9PVwiZGl2XCImJnQhPT1cInNwYW5cIiYmIWhhc0Nzc092ZXJmbG93U2Nyb2xsKHIpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGUub2Zmc2V0SGVpZ2h0PGUuc2Nyb2xsSGVpZ2h0fHxlLm9mZnNldFdpZHRoPGUuc2Nyb2xsV2lkdGh9dmFyIGdlPXZvaWQgMDtmdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnRSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuZXhjZXB0LHI9dD09PXVuZGVmaW5lZD97ZmxleGJveDpmYWxzZSxzY3JvbGxhYmxlOmZhbHNlLHNoYWRvdzpmYWxzZX06dDtpZighZ2Upe2dlPV9zdXBwb3J0cygpfXZhciBhPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvZm9jdXMtcmVsZXZhbnRcIixyZXNvbHZlRG9jdW1lbnQ6dHJ1ZSxjb250ZXh0Om59KTtpZighci5zaGFkb3cmJmEuc2hhZG93Um9vdCl7cmV0dXJuIHRydWV9dmFyIG89YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKG89PT1cImlucHV0XCImJmEudHlwZT09PVwiaGlkZGVuXCIpe3JldHVybiBmYWxzZX1pZihvPT09XCJpbnB1dFwifHxvPT09XCJzZWxlY3RcInx8bz09PVwiYnV0dG9uXCJ8fG89PT1cInRleHRhcmVhXCIpe3JldHVybiB0cnVlfWlmKG89PT1cImxlZ2VuZFwiJiZnZS5mb2N1c1JlZGlyZWN0TGVnZW5kKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJsYWJlbFwiKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJhcmVhXCIpe3JldHVybiB0cnVlfWlmKG89PT1cImFcIiYmYS5oYXNBdHRyaWJ1dGUoXCJocmVmXCIpKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJvYmplY3RcIiYmYS5oYXNBdHRyaWJ1dGUoXCJ1c2VtYXBcIikpe3JldHVybiBmYWxzZX1pZihvPT09XCJvYmplY3RcIil7dmFyIGk9YS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO2lmKCFnZS5mb2N1c09iamVjdFN2ZyYmaT09PVwiaW1hZ2Uvc3ZnK3htbFwiKXtyZXR1cm4gZmFsc2V9ZWxzZSBpZighZ2UuZm9jdXNPYmplY3RTd2YmJmk9PT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCIpe3JldHVybiBmYWxzZX19aWYobz09PVwiaWZyYW1lXCJ8fG89PT1cIm9iamVjdFwiKXtyZXR1cm4gdHJ1ZX1pZihvPT09XCJlbWJlZFwifHxvPT09XCJrZXlnZW5cIil7cmV0dXJuIHRydWV9aWYoYS5oYXNBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikpe3JldHVybiB0cnVlfWlmKG89PT1cImF1ZGlvXCImJihnZS5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzfHxhLmhhc0F0dHJpYnV0ZShcImNvbnRyb2xzXCIpKSl7cmV0dXJuIHRydWV9aWYobz09PVwidmlkZW9cIiYmKGdlLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHN8fGEuaGFzQXR0cmlidXRlKFwiY29udHJvbHNcIikpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c1N1bW1hcnkmJm89PT1cInN1bW1hcnlcIil7cmV0dXJuIHRydWV9dmFyIGw9aXNWYWxpZFRhYmluZGV4KGEpO2lmKG89PT1cImltZ1wiJiZhLmhhc0F0dHJpYnV0ZShcInVzZW1hcFwiKSl7cmV0dXJuIGwmJmdlLmZvY3VzSW1nVXNlbWFwVGFiaW5kZXh8fGdlLmZvY3VzUmVkaXJlY3RJbWdVc2VtYXB9aWYoZ2UuZm9jdXNUYWJsZSYmKG89PT1cInRhYmxlXCJ8fG89PT1cInRkXCIpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c0ZpZWxkc2V0JiZvPT09XCJmaWVsZHNldFwiKXtyZXR1cm4gdHJ1ZX12YXIgcz1vPT09XCJzdmdcIjt2YXIgdT1hLm93bmVyU1ZHRWxlbWVudDt2YXIgYz1hLmdldEF0dHJpYnV0ZShcImZvY3VzYWJsZVwiKTt2YXIgZj10YWJpbmRleFZhbHVlKGEpO2lmKG89PT1cInVzZVwiJiZmIT09bnVsbCYmIWdlLmZvY3VzU3ZnVXNlVGFiaW5kZXgpe3JldHVybiBmYWxzZX1pZihvPT09XCJmb3JlaWdub2JqZWN0XCIpe3JldHVybiBmIT09bnVsbCYmZ2UuZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXh9aWYoZWxlbWVudE1hdGNoZXMoYSxcInN2ZyBhXCIpJiZhLmhhc0F0dHJpYnV0ZShcInhsaW5rOmhyZWZcIikpe3JldHVybiB0cnVlfWlmKChzfHx1KSYmYS5mb2N1cyYmIWdlLmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSYmZjwwKXtyZXR1cm4gZmFsc2V9aWYocyl7cmV0dXJuIGx8fGdlLmZvY3VzU3ZnfHxnZS5mb2N1c1N2Z0luSWZyYW1lfHxCb29sZWFuKGdlLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlJiZjJiZjPT09XCJ0cnVlXCIpfWlmKHUpe2lmKGdlLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUmJmwpe3JldHVybiB0cnVlfWlmKGdlLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKXtyZXR1cm4gYz09PVwidHJ1ZVwifX1pZihsKXtyZXR1cm4gdHJ1ZX12YXIgZD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpO2lmKGlzVXNlck1vZGlmeVdyaXRhYmxlKGQpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c0ltZ0lzbWFwJiZvPT09XCJpbWdcIiYmYS5oYXNBdHRyaWJ1dGUoXCJpc21hcFwiKSl7dmFyIHY9Z2V0UGFyZW50cyh7Y29udGV4dDphfSkuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PVwiYVwiJiZlLmhhc0F0dHJpYnV0ZShcImhyZWZcIil9KSk7aWYodil7cmV0dXJuIHRydWV9fWlmKCFyLnNjcm9sbGFibGUmJmdlLmZvY3VzU2Nyb2xsQ29udGFpbmVyKXtpZihnZS5mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdyl7aWYoaXNTY3JvbGxhYmxlQ29udGFpbmVyKGEsbykpe3JldHVybiB0cnVlfX1lbHNlIGlmKGhhc0Nzc092ZXJmbG93U2Nyb2xsKGQpKXtyZXR1cm4gdHJ1ZX19aWYoIXIuZmxleGJveCYmZ2UuZm9jdXNGbGV4Ym94Q29udGFpbmVyJiZoYXNDc3NEaXNwbGF5RmxleChkKSl7cmV0dXJuIHRydWV9dmFyIHA9YS5wYXJlbnRFbGVtZW50O2lmKCFyLnNjcm9sbGFibGUmJnApe3ZhciBtPXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKTt2YXIgYj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwLG51bGwpO2lmKGdlLmZvY3VzU2Nyb2xsQm9keSYmaXNTY3JvbGxhYmxlQ29udGFpbmVyKHAsbyxtLGIpKXtyZXR1cm4gdHJ1ZX1pZihnZS5mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KXtpZihoYXNDc3NEaXNwbGF5RmxleChiKSl7cmV0dXJuIHRydWV9fX1yZXR1cm4gZmFsc2V9aXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciBuPWZ1bmN0aW9uIGlzRm9jdXNSZWxldmFudChuKXtyZXR1cm4gaXNGb2N1c1JlbGV2YW50UnVsZXMoe2NvbnRleHQ6bixleGNlcHQ6ZX0pfTtuLnJ1bGVzPWlzRm9jdXNSZWxldmFudFJ1bGVzO3JldHVybiBufTt2YXIgaGU9aXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBmaW5kSW5kZXgoZSxuKXtpZihlLmZpbmRJbmRleCl7cmV0dXJuIGUuZmluZEluZGV4KG4pfXZhciB0PWUubGVuZ3RoO2lmKHQ9PT0wKXtyZXR1cm4tMX1mb3IodmFyIHI9MDtyPHQ7cisrKXtpZihuKGVbcl0scixlKSl7cmV0dXJuIHJ9fXJldHVybi0xfWZ1bmN0aW9uIGdldENvbnRlbnREb2N1bWVudChlKXt0cnl7cmV0dXJuIGUuY29udGVudERvY3VtZW50fHxlLmNvbnRlbnRXaW5kb3cmJmUuY29udGVudFdpbmRvdy5kb2N1bWVudHx8ZS5nZXRTVkdEb2N1bWVudCYmZS5nZXRTVkdEb2N1bWVudCgpfHxudWxsfWNhdGNoKGUpe3JldHVybiBudWxsfX1mdW5jdGlvbiBnZXRXaW5kb3coZSl7dmFyIG49Z2V0RG9jdW1lbnQoZSk7cmV0dXJuIG4uZGVmYXVsdFZpZXd8fHdpbmRvd312YXIgeWU9dm9pZCAwO2Z1bmN0aW9uIHNlbGVjdEluU2hhZG93cyhlKXtpZih0eXBlb2YgeWUhPT1cInN0cmluZ1wiKXt2YXIgbj1jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKCk7aWYobil7eWU9XCIsIGh0bWwgXCIrbitcIiBcIn19aWYoIXllKXtyZXR1cm4gZX1yZXR1cm4gZSt5ZStlLnJlcGxhY2UoL1xccyosXFxzKi9nLFwiLFwiKS5zcGxpdChcIixcIikuam9pbih5ZSl9dmFyIHhlPXZvaWQgMDtmdW5jdGlvbiBmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChlKXtpZigheGUpe3hlPXNlbGVjdEluU2hhZG93cyhcIm9iamVjdCwgaWZyYW1lXCIpfWlmKGUuX2ZyYW1lRWxlbWVudCE9PXVuZGVmaW5lZCl7cmV0dXJuIGUuX2ZyYW1lRWxlbWVudH1lLl9mcmFtZUVsZW1lbnQ9bnVsbDt2YXIgbj1lLnBhcmVudC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHhlKTtbXS5zb21lLmNhbGwobiwoZnVuY3Rpb24obil7dmFyIHQ9Z2V0Q29udGVudERvY3VtZW50KG4pO2lmKHQhPT1lLmRvY3VtZW50KXtyZXR1cm4gZmFsc2V9ZS5fZnJhbWVFbGVtZW50PW47cmV0dXJuIHRydWV9KSk7cmV0dXJuIGUuX2ZyYW1lRWxlbWVudH1mdW5jdGlvbiBnZXRGcmFtZUVsZW1lbnQoZSl7dmFyIG49Z2V0V2luZG93KGUpO2lmKCFuLnBhcmVudHx8bi5wYXJlbnQ9PT1uKXtyZXR1cm4gbnVsbH10cnl7cmV0dXJuIG4uZnJhbWVFbGVtZW50fHxmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChuKX1jYXRjaChlKXtyZXR1cm4gbnVsbH19dmFyIHdlPS9eKGFyZWEpJC87ZnVuY3Rpb24gY29tcHV0ZWRTdHlsZShlLG4pe3JldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpLmdldFByb3BlcnR5VmFsdWUobil9ZnVuY3Rpb24gbm90RGlzcGxheWVkKGUpe3JldHVybiBlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wdXRlZFN0eWxlKGUsXCJkaXNwbGF5XCIpPT09XCJub25lXCJ9KSl9ZnVuY3Rpb24gbm90VmlzaWJsZShlKXt2YXIgbj1maW5kSW5kZXgoZSwoZnVuY3Rpb24oZSl7dmFyIG49Y29tcHV0ZWRTdHlsZShlLFwidmlzaWJpbGl0eVwiKTtyZXR1cm4gbj09PVwiaGlkZGVuXCJ8fG49PT1cImNvbGxhcHNlXCJ9KSk7aWYobj09PS0xKXtyZXR1cm4gZmFsc2V9dmFyIHQ9ZmluZEluZGV4KGUsKGZ1bmN0aW9uKGUpe3JldHVybiBjb21wdXRlZFN0eWxlKGUsXCJ2aXNpYmlsaXR5XCIpPT09XCJ2aXNpYmxlXCJ9KSk7aWYodD09PS0xKXtyZXR1cm4gdHJ1ZX1pZihuPHQpe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX1mdW5jdGlvbiBjb2xsYXBzZWRQYXJlbnQoZSl7dmFyIG49MTtpZihlWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cInN1bW1hcnlcIil7bj0yfXJldHVybiBlLnNsaWNlKG4pLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1cImRldGFpbHNcIiYmZS5vcGVuPT09ZmFsc2V9KSl9ZnVuY3Rpb24gaXNWaXNpYmxlUnVsZXMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmNvbnRleHQsdD1lLmV4Y2VwdCxyPXQ9PT11bmRlZmluZWQ/e25vdFJlbmRlcmVkOmZhbHNlLGNzc0Rpc3BsYXk6ZmFsc2UsY3NzVmlzaWJpbGl0eTpmYWxzZSxkZXRhaWxzRWxlbWVudDpmYWxzZSxicm93c2luZ0NvbnRleHQ6ZmFsc2V9OnQ7dmFyIGE9Y29udGV4dFRvRWxlbWVudCh7bGFiZWw6XCJpcy92aXNpYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDpufSk7dmFyIG89YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKCFyLm5vdFJlbmRlcmVkJiZ3ZS50ZXN0KG8pKXtyZXR1cm4gdHJ1ZX12YXIgaT1nZXRQYXJlbnRzKHtjb250ZXh0OmF9KTt2YXIgbD1vPT09XCJhdWRpb1wiJiYhYS5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKTtpZighci5jc3NEaXNwbGF5JiZub3REaXNwbGF5ZWQobD9pLnNsaWNlKDEpOmkpKXtyZXR1cm4gZmFsc2V9aWYoIXIuY3NzVmlzaWJpbGl0eSYmbm90VmlzaWJsZShpKSl7cmV0dXJuIGZhbHNlfWlmKCFyLmRldGFpbHNFbGVtZW50JiZjb2xsYXBzZWRQYXJlbnQoaSkpe3JldHVybiBmYWxzZX1pZighci5icm93c2luZ0NvbnRleHQpe3ZhciBzPWdldEZyYW1lRWxlbWVudChhKTt2YXIgdT1pc1Zpc2libGVSdWxlcy5leGNlcHQocik7aWYocyYmIXUocykpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9aXNWaXNpYmxlUnVsZXMuZXhjZXB0PWZ1bmN0aW9uKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9O3ZhciBuPWZ1bmN0aW9uIGlzVmlzaWJsZShuKXtyZXR1cm4gaXNWaXNpYmxlUnVsZXMoe2NvbnRleHQ6bixleGNlcHQ6ZX0pfTtuLnJ1bGVzPWlzVmlzaWJsZVJ1bGVzO3JldHVybiBufTt2YXIgX2U9aXNWaXNpYmxlUnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBnZXRNYXBCeU5hbWUoZSxuKXt2YXIgdD1uLnF1ZXJ5U2VsZWN0b3IoJ21hcFtuYW1lPVwiJysoMCxvW1wiZGVmYXVsdFwiXSkoZSkrJ1wiXScpO3JldHVybiB0fHxudWxsfWZ1bmN0aW9uIGdldEltYWdlT2ZBcmVhKGUpe3ZhciBuPWUucGFyZW50RWxlbWVudDtpZighbi5uYW1lfHxuLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkhPT1cIm1hcFwiKXtyZXR1cm4gbnVsbH12YXIgdD1nZXREb2N1bWVudChlKTtyZXR1cm4gdC5xdWVyeVNlbGVjdG9yKCdpbWdbdXNlbWFwPVwiIycrKDAsb1tcImRlZmF1bHRcIl0pKG4ubmFtZSkrJ1wiXScpfHxudWxsfXZhciBFZT12b2lkIDA7ZnVuY3Rpb24gaXNWYWxpZEFyZWEoZSl7aWYoIUVlKXtFZT1fc3VwcG9ydHMoKX12YXIgbj1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3ZhbGlkLWFyZWFcIixjb250ZXh0OmV9KTt2YXIgdD1uLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYodCE9PVwiYXJlYVwiKXtyZXR1cm4gZmFsc2V9dmFyIHI9bi5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKTtpZighRWUuZm9jdXNBcmVhVGFiaW5kZXgmJnIpe3JldHVybiBmYWxzZX12YXIgYT1nZXRJbWFnZU9mQXJlYShuKTtpZighYXx8IV9lKGEpKXtyZXR1cm4gZmFsc2V9aWYoIUVlLmZvY3VzQnJva2VuSW1hZ2VNYXAmJighYS5jb21wbGV0ZXx8IWEubmF0dXJhbEhlaWdodHx8YS5vZmZzZXRXaWR0aDw9MHx8YS5vZmZzZXRIZWlnaHQ8PTApKXtyZXR1cm4gZmFsc2V9aWYoIUVlLmZvY3VzQXJlYVdpdGhvdXRIcmVmJiYhbi5ocmVmKXtyZXR1cm4gRWUuZm9jdXNBcmVhVGFiaW5kZXgmJnJ8fEVlLmZvY3VzQXJlYUltZ1RhYmluZGV4JiZhLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpfXZhciBvPWdldFBhcmVudHMoe2NvbnRleHQ6YX0pLnNsaWNlKDEpLnNvbWUoKGZ1bmN0aW9uKGUpe3ZhciBuPWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gbj09PVwiYnV0dG9uXCJ8fG49PT1cImFcIn0pKTtpZihvKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9dmFyIGplPXZvaWQgMDt2YXIgT2U9dm9pZCAwO3ZhciBrZT17aW5wdXQ6dHJ1ZSxzZWxlY3Q6dHJ1ZSx0ZXh0YXJlYTp0cnVlLGJ1dHRvbjp0cnVlLGZpZWxkc2V0OnRydWUsZm9ybTp0cnVlfTtmdW5jdGlvbiBpc05hdGl2ZURpc2FibGVkU3VwcG9ydGVkKGUpe2lmKCFqZSl7amU9X3N1cHBvcnRzKCk7aWYoamUuZm9jdXNGaWVsZHNldERpc2FibGVkKXtkZWxldGUga2UuZmllbGRzZXR9aWYoamUuZm9jdXNGb3JtRGlzYWJsZWQpe2RlbGV0ZSBrZS5mb3JtfU9lPW5ldyBSZWdFeHAoXCJeKFwiK09iamVjdC5rZXlzKGtlKS5qb2luKFwifFwiKStcIikkXCIpfXZhciBuPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZFwiLGNvbnRleHQ6ZX0pO3ZhciB0PW4ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gQm9vbGVhbihPZS50ZXN0KHQpKX12YXIgU2U9dm9pZCAwO2Z1bmN0aW9uIGlzRGlzYWJsZWRGaWVsZHNldChlKXt2YXIgbj1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIG49PT1cImZpZWxkc2V0XCImJmUuZGlzYWJsZWR9ZnVuY3Rpb24gaXNEaXNhYmxlZEZvcm0oZSl7dmFyIG49ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBuPT09XCJmb3JtXCImJmUuZGlzYWJsZWR9ZnVuY3Rpb24gaXNEaXNhYmxlZChlKXtpZighU2Upe1NlPV9zdXBwb3J0cygpfXZhciBuPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvZGlzYWJsZWRcIixjb250ZXh0OmV9KTtpZihuLmhhc0F0dHJpYnV0ZShcImRhdGEtYWxseS1kaXNhYmxlZFwiKSl7cmV0dXJuIHRydWV9aWYoIWlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQobikpe3JldHVybiBmYWxzZX1pZihuLmRpc2FibGVkKXtyZXR1cm4gdHJ1ZX12YXIgdD1nZXRQYXJlbnRzKHtjb250ZXh0Om59KTtpZih0LnNvbWUoaXNEaXNhYmxlZEZpZWxkc2V0KSl7cmV0dXJuIHRydWV9aWYoIVNlLmZvY3VzRm9ybURpc2FibGVkJiZ0LnNvbWUoaXNEaXNhYmxlZEZvcm0pKXtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuZXhjZXB0LHI9dD09PXVuZGVmaW5lZD97b25seUZvY3VzYWJsZUJyb3dzaW5nQ29udGV4dDpmYWxzZSx2aXNpYmxlOmZhbHNlfTp0O3ZhciBhPWNvbnRleHRUb0VsZW1lbnQoe2xhYmVsOlwiaXMvb25seS10YWJiYWJsZVwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGNvbnRleHQ6bn0pO2lmKCFyLnZpc2libGUmJiFfZShhKSl7cmV0dXJuIGZhbHNlfWlmKCFyLm9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQmJihzLmlzLkdFQ0tPfHxzLmlzLlRSSURFTlR8fHMuaXMuRURHRSkpe3ZhciBvPWdldEZyYW1lRWxlbWVudChhKTtpZihvKXtpZih0YWJpbmRleFZhbHVlKG8pPDApe3JldHVybiBmYWxzZX19fXZhciBpPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTt2YXIgbD10YWJpbmRleFZhbHVlKGEpO2lmKGk9PT1cImxhYmVsXCImJnMuaXMuR0VDS08pe3JldHVybiBsIT09bnVsbCYmbD49MH1pZihzLmlzLkdFQ0tPJiZhLm93bmVyU1ZHRWxlbWVudCYmIWEuZm9jdXMpe2lmKGk9PT1cImFcIiYmYS5oYXNBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpKXtpZihzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX19fXJldHVybiBmYWxzZX1pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdD1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgbj1mdW5jdGlvbiBpc09ubHlUYWJiYWJsZShuKXtyZXR1cm4gaXNPbmx5VGFiYmFibGVSdWxlcyh7Y29udGV4dDpuLGV4Y2VwdDplfSl9O24ucnVsZXM9aXNPbmx5VGFiYmFibGVSdWxlcztyZXR1cm4gbn07dmFyIFRlPWlzT25seVRhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTt2YXIgQ2U9dm9pZCAwO2Z1bmN0aW9uIGlzT25seUZvY3VzUmVsZXZhbnQoZSl7dmFyIG49ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKG49PT1cImVtYmVkXCJ8fG49PT1cImtleWdlblwiKXtyZXR1cm4gdHJ1ZX12YXIgdD10YWJpbmRleFZhbHVlKGUpO2lmKGUuc2hhZG93Um9vdCYmdD09PW51bGwpe3JldHVybiB0cnVlfWlmKG49PT1cImxhYmVsXCIpe3JldHVybiFDZS5mb2N1c0xhYmVsVGFiaW5kZXh8fHQ9PT1udWxsfWlmKG49PT1cImxlZ2VuZFwiKXtyZXR1cm4gdD09PW51bGx9aWYoQ2UuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUmJihlLm93bmVyU1ZHRWxlbWVudHx8bj09PVwic3ZnXCIpKXt2YXIgcj1lLmdldEF0dHJpYnV0ZShcImZvY3VzYWJsZVwiKTtyZXR1cm4gciYmcj09PVwiZmFsc2VcIn1pZihuPT09XCJpbWdcIiYmZS5oYXNBdHRyaWJ1dGUoXCJ1c2VtYXBcIikpe3JldHVybiB0PT09bnVsbHx8IUNlLmZvY3VzSW1nVXNlbWFwVGFiaW5kZXh9aWYobj09PVwiYXJlYVwiKXtyZXR1cm4haXNWYWxpZEFyZWEoZSl9cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGlzRm9jdXNhYmxlUnVsZXMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmNvbnRleHQsdD1lLmV4Y2VwdCxyPXQ9PT11bmRlZmluZWQ/e2Rpc2FibGVkOmZhbHNlLHZpc2libGU6ZmFsc2Usb25seVRhYmJhYmxlOmZhbHNlfTp0O2lmKCFDZSl7Q2U9X3N1cHBvcnRzKCl9dmFyIGE9VGUucnVsZXMuZXhjZXB0KHtvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OnRydWUsdmlzaWJsZTpyLnZpc2libGV9KTt2YXIgbz1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL2ZvY3VzYWJsZVwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGNvbnRleHQ6bn0pO3ZhciBpPWhlLnJ1bGVzKHtjb250ZXh0Om8sZXhjZXB0OnJ9KTtpZighaXx8aXNPbmx5Rm9jdXNSZWxldmFudChvKSl7cmV0dXJuIGZhbHNlfWlmKCFyLmRpc2FibGVkJiZpc0Rpc2FibGVkKG8pKXtyZXR1cm4gZmFsc2V9aWYoIXIub25seVRhYmJhYmxlJiZhKG8pKXtyZXR1cm4gZmFsc2V9aWYoIXIudmlzaWJsZSl7dmFyIGw9e2NvbnRleHQ6byxleGNlcHQ6e319O2lmKENlLmZvY3VzSW5IaWRkZW5JZnJhbWUpe2wuZXhjZXB0LmJyb3dzaW5nQ29udGV4dD10cnVlfWlmKENlLmZvY3VzT2JqZWN0U3ZnSGlkZGVuKXt2YXIgcz1vLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYocz09PVwib2JqZWN0XCIpe2wuZXhjZXB0LmNzc1Zpc2liaWxpdHk9dHJ1ZX19aWYoIV9lLnJ1bGVzKGwpKXtyZXR1cm4gZmFsc2V9fXZhciB1PWdldEZyYW1lRWxlbWVudChvKTtpZih1KXt2YXIgYz11Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoYz09PVwib2JqZWN0XCImJiFDZS5mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCl7aWYoIXUub2Zmc2V0V2lkdGh8fCF1Lm9mZnNldEhlaWdodCl7cmV0dXJuIGZhbHNlfX19dmFyIGY9by5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cInN2Z1wiJiZDZS5mb2N1c1N2Z0luSWZyYW1lJiYhdSYmby5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKT09PW51bGwpe3JldHVybiBmYWxzZX1yZXR1cm4gdHJ1ZX1pc0ZvY3VzYWJsZVJ1bGVzLmV4Y2VwdD1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgbj1mdW5jdGlvbiBpc0ZvY3VzYWJsZShuKXtyZXR1cm4gaXNGb2N1c2FibGVSdWxlcyh7Y29udGV4dDpuLGV4Y2VwdDplfSl9O24ucnVsZXM9aXNGb2N1c2FibGVSdWxlcztyZXR1cm4gbn07dmFyIERlPWlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZSl7dmFyIG49ZnVuY3Rpb24gZmlsdGVyKG4pe2lmKG4uc2hhZG93Um9vdCl7cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVH1pZihlKG4pKXtyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUfXJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQfTtuLmFjY2VwdE5vZGU9bjtyZXR1cm4gbn12YXIgTWU9Y3JlYXRlRmlsdGVyKGhlKTtmdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVN0cmljdCgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuaW5jbHVkZUNvbnRleHQscj1lLmluY2x1ZGVPbmx5VGFiYmFibGUsYT1lLnN0cmF0ZWd5O2lmKCFuKXtuPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudH12YXIgbz1EZS5ydWxlcy5leGNlcHQoe29ubHlUYWJiYWJsZTpyfSk7dmFyIGk9Z2V0RG9jdW1lbnQobik7dmFyIGw9aS5jcmVhdGVUcmVlV2Fsa2VyKG4sTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsYT09PVwiYWxsXCI/TWU6Y3JlYXRlRmlsdGVyKG8pLGZhbHNlKTt2YXIgcz1bXTt3aGlsZShsLm5leHROb2RlKCkpe2lmKGwuY3VycmVudE5vZGUuc2hhZG93Um9vdCl7aWYobyhsLmN1cnJlbnROb2RlKSl7cy5wdXNoKGwuY3VycmVudE5vZGUpfXM9cy5jb25jYXQocXVlcnlGb2N1c2FibGVTdHJpY3Qoe2NvbnRleHQ6bC5jdXJyZW50Tm9kZS5zaGFkb3dSb290LGluY2x1ZGVPbmx5VGFiYmFibGU6cixzdHJhdGVneTphfSkpfWVsc2V7cy5wdXNoKGwuY3VycmVudE5vZGUpfX1pZih0KXtpZihhPT09XCJhbGxcIil7aWYoaGUobikpe3MudW5zaGlmdChuKX19ZWxzZSBpZihvKG4pKXtzLnVuc2hpZnQobil9fXJldHVybiBzfXZhciBQZT12b2lkIDA7dmFyIHplPXZvaWQgMDtmdW5jdGlvbiBzZWxlY3RvciQyKCl7aWYoIVBlKXtQZT1fc3VwcG9ydHMoKX1pZih0eXBlb2YgemU9PT1cInN0cmluZ1wiKXtyZXR1cm4gemV9emU9XCJcIisoUGUuZm9jdXNUYWJsZT9cInRhYmxlLCB0ZCxcIjpcIlwiKSsoUGUuZm9jdXNGaWVsZHNldD9cImZpZWxkc2V0LFwiOlwiXCIpK1wic3ZnIGEsXCIrXCJhW2hyZWZdLFwiK1wiYXJlYVtocmVmXSxcIitcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBidXR0b24sXCIrXCJpZnJhbWUsIG9iamVjdCwgZW1iZWQsXCIrXCJrZXlnZW4sXCIrKFBlLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM/XCJhdWRpbyxcIjpcImF1ZGlvW2NvbnRyb2xzXSxcIikrKFBlLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHM/XCJ2aWRlbyxcIjpcInZpZGVvW2NvbnRyb2xzXSxcIikrKFBlLmZvY3VzU3VtbWFyeT9cInN1bW1hcnksXCI6XCJcIikrXCJbdGFiaW5kZXhdLFwiK1wiW2NvbnRlbnRlZGl0YWJsZV1cIjt6ZT1zZWxlY3RJblNoYWRvd3MoemUpO3JldHVybiB6ZX1mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVF1aWNrKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LG49ZS5jb250ZXh0LHQ9ZS5pbmNsdWRlQ29udGV4dCxyPWUuaW5jbHVkZU9ubHlUYWJiYWJsZTt2YXIgYT1zZWxlY3RvciQyKCk7dmFyIG89bi5xdWVyeVNlbGVjdG9yQWxsKGEpO3ZhciBpPURlLnJ1bGVzLmV4Y2VwdCh7b25seVRhYmJhYmxlOnJ9KTt2YXIgbD1bXS5maWx0ZXIuY2FsbChvLGkpO2lmKHQmJmkobikpe2wudW5zaGlmdChuKX1yZXR1cm4gbH1mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZSgpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUuY29udGV4dCx0PWUuaW5jbHVkZUNvbnRleHQscj1lLmluY2x1ZGVPbmx5VGFiYmFibGUsYT1lLnN0cmF0ZWd5LG89YT09PXVuZGVmaW5lZD9cInF1aWNrXCI6YTt2YXIgaT1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcInF1ZXJ5L2ZvY3VzYWJsZVwiLHJlc29sdmVEb2N1bWVudDp0cnVlLGRlZmF1bHRUb0RvY3VtZW50OnRydWUsY29udGV4dDpufSk7dmFyIGw9e2NvbnRleHQ6aSxpbmNsdWRlQ29udGV4dDp0LGluY2x1ZGVPbmx5VGFiYmFibGU6cixzdHJhdGVneTpvfTtpZihvPT09XCJxdWlja1wiKXtyZXR1cm4gcXVlcnlGb2N1c2FibGVRdWljayhsKX1lbHNlIGlmKG89PT1cInN0cmljdFwifHxvPT09XCJhbGxcIil7cmV0dXJuIHF1ZXJ5Rm9jdXNhYmxlU3RyaWN0KGwpfXRocm93IG5ldyBUeXBlRXJyb3IoJ3F1ZXJ5L2ZvY3VzYWJsZSByZXF1aXJlcyBvcHRpb24uc3RyYXRlZ3kgdG8gYmUgb25lIG9mIFtcInF1aWNrXCIsIFwic3RyaWN0XCIsIFwiYWxsXCJdJyl9dmFyIEFlPXZvaWQgMDt2YXIgTmU9L14oZmllbGRzZXR8dGFibGV8dGR8Ym9keSkkLztmdW5jdGlvbiBpc1RhYmJhYmxlUnVsZXMoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmNvbnRleHQsdD1lLmV4Y2VwdCxyPXQ9PT11bmRlZmluZWQ/e2ZsZXhib3g6ZmFsc2Usc2Nyb2xsYWJsZTpmYWxzZSxzaGFkb3c6ZmFsc2UsdmlzaWJsZTpmYWxzZSxvbmx5VGFiYmFibGU6ZmFsc2V9OnQ7aWYoIUFlKXtBZT1fc3VwcG9ydHMoKX12YXIgYT1jb250ZXh0VG9FbGVtZW50KHtsYWJlbDpcImlzL3RhYmJhYmxlXCIscmVzb2x2ZURvY3VtZW50OnRydWUsY29udGV4dDpufSk7aWYocy5pcy5CTElOSyYmcy5pcy5BTkRST0lEJiZzLm1ham9yVmVyc2lvbj40Mil7cmV0dXJuIGZhbHNlfXZhciBvPWdldEZyYW1lRWxlbWVudChhKTtpZihvKXtpZihzLmlzLldFQktJVCYmcy5pcy5JT1Mpe3JldHVybiBmYWxzZX1pZih0YWJpbmRleFZhbHVlKG8pPDApe3JldHVybiBmYWxzZX1pZighci52aXNpYmxlJiYocy5pcy5CTElOS3x8cy5pcy5XRUJLSVQpJiYhX2Uobykpe3JldHVybiBmYWxzZX12YXIgaT1vLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoaT09PVwib2JqZWN0XCIpe3ZhciBsPXMubmFtZT09PVwiQ2hyb21lXCImJnMubWFqb3JWZXJzaW9uPj01NHx8cy5uYW1lPT09XCJPcGVyYVwiJiZzLm1ham9yVmVyc2lvbj49NDE7aWYocy5pcy5XRUJLSVR8fHMuaXMuQkxJTksmJiFsKXtyZXR1cm4gZmFsc2V9fX12YXIgdT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7dmFyIGM9dGFiaW5kZXhWYWx1ZShhKTt2YXIgZj1jPT09bnVsbD9udWxsOmM+PTA7aWYocy5pcy5FREdFJiZzLm1ham9yVmVyc2lvbj49MTQmJm8mJmEub3duZXJTVkdFbGVtZW50JiZjPDApe3JldHVybiB0cnVlfXZhciBkPWYhPT1mYWxzZTt2YXIgdj1jIT09bnVsbCYmYz49MDtpZihhLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKSl7cmV0dXJuIGR9aWYoTmUudGVzdCh1KSYmZiE9PXRydWUpe3JldHVybiBmYWxzZX1pZihzLmlzLldFQktJVCYmcy5pcy5JT1Mpe3ZhciBwPXU9PT1cImlucHV0XCImJmEudHlwZT09PVwidGV4dFwifHxhLnR5cGU9PT1cInBhc3N3b3JkXCJ8fHU9PT1cInNlbGVjdFwifHx1PT09XCJ0ZXh0YXJlYVwifHxhLmhhc0F0dHJpYnV0ZShcImNvbnRlbnRlZGl0YWJsZVwiKTtpZighcCl7dmFyIG09d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSxudWxsKTtwPWlzVXNlck1vZGlmeVdyaXRhYmxlKG0pfWlmKCFwKXtyZXR1cm4gZmFsc2V9fWlmKHU9PT1cInVzZVwiJiZjIT09bnVsbCl7aWYocy5pcy5CTElOS3x8cy5pcy5XRUJLSVQmJnMubWFqb3JWZXJzaW9uPT09OSl7cmV0dXJuIHRydWV9fWlmKGVsZW1lbnRNYXRjaGVzKGEsXCJzdmcgYVwiKSYmYS5oYXNBdHRyaWJ1dGUoXCJ4bGluazpocmVmXCIpKXtpZihkKXtyZXR1cm4gdHJ1ZX1pZihhLmZvY3VzJiYhQWUuZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlKXtyZXR1cm4gdHJ1ZX19aWYodT09PVwic3ZnXCImJkFlLmZvY3VzU3ZnSW5JZnJhbWUmJmQpe3JldHVybiB0cnVlfWlmKHMuaXMuVFJJREVOVHx8cy5pcy5FREdFKXtpZih1PT09XCJzdmdcIil7aWYoQWUuZm9jdXNTdmcpe3JldHVybiB0cnVlfXJldHVybiBhLmhhc0F0dHJpYnV0ZShcImZvY3VzYWJsZVwiKXx8dn1pZihhLm93bmVyU1ZHRWxlbWVudCl7aWYoQWUuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSYmdil7cmV0dXJuIHRydWV9cmV0dXJuIGEuaGFzQXR0cmlidXRlKFwiZm9jdXNhYmxlXCIpfX1pZihhLnRhYkluZGV4PT09dW5kZWZpbmVkKXtyZXR1cm4gQm9vbGVhbihyLm9ubHlUYWJiYWJsZSl9aWYodT09PVwiYXVkaW9cIil7aWYoIWEuaGFzQXR0cmlidXRlKFwiY29udHJvbHNcIikpe3JldHVybiBmYWxzZX1lbHNlIGlmKHMuaXMuQkxJTkspe3JldHVybiB0cnVlfX1pZih1PT09XCJ2aWRlb1wiKXtpZighYS5oYXNBdHRyaWJ1dGUoXCJjb250cm9sc1wiKSl7aWYocy5pcy5UUklERU5UfHxzLmlzLkVER0Upe3JldHVybiBmYWxzZX19ZWxzZSBpZihzLmlzLkJMSU5LfHxzLmlzLkdFQ0tPKXtyZXR1cm4gdHJ1ZX19aWYodT09PVwib2JqZWN0XCIpe2lmKHMuaXMuQkxJTkt8fHMuaXMuV0VCS0lUKXtyZXR1cm4gZmFsc2V9fWlmKHU9PT1cImlmcmFtZVwiKXtyZXR1cm4gZmFsc2V9aWYoIXIuc2Nyb2xsYWJsZSYmcy5pcy5HRUNLTyl7dmFyIGI9d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSxudWxsKTtpZihoYXNDc3NPdmVyZmxvd1Njcm9sbChiKSl7cmV0dXJuIGR9fWlmKHMuaXMuVFJJREVOVHx8cy5pcy5FREdFKXtpZih1PT09XCJhcmVhXCIpe3ZhciBnPWdldEltYWdlT2ZBcmVhKGEpO2lmKGcmJnRhYmluZGV4VmFsdWUoZyk8MCl7cmV0dXJuIGZhbHNlfX12YXIgaD13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhLG51bGwpO2lmKGlzVXNlck1vZGlmeVdyaXRhYmxlKGgpKXtyZXR1cm4gYS50YWJJbmRleD49MH1pZighci5mbGV4Ym94JiZoYXNDc3NEaXNwbGF5RmxleChoKSl7aWYoYyE9PW51bGwpe3JldHVybiB2fXJldHVybiBSZShhKSYmSWUoYSl9aWYoaXNTY3JvbGxhYmxlQ29udGFpbmVyKGEsdSkpe3JldHVybiBmYWxzZX12YXIgeT1hLnBhcmVudEVsZW1lbnQ7aWYoeSl7dmFyIHg9eS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3ZhciB3PXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHksbnVsbCk7aWYoaXNTY3JvbGxhYmxlQ29udGFpbmVyKHksdSx4LHcpKXtyZXR1cm4gZmFsc2V9aWYoaGFzQ3NzRGlzcGxheUZsZXgodykpe3JldHVybiB2fX19cmV0dXJuIGEudGFiSW5kZXg+PTB9aXNUYWJiYWJsZVJ1bGVzLmV4Y2VwdD1mdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fTt2YXIgbj1mdW5jdGlvbiBpc1RhYmJhYmxlKG4pe3JldHVybiBpc1RhYmJhYmxlUnVsZXMoe2NvbnRleHQ6bixleGNlcHQ6ZX0pfTtuLnJ1bGVzPWlzVGFiYmFibGVSdWxlcztyZXR1cm4gbn07dmFyIFJlPWhlLnJ1bGVzLmV4Y2VwdCh7ZmxleGJveDp0cnVlfSk7dmFyIEllPWlzVGFiYmFibGVSdWxlcy5leGNlcHQoe2ZsZXhib3g6dHJ1ZX0pO3ZhciBGZT1pc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtmdW5jdGlvbiBxdWVyeVRhYmJhYmxlKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LG49ZS5jb250ZXh0LHQ9ZS5pbmNsdWRlQ29udGV4dCxyPWUuaW5jbHVkZU9ubHlUYWJiYWJsZSxhPWUuc3RyYXRlZ3k7dmFyIG89RmUucnVsZXMuZXhjZXB0KHtvbmx5VGFiYmFibGU6cn0pO3JldHVybiBxdWVyeUZvY3VzYWJsZSh7Y29udGV4dDpuLGluY2x1ZGVDb250ZXh0OnQsaW5jbHVkZU9ubHlUYWJiYWJsZTpyLHN0cmF0ZWd5OmF9KS5maWx0ZXIobyl9ZnVuY3Rpb24gY29tcGFyZURvbVBvc2l0aW9uKGUsbil7cmV0dXJuIGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obikmTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc/LTE6MX1mdW5jdGlvbiBzb3J0RG9tT3JkZXIoZSl7cmV0dXJuIGUuc29ydChjb21wYXJlRG9tUG9zaXRpb24pfWZ1bmN0aW9uIGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGUsbil7cmV0dXJuIGZpbmRJbmRleChlLChmdW5jdGlvbihlKXtyZXR1cm4gbi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlKSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lOR30pKX1mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhlLG4sdCl7dmFyIHI9W107bi5mb3JFYWNoKChmdW5jdGlvbihuKXt2YXIgYT10cnVlO3ZhciBvPWUuaW5kZXhPZihuKTtpZihvPT09LTEpe289Z2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQoZSxuKTthPWZhbHNlfWlmKG89PT0tMSl7bz1lLmxlbmd0aH12YXIgaT1ub2RlQXJyYXkodD90KG4pOm4pO2lmKCFpLmxlbmd0aCl7cmV0dXJufXIucHVzaCh7b2Zmc2V0Om8scmVwbGFjZTphLGVsZW1lbnRzOml9KX0pKTtyZXR1cm4gcn1mdW5jdGlvbiBpbnNlcnRFbGVtZW50c0F0T2Zmc2V0cyhlLG4pe3ZhciB0PTA7bi5zb3J0KChmdW5jdGlvbihlLG4pe3JldHVybiBlLm9mZnNldC1uLm9mZnNldH0pKTtuLmZvckVhY2goKGZ1bmN0aW9uKG4pe3ZhciByPW4ucmVwbGFjZT8xOjA7dmFyIGE9W24ub2Zmc2V0K3Qscl0uY29uY2F0KG4uZWxlbWVudHMpO2Uuc3BsaWNlLmFwcGx5KGUsYSk7dCs9bi5lbGVtZW50cy5sZW5ndGgtcn0pKX1mdW5jdGlvbiBtZXJnZUluRG9tT3JkZXIoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e30sbj1lLmxpc3QsdD1lLmVsZW1lbnRzLHI9ZS5yZXNvbHZlRWxlbWVudDt2YXIgYT1uLnNsaWNlKDApO3ZhciBvPW5vZGVBcnJheSh0KS5zbGljZSgwKTtzb3J0RG9tT3JkZXIobyk7dmFyIGk9ZmluZEluc2VydGlvbk9mZnNldHMoYSxvLHIpO2luc2VydEVsZW1lbnRzQXRPZmZzZXRzKGEsaSk7cmV0dXJuIGF9dmFyIExlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhlLG4pe2Zvcih2YXIgdD0wO3Q8bi5sZW5ndGg7dCsrKXt2YXIgcj1uW3RdO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fGZhbHNlO3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gcilyLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXJldHVybiBmdW5jdGlvbihlLG4sdCl7aWYobilkZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLG4pO2lmKHQpZGVmaW5lUHJvcGVydGllcyhlLHQpO3JldHVybiBlfX0oKTtmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soZSxuKXtpZighKGUgaW5zdGFuY2VvZiBuKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19dmFyIEJlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gTWFwcyhlKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxNYXBzKTt0aGlzLl9kb2N1bWVudD1nZXREb2N1bWVudChlKTt0aGlzLm1hcHM9e319TGUoTWFwcyxbe2tleTpcImdldEFyZWFzRm9yXCIsdmFsdWU6ZnVuY3Rpb24gZ2V0QXJlYXNGb3IoZSl7aWYoIXRoaXMubWFwc1tlXSl7dGhpcy5hZGRNYXBCeU5hbWUoZSl9cmV0dXJuIHRoaXMubWFwc1tlXX19LHtrZXk6XCJhZGRNYXBCeU5hbWVcIix2YWx1ZTpmdW5jdGlvbiBhZGRNYXBCeU5hbWUoZSl7dmFyIG49Z2V0TWFwQnlOYW1lKGUsdGhpcy5fZG9jdW1lbnQpO2lmKCFuKXtyZXR1cm59dGhpcy5tYXBzW24ubmFtZV09cXVlcnlUYWJiYWJsZSh7Y29udGV4dDpufSl9fSx7a2V5OlwiZXh0cmFjdEFyZWFzRnJvbUxpc3RcIix2YWx1ZTpmdW5jdGlvbiBleHRyYWN0QXJlYXNGcm9tTGlzdChlKXtyZXR1cm4gZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciBuPWUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihuIT09XCJhcmVhXCIpe3JldHVybiB0cnVlfXZhciB0PWUucGFyZW50Tm9kZTtpZighdGhpcy5tYXBzW3QubmFtZV0pe3RoaXMubWFwc1t0Lm5hbWVdPVtdfXRoaXMubWFwc1t0Lm5hbWVdLnB1c2goZSk7cmV0dXJuIGZhbHNlfSksdGhpcyl9fV0pO3JldHVybiBNYXBzfSgpO2Z1bmN0aW9uIHNvcnRBcmVhKGUsbil7dmFyIHQ9bi5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nW3VzZW1hcF1cIik7dmFyIHI9bmV3IEJlKG4pO3ZhciBhPXIuZXh0cmFjdEFyZWFzRnJvbUxpc3QoZSk7aWYoIXQubGVuZ3RoKXtyZXR1cm4gYX1yZXR1cm4gbWVyZ2VJbkRvbU9yZGVyKHtsaXN0OmEsZWxlbWVudHM6dCxyZXNvbHZlRWxlbWVudDpmdW5jdGlvbiByZXNvbHZlRWxlbWVudChlKXt2YXIgbj1lLmdldEF0dHJpYnV0ZShcInVzZW1hcFwiKS5zbGljZSgxKTtyZXR1cm4gci5nZXRBcmVhc0ZvcihuKX19KX12YXIgSGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGUsbil7Zm9yKHZhciB0PTA7dDxuLmxlbmd0aDt0Kyspe3ZhciByPW5bdF07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ZmFsc2U7ci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiByKXIud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19cmV0dXJuIGZ1bmN0aW9uKGUsbix0KXtpZihuKWRlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsbik7aWYodClkZWZpbmVQcm9wZXJ0aWVzKGUsdCk7cmV0dXJuIGV9fSgpO2Z1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQxKGUsbil7aWYoIShlIGluc3RhbmNlb2Ygbikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9fXZhciBxZT1mdW5jdGlvbigpe2Z1bmN0aW9uIFNoYWRvd3MoZSxuKXtfY2xhc3NDYWxsQ2hlY2skMSh0aGlzLFNoYWRvd3MpO3RoaXMuY29udGV4dD1lO3RoaXMuc29ydEVsZW1lbnRzPW47dGhpcy5ob3N0Q291bnRlcj0xO3RoaXMuaW5Ib3N0PXt9O3RoaXMuaW5Eb2N1bWVudD1bXTt0aGlzLmhvc3RzPXt9O3RoaXMuZWxlbWVudHM9e319SGUoU2hhZG93cyxbe2tleTpcIl9yZWdpc3Rlckhvc3RcIix2YWx1ZTpmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0KGUpe2lmKGUuX3NvcnRpbmdJZCl7cmV0dXJufWUuX3NvcnRpbmdJZD1cInNoYWRvdy1cIit0aGlzLmhvc3RDb3VudGVyKys7dGhpcy5ob3N0c1tlLl9zb3J0aW5nSWRdPWU7dmFyIG49Z2V0U2hhZG93SG9zdCh7Y29udGV4dDplfSk7aWYobil7dGhpcy5fcmVnaXN0ZXJIb3N0KG4pO3RoaXMuX3JlZ2lzdGVySG9zdFBhcmVudChlLG4pfWVsc2V7dGhpcy5pbkRvY3VtZW50LnB1c2goZSl9fX0se2tleTpcIl9yZWdpc3Rlckhvc3RQYXJlbnRcIix2YWx1ZTpmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0UGFyZW50KGUsbil7aWYoIXRoaXMuaW5Ib3N0W24uX3NvcnRpbmdJZF0pe3RoaXMuaW5Ib3N0W24uX3NvcnRpbmdJZF09W119dGhpcy5pbkhvc3Rbbi5fc29ydGluZ0lkXS5wdXNoKGUpfX0se2tleTpcIl9yZWdpc3RlckVsZW1lbnRcIix2YWx1ZTpmdW5jdGlvbiBfcmVnaXN0ZXJFbGVtZW50KGUsbil7aWYoIXRoaXMuZWxlbWVudHNbbi5fc29ydGluZ0lkXSl7dGhpcy5lbGVtZW50c1tuLl9zb3J0aW5nSWRdPVtdfXRoaXMuZWxlbWVudHNbbi5fc29ydGluZ0lkXS5wdXNoKGUpfX0se2tleTpcImV4dHJhY3RFbGVtZW50c1wiLHZhbHVlOmZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50cyhlKXtyZXR1cm4gZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciBuPWdldFNoYWRvd0hvc3Qoe2NvbnRleHQ6ZX0pO2lmKCFuKXtyZXR1cm4gdHJ1ZX10aGlzLl9yZWdpc3Rlckhvc3Qobik7dGhpcy5fcmVnaXN0ZXJFbGVtZW50KGUsbik7cmV0dXJuIGZhbHNlfSksdGhpcyl9fSx7a2V5Olwic29ydFwiLHZhbHVlOmZ1bmN0aW9uIHNvcnQoZSl7dmFyIG49dGhpcy5faW5qZWN0SG9zdHMoZSk7bj10aGlzLl9yZXBsYWNlSG9zdHMobik7dGhpcy5fY2xlYW51cCgpO3JldHVybiBufX0se2tleTpcIl9pbmplY3RIb3N0c1wiLHZhbHVlOmZ1bmN0aW9uIF9pbmplY3RIb3N0cyhlKXtPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKChmdW5jdGlvbihlKXt2YXIgbj10aGlzLmVsZW1lbnRzW2VdO3ZhciB0PXRoaXMuaW5Ib3N0W2VdO3ZhciByPXRoaXMuaG9zdHNbZV0uc2hhZG93Um9vdDt0aGlzLmVsZW1lbnRzW2VdPXRoaXMuX21lcmdlKG4sdCxyKX0pLHRoaXMpO3JldHVybiB0aGlzLl9tZXJnZShlLHRoaXMuaW5Eb2N1bWVudCx0aGlzLmNvbnRleHQpfX0se2tleTpcIl9tZXJnZVwiLHZhbHVlOmZ1bmN0aW9uIF9tZXJnZShlLG4sdCl7dmFyIHI9bWVyZ2VJbkRvbU9yZGVyKHtsaXN0OmUsZWxlbWVudHM6bn0pO3JldHVybiB0aGlzLnNvcnRFbGVtZW50cyhyLHQpfX0se2tleTpcIl9yZXBsYWNlSG9zdHNcIix2YWx1ZTpmdW5jdGlvbiBfcmVwbGFjZUhvc3RzKGUpe3JldHVybiBtZXJnZUluRG9tT3JkZXIoe2xpc3Q6ZSxlbGVtZW50czp0aGlzLmluRG9jdW1lbnQscmVzb2x2ZUVsZW1lbnQ6dGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcyl9KX19LHtrZXk6XCJfcmVzb2x2ZUhvc3RFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24gX3Jlc29sdmVIb3N0RWxlbWVudChlKXt2YXIgbj1tZXJnZUluRG9tT3JkZXIoe2xpc3Q6dGhpcy5lbGVtZW50c1tlLl9zb3J0aW5nSWRdLGVsZW1lbnRzOnRoaXMuaW5Ib3N0W2UuX3NvcnRpbmdJZF0scmVzb2x2ZUVsZW1lbnQ6dGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcyl9KTt2YXIgdD10YWJpbmRleFZhbHVlKGUpO2lmKHQhPT1udWxsJiZ0Pi0xKXtyZXR1cm5bZV0uY29uY2F0KG4pfXJldHVybiBufX0se2tleTpcIl9jbGVhbnVwXCIsdmFsdWU6ZnVuY3Rpb24gX2NsZWFudXAoKXtPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKChmdW5jdGlvbihlKXtkZWxldGUgdGhpcy5ob3N0c1tlXS5fc29ydGluZ0lkfSksdGhpcyl9fV0pO3JldHVybiBTaGFkb3dzfSgpO2Z1bmN0aW9uIHNvcnRTaGFkb3dlZChlLG4sdCl7dmFyIHI9bmV3IHFlKG4sdCk7dmFyIGE9ci5leHRyYWN0RWxlbWVudHMoZSk7aWYoYS5sZW5ndGg9PT1lLmxlbmd0aCl7cmV0dXJuIHQoZSl9cmV0dXJuIHIuc29ydChhKX1mdW5jdGlvbiBzb3J0VGFiaW5kZXgoZSl7dmFyIG49e307dmFyIHQ9W107dmFyIHI9ZS5maWx0ZXIoKGZ1bmN0aW9uKGUpe3ZhciByPWUudGFiSW5kZXg7aWYocj09PXVuZGVmaW5lZCl7cj10YWJpbmRleFZhbHVlKGUpfWlmKHI8PTB8fHI9PT1udWxsfHxyPT09dW5kZWZpbmVkKXtyZXR1cm4gdHJ1ZX1pZighbltyXSl7bltyXT1bXTt0LnB1c2gocil9bltyXS5wdXNoKGUpO3JldHVybiBmYWxzZX0pKTt2YXIgYT10LnNvcnQoKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBuW2VdfSkpLnJlZHVjZVJpZ2h0KChmdW5jdGlvbihlLG4pe3JldHVybiBuLmNvbmNhdChlKX0pLHIpO3JldHVybiBhfXZhciBVZT12b2lkIDA7ZnVuY3Rpb24gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlLG4pe3ZhciB0PWUuaW5kZXhPZihuKTtpZih0PjApe3ZhciByPWUuc3BsaWNlKHQsMSk7cmV0dXJuIHIuY29uY2F0KGUpfXJldHVybiBlfWZ1bmN0aW9uIHNvcnRFbGVtZW50cyhlLG4pe2lmKFVlLnRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24pe2U9c29ydEFyZWEoZSxuKX1lPXNvcnRUYWJpbmRleChlKTtyZXR1cm4gZX1mdW5jdGlvbiBxdWVyeVRhYnNlcXVlbmNlKCl7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzBdOnt9LG49ZS5jb250ZXh0LHQ9ZS5pbmNsdWRlQ29udGV4dCxyPWUuaW5jbHVkZU9ubHlUYWJiYWJsZSxhPWUuc3RyYXRlZ3k7aWYoIVVlKXtVZT1fc3VwcG9ydHMoKX12YXIgbz1ub2RlQXJyYXkobilbMF18fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt2YXIgaT1xdWVyeVRhYmJhYmxlKHtjb250ZXh0Om8saW5jbHVkZUNvbnRleHQ6dCxpbmNsdWRlT25seVRhYmJhYmxlOnIsc3RyYXRlZ3k6YX0pO2lmKGRvY3VtZW50LmJvZHkuY3JlYXRlU2hhZG93Um9vdCYmcy5pcy5CTElOSyl7aT1zb3J0U2hhZG93ZWQoaSxvLHNvcnRFbGVtZW50cyl9ZWxzZXtpPXNvcnRFbGVtZW50cyhpLG8pfWlmKHQpe2k9bW92ZUNvbnRleHRUb0JlZ2lubmluZyhpLG8pfXJldHVybiBpfXZhciBXZT17dGFiOjksbGVmdDozNyx1cDozOCxyaWdodDozOSxkb3duOjQwLHBhZ2VVcDozMyxcInBhZ2UtdXBcIjozMyxwYWdlRG93bjozNCxcInBhZ2UtZG93blwiOjM0LGVuZDozNSxob21lOjM2LGVudGVyOjEzLGVzY2FwZToyNyxzcGFjZTozMixzaGlmdDoxNixjYXBzTG9jazoyMCxcImNhcHMtbG9ja1wiOjIwLGN0cmw6MTcsYWx0OjE4LG1ldGE6OTEscGF1c2U6MTksaW5zZXJ0OjQ1LGRlbGV0ZTo0NixiYWNrc3BhY2U6OCxfYWxpYXM6ezkxOls5Miw5MywyMjRdfX07Zm9yKHZhciBWZT0xO1ZlPDI2O1ZlKyspe1dlW1wiZlwiK1ZlXT1WZSsxMTF9Zm9yKHZhciBLZT0wO0tlPDEwO0tlKyspe3ZhciBaZT1LZSs0ODt2YXIgR2U9S2UrOTY7V2VbS2VdPVplO1dlW1wibnVtLVwiK0tlXT1HZTtXZS5fYWxpYXNbWmVdPVtHZV19Zm9yKHZhciBZZT0wO1llPDI2O1llKyspe3ZhciBKZT1ZZSs2NTt2YXIgJGU9U3RyaW5nLmZyb21DaGFyQ29kZShKZSkudG9Mb3dlckNhc2UoKTtXZVskZV09SmV9dmFyIFhlPXthbHQ6XCJhbHRLZXlcIixjdHJsOlwiY3RybEtleVwiLG1ldGE6XCJtZXRhS2V5XCIsc2hpZnQ6XCJzaGlmdEtleVwifTt2YXIgUWU9T2JqZWN0LmtleXMoWGUpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIFhlW2VdfSkpO2Z1bmN0aW9uIGNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzKGUpe3ZhciBuPWU/bnVsbDpmYWxzZTtyZXR1cm57YWx0S2V5Om4sY3RybEtleTpuLG1ldGFLZXk6bixzaGlmdEtleTpufX1mdW5jdGlvbiByZXNvbHZlTW9kaWZpZXJzKGUpe3ZhciBuPWUuaW5kZXhPZihcIipcIikhPT0tMTt2YXIgdD1jcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhuKTtlLmZvckVhY2goKGZ1bmN0aW9uKGUpe2lmKGU9PT1cIipcIil7cmV0dXJufXZhciBuPXRydWU7dmFyIHI9ZS5zbGljZSgwLDEpO2lmKHI9PT1cIj9cIil7bj1udWxsfWVsc2UgaWYocj09PVwiIVwiKXtuPWZhbHNlfWlmKG4hPT10cnVlKXtlPWUuc2xpY2UoMSl9dmFyIGE9WGVbZV07aWYoIWEpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbW9kaWZpZXIgXCInK2UrJ1wiJyl9dFthXT1ufSkpO3JldHVybiB0fWZ1bmN0aW9uIHJlc29sdmVLZXkoZSl7dmFyIG49V2VbZV18fHBhcnNlSW50KGUsMTApO2lmKCFufHx0eXBlb2YgbiE9PVwibnVtYmVyXCJ8fGlzTmFOKG4pKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGtleSBcIicrZSsnXCInKX1yZXR1cm5bbl0uY29uY2F0KFdlLl9hbGlhc1tuXXx8W10pfWZ1bmN0aW9uIG1hdGNoTW9kaWZpZXJzKGUsbil7cmV0dXJuIVFlLnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgZVt0XT09PVwiYm9vbGVhblwiJiZCb29sZWFuKG5bdF0pIT09ZVt0XX0pKX1mdW5jdGlvbiBrZXlCaW5kaW5nKGUpe3JldHVybiBlLnNwbGl0KC9cXHMrLykubWFwKChmdW5jdGlvbihlKXt2YXIgbj1lLnNwbGl0KFwiK1wiKTt2YXIgdD1yZXNvbHZlTW9kaWZpZXJzKG4uc2xpY2UoMCwtMSkpO3ZhciByPXJlc29sdmVLZXkobi5zbGljZSgtMSkpO3JldHVybntrZXlDb2RlczpyLG1vZGlmaWVyczp0LG1hdGNoTW9kaWZpZXJzOm1hdGNoTW9kaWZpZXJzLmJpbmQobnVsbCx0KX19KSl9ZnVuY3Rpb24gZ2V0UGFyZW50Q29tcGFyYXRvcigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dW5kZWZpbmVkP2FyZ3VtZW50c1swXTp7fSxuPWUucGFyZW50LHQ9ZS5lbGVtZW50LHI9ZS5pbmNsdWRlU2VsZjtpZihuKXtyZXR1cm4gZnVuY3Rpb24gaXNDaGlsZE9mKGUpe3JldHVybiBCb29sZWFuKHImJmU9PT1ufHxuLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKX19ZWxzZSBpZih0KXtyZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihlKXtyZXR1cm4gQm9vbGVhbihyJiZ0PT09ZXx8ZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0KSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSl9fXRocm93IG5ldyBUeXBlRXJyb3IoXCJ1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50XCIpfWZ1bmN0aW9uIHdoZW5LZXkoKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXVuZGVmaW5lZD9hcmd1bWVudHNbMF06e307dmFyIG49e307dmFyIHQ9bm9kZUFycmF5KGUuY29udGV4dClbMF18fGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtkZWxldGUgZS5jb250ZXh0O3ZhciByPW5vZGVBcnJheShlLmZpbHRlcik7ZGVsZXRlIGUuZmlsdGVyO3ZhciBhPU9iamVjdC5rZXlzKGUpO2lmKCFhLmxlbmd0aCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIndoZW4va2V5IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24ga2V5XCIpfXZhciBvPWZ1bmN0aW9uIHJlZ2lzdGVyQmluZGluZyhlKXtlLmtleUNvZGVzLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lmKCFuW3RdKXtuW3RdPVtdfW5bdF0ucHVzaChlKX0pKX07YS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZih0eXBlb2YgZVtuXSE9PVwiZnVuY3Rpb25cIil7dGhyb3cgbmV3IFR5cGVFcnJvcignd2hlbi9rZXkgcmVxdWlyZXMgb3B0aW9uW1wiJytuKydcIl0gdG8gYmUgYSBmdW5jdGlvbicpfXZhciB0PWZ1bmN0aW9uIGFkZENhbGxiYWNrKHQpe3QuY2FsbGJhY2s9ZVtuXTtyZXR1cm4gdH07a2V5QmluZGluZyhuKS5tYXAodCkuZm9yRWFjaChvKX0pKTt2YXIgaT1mdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpe2lmKGUuZGVmYXVsdFByZXZlbnRlZCl7cmV0dXJufWlmKHIubGVuZ3RoKXt2YXIgYT1nZXRQYXJlbnRDb21wYXJhdG9yKHtlbGVtZW50OmUudGFyZ2V0LGluY2x1ZGVTZWxmOnRydWV9KTtpZihyLnNvbWUoYSkpe3JldHVybn19dmFyIG89ZS5rZXlDb2RlfHxlLndoaWNoO2lmKCFuW29dKXtyZXR1cm59bltvXS5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighbi5tYXRjaE1vZGlmaWVycyhlKSl7cmV0dXJufW4uY2FsbGJhY2suY2FsbCh0LGUsbCl9KSl9O3QuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIixpLGZhbHNlKTt2YXIgbD1mdW5jdGlvbiBkaXNlbmdhZ2UoKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsaSxmYWxzZSl9O3JldHVybntkaXNlbmdhZ2U6bH19ZnVuY3Rpb24gZGVmYXVsdF8xKGUpe3ZhciBuPWU9PT12b2lkIDA/e306ZSx0PW4uY29udGV4dDtpZighdCl7dD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnR9cXVlcnlUYWJzZXF1ZW5jZSgpO3JldHVybiB3aGVuS2V5KHtcIj9hbHQrP3NoaWZ0K3RhYlwiOmZ1bmN0aW9uIGFsdFNoaWZ0VGFiKGUpe2UucHJldmVudERlZmF1bHQoKTt2YXIgbj1xdWVyeVRhYnNlcXVlbmNlKHtjb250ZXh0OnR9KTt2YXIgcj1lLnNoaWZ0S2V5O3ZhciBhPW5bMF07dmFyIG89bltuLmxlbmd0aC0xXTt2YXIgaT1yP2E6bzt2YXIgbD1yP286YTtpZihpc0FjdGl2ZUVsZW1lbnQoaSkpe2wuZm9jdXMoKTtyZXR1cm59dmFyIHM9dm9pZCAwO3ZhciB1PW4uc29tZSgoZnVuY3Rpb24oZSxuKXtpZighaXNBY3RpdmVFbGVtZW50KGUpKXtyZXR1cm4gZmFsc2V9cz1uO3JldHVybiB0cnVlfSkpO2lmKCF1KXthLmZvY3VzKCk7cmV0dXJufXZhciBjPXI/LTE6MTtuW3MrY10uZm9jdXMoKX19KX1uW1wiZGVmYXVsdFwiXT1kZWZhdWx0XzF9LDk5MzpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPXZvaWQgMDt2YXIgYT10KDkxMCk7dmFyIG89KDAsYS5ub29wKShpfHwoaT1yKFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgei1pbmRleDogOTAwMDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBwYWRkaW5nOiAxMHZoIDE1cHggMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgICAgcGFkZGluZzogMTVweCAxNXB4IDA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTcsIDE3LCAxNywgMC4yKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gICAgei1pbmRleDogLTE7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wLWZpeGVkXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIHBhZGRpbmc6IDE1cHggMTVweCAwO1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0pKSk7bi5zdHlsZXM9bzt2YXIgaX0sMzM4OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O3ZhciBpPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcj10LmNhbGwoZSksYSxvPVtdLGk7dHJ5e3doaWxlKChuPT09dm9pZCAwfHxuLS0gPjApJiYhKGE9ci5uZXh0KCkpLmRvbmUpby5wdXNoKGEudmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e2lmKGEmJiFhLmRvbmUmJih0PXJbXCJyZXR1cm5cIl0pKXQuY2FsbChyKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIG99O24uX19lc01vZHVsZT10cnVlO24uU2hhZG93UG9ydGFsPXZvaWQgMDt2YXIgbD1vKHQoNTIyKSk7dmFyIHM9dCgyNTUpO3ZhciB1PWZ1bmN0aW9uIFBvcnRhbChlKXt2YXIgbj1lLmNoaWxkcmVuLHQ9ZS5nbG9iYWxPdmVybGF5O3ZhciByPWwudXNlUmVmKG51bGwpO3ZhciBhPWwudXNlUmVmKG51bGwpO3ZhciBvPWwudXNlUmVmKG51bGwpO3ZhciB1PWkobC51c2VTdGF0ZSgpLDIpLGM9dVsxXTtsLnVzZUxheW91dEVmZmVjdCgoZnVuY3Rpb24oKXt2YXIgZT10P2RvY3VtZW50OnIuY3VycmVudC5vd25lckRvY3VtZW50O2EuY3VycmVudD1lLmNyZWF0ZUVsZW1lbnQoXCJuZXh0anMtcG9ydGFsXCIpO28uY3VycmVudD1hLmN1cnJlbnQuYXR0YWNoU2hhZG93KHttb2RlOlwib3BlblwifSk7ZS5ib2R5LmFwcGVuZENoaWxkKGEuY3VycmVudCk7Yyh7fSk7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoYS5jdXJyZW50JiZhLmN1cnJlbnQub3duZXJEb2N1bWVudCl7YS5jdXJyZW50Lm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhLmN1cnJlbnQpfX19KSxbdF0pO3JldHVybiBvLmN1cnJlbnQ/KDAscy5jcmVhdGVQb3J0YWwpKG4sby5jdXJyZW50KTp0P251bGw6bC5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtyZWY6cn0pfTtuLlNoYWRvd1BvcnRhbD11fSwyMTU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19hc3NpZ258fGZ1bmN0aW9uKCl7cj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIG4sdD0xLHI9YXJndW1lbnRzLmxlbmd0aDt0PHI7dCsrKXtuPWFyZ3VtZW50c1t0XTtmb3IodmFyIGEgaW4gbilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixhKSllW2FdPW5bYV19cmV0dXJuIGV9O3JldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpYShuLGUsdCk7byhuLGUpO3JldHVybiBufTt2YXIgbD10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLlRlcm1pbmFsPXZvaWQgMDt2YXIgcz1sKHQoOTk3KSk7dmFyIHU9aSh0KDUyMikpO3ZhciBjPWZ1bmN0aW9uIFRlcm1pbmFsKGUpe3ZhciBuPWUuY29udGVudDt2YXIgdD11LnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJuIHNbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24obix7anNvbjp0cnVlLHVzZV9jbGFzc2VzOnRydWUscmVtb3ZlX2VtcHR5OnRydWV9KX0pLFtuXSk7cmV0dXJuIHUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtcImRhdGEtbmV4dGpzLXRlcm1pbmFsXCI6dHJ1ZX0sdS5jcmVhdGVFbGVtZW50KFwicHJlXCIsbnVsbCx0Lm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KFwic3BhblwiLHtrZXk6XCJ0ZXJtaW5hbC1lbnRyeS1cIi5jb25jYXQobiksc3R5bGU6cih7Y29sb3I6ZS5mZz9cInZhcigtLWNvbG9yLVwiLmNvbmNhdChlLmZnLFwiKVwiKTp1bmRlZmluZWR9LGUuZGVjb3JhdGlvbj09PVwiYm9sZFwiP3tmb250V2VpZ2h0OjgwMH06ZS5kZWNvcmF0aW9uPT09XCJpdGFsaWNcIj97Zm9udFN0eWxlOlwiaXRhbGljXCJ9OnVuZGVmaW5lZCl9LGUuY29udGVudCl9KSkpKX07bi5UZXJtaW5hbD1jfSwyMzY6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7bi5fX2VzTW9kdWxlPXRydWU7bi5UZXJtaW5hbD12b2lkIDA7dmFyIGE9dCgyMTUpO3IobixhLFwiVGVybWluYWxcIil9LDQ4ODpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O24uX19lc01vZHVsZT10cnVlO24uc3R5bGVzPXZvaWQgMDt2YXIgYT10KDkxMCk7dmFyIG89KDAsYS5ub29wKShpfHwoaT1yKFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSAqOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXNlbGVjdGlvbik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHByZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcXG4gIH1cXG5cIl0sW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSkpKTtuLnN0eWxlcz1vO3ZhciBpfSw2ODM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIGE9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKXIobixlLHQpO2EobixlKTtyZXR1cm4gbn07bi5fX2VzTW9kdWxlPXRydWU7bi5Ub2FzdD12b2lkIDA7dmFyIGk9byh0KDUyMikpO3ZhciBsPWZ1bmN0aW9uIFRvYXN0KGUpe3ZhciBuPWUub25DbGljayx0PWUuY2hpbGRyZW4scj1lLmNsYXNzTmFtZTtyZXR1cm4gaS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtdG9hc3RcIjp0cnVlLG9uQ2xpY2s6bixjbGFzc05hbWU6cn0saS5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlclwiOnRydWV9LHQpKX07bi5Ub2FzdD1sfSwxMjA6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7bi5fX2VzTW9kdWxlPXRydWU7bi5Ub2FzdD1uLnN0eWxlcz12b2lkIDA7dmFyIGE9dCg2OSk7cihuLGEsXCJzdHlsZXNcIik7dmFyIG89dCg2ODMpO3IobixvLFwiVG9hc3RcIil9LDY5OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0fHxmdW5jdGlvbihlLG4pe2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJyYXdcIix7dmFsdWU6bn0pfWVsc2V7ZS5yYXc9bn1yZXR1cm4gZX07bi5fX2VzTW9kdWxlPXRydWU7bi5zdHlsZXM9dm9pZCAwO3ZhciBhPXQoOTEwKTt2YXIgbz0oMCxhLm5vb3ApKGl8fChpPXIoW1wiXFxuICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGxlZnQ6IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIG1heC13aWR0aDogNDIwcHg7XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC13aWR0aDogNDQwcHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgICAgbWF4LXdpZHRoOiA5MHZ3O1xcbiAgICAgIGxlZnQ6IDV2dztcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0LXdyYXBwZXJdIHtcXG4gICAgcGFkZGluZzogMTZweDtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC13aGl0ZSk7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgYm94LXNoYWRvdzogMHB4IHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgdmFyKC0tc2l6ZS1nYXAtcXVhZClcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgfVxcblwiXSxbXCJcXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbWF4LXdpZHRoOiA0MjBweDtcXG4gICAgei1pbmRleDogOTAwMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NDBweCkge1xcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XFxuICAgICAgbGVmdDogNXZ3O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xcbiAgICBwYWRkaW5nOiAxNnB4O1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICB9XFxuXCJdKSkpO24uc3R5bGVzPW87dmFyIGl9LDkzNjpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdHx8ZnVuY3Rpb24oZSxuKXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwicmF3XCIse3ZhbHVlOm59KX1lbHNle2UucmF3PW59cmV0dXJuIGV9O3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIG89dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBpPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKWEobixlLHQpO28obixlKTtyZXR1cm4gbn07bi5fX2VzTW9kdWxlPXRydWU7bi5zdHlsZXM9bi5CdWlsZEVycm9yPXZvaWQgMDt2YXIgbD1pKHQoNTIyKSk7dmFyIHM9dCg2NTEpO3ZhciB1PXQoMjc4KTt2YXIgYz10KDIzNik7dmFyIGY9dCg5MTApO3ZhciBkPWZ1bmN0aW9uIEJ1aWxkRXJyb3IoZSl7dmFyIG49ZS5tZXNzYWdlO3ZhciB0PWwudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7fSksW10pO3JldHVybiBsLmNyZWF0ZUVsZW1lbnQodS5PdmVybGF5LHtmaXhlZDp0cnVlfSxsLmNyZWF0ZUVsZW1lbnQocy5EaWFsb2cse3R5cGU6XCJlcnJvclwiLFwiYXJpYS1sYWJlbGxlZGJ5XCI6XCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9sYWJlbFwiLFwiYXJpYS1kZXNjcmliZWRieVwiOlwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfZGVzY1wiLG9uQ2xvc2U6dH0sbC5jcmVhdGVFbGVtZW50KHMuRGlhbG9nQ29udGVudCxudWxsLGwuY3JlYXRlRWxlbWVudChzLkRpYWxvZ0hlYWRlcix7Y2xhc3NOYW1lOlwibmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXJcIn0sbC5jcmVhdGVFbGVtZW50KFwiaDRcIix7aWQ6XCJuZXh0anNfX2NvbnRhaW5lcl9idWlsZF9lcnJvcl9sYWJlbFwifSxcIkZhaWxlZCB0byBjb21waWxlXCIpKSxsLmNyZWF0ZUVsZW1lbnQocy5EaWFsb2dCb2R5LHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHlcIn0sbC5jcmVhdGVFbGVtZW50KGMuVGVybWluYWwse2NvbnRlbnQ6bn0pLGwuY3JlYXRlRWxlbWVudChcImZvb3RlclwiLG51bGwsbC5jcmVhdGVFbGVtZW50KFwicFwiLHtpZDpcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIn0sbC5jcmVhdGVFbGVtZW50KFwic21hbGxcIixudWxsLFwiVGhpcyBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MgYW5kIGNhbiBvbmx5IGJlIGRpc21pc3NlZCBieSBmaXhpbmcgdGhlIGVycm9yLlwiKSkpKSkpKX07bi5CdWlsZEVycm9yPWQ7bi5zdHlsZXM9KDAsZi5ub29wKSh2fHwodj1yKFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdLFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdKSkpO3ZhciB2fSwzNTU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe2E9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciBvPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDt2YXIgYT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCk7aWYoIWF8fChcImdldFwiaW4gYT8hbi5fX2VzTW9kdWxlOmEud3JpdGFibGV8fGEuY29uZmlndXJhYmxlKSl7YT17ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe3JldHVybiBuW3RdfX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscixhKX06ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7ZVtyXT1uW3RdfSk7dmFyIGk9dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6dHJ1ZSx2YWx1ZTpufSl9OmZ1bmN0aW9uKGUsbil7ZVtcImRlZmF1bHRcIl09bn0pO3ZhciBsPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49e307aWYoZSE9bnVsbClmb3IodmFyIHQgaW4gZSlpZih0IT09XCJkZWZhdWx0XCImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpKW8obixlLHQpO2kobixlKTtyZXR1cm4gbn07dmFyIHM9dGhpcyYmdGhpcy5fX3JlYWR8fGZ1bmN0aW9uKGUsbil7dmFyIHQ9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciByPXQuY2FsbChlKSxhLG89W10saTt0cnl7d2hpbGUoKG49PT12b2lkIDB8fG4tLSA+MCkmJiEoYT1yLm5leHQoKSkuZG9uZSlvLnB1c2goYS52YWx1ZSl9Y2F0Y2goZSl7aT17ZXJyb3I6ZX19ZmluYWxseXt0cnl7aWYoYSYmIWEuZG9uZSYmKHQ9cltcInJldHVyblwiXSkpdC5jYWxsKHIpfWZpbmFsbHl7aWYoaSl0aHJvdyBpLmVycm9yfX1yZXR1cm4gb307bi5fX2VzTW9kdWxlPXRydWU7bi5zdHlsZXM9bi5FcnJvcnM9dm9pZCAwO3ZhciB1PWwodCg1MjIpKTt2YXIgYz10KDg1MSk7dmFyIGY9dCg2NTEpO3ZhciBkPXQoNzMyKTt2YXIgdj10KDI3OCk7dmFyIHA9dCgxMjApO3ZhciBtPXQoNDAzKTt2YXIgYj10KDIzMyk7dmFyIGc9dCg5MTApO3ZhciBoPXQoODY1KTt2YXIgeT10KDQ4NCk7ZnVuY3Rpb24gZ2V0RXJyb3JTaWduYXR1cmUoZSl7dmFyIG49ZS5ldmVudDtzd2l0Y2gobi50eXBlKXtjYXNlIGMuVFlQRV9VTkhBTkRMRURfRVJST1I6Y2FzZSBjLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjp7cmV0dXJuXCJcIi5jb25jYXQobi5yZWFzb24ubmFtZSxcIjo6XCIpLmNvbmNhdChuLnJlYXNvbi5tZXNzYWdlLFwiOjpcIikuY29uY2F0KG4ucmVhc29uLnN0YWNrKX1kZWZhdWx0Ont9fXZhciB0PW47cmV0dXJuXCJcIn12YXIgeD1mdW5jdGlvbiBIb3RsaW5rZWRUZXh0KGUpe3ZhciBuPWUudGV4dDt2YXIgdD0vaHR0cHM/OlxcL1xcL1teXFxzLyQuPyNdLlteXFxzXCJdKi9pO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCxudWxsLHQudGVzdChuKT9uLnNwbGl0KFwiIFwiKS5tYXAoKGZ1bmN0aW9uKGUsbixyKXtpZih0LnRlc3QoZSkpe3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCx7a2V5OlwibGluay1cIi5jb25jYXQobil9LHUuY3JlYXRlRWxlbWVudChcImFcIix7aHJlZjplfSxlKSxuPT09ci5sZW5ndGgtMT9cIlwiOlwiIFwiKX1yZXR1cm4gbj09PXIubGVuZ3RoLTE/dS5jcmVhdGVFbGVtZW50KHUuRnJhZ21lbnQse2tleTpcInRleHQtXCIuY29uY2F0KG4pfSxlKTp1LmNyZWF0ZUVsZW1lbnQodS5GcmFnbWVudCx7a2V5OlwidGV4dC1cIi5jb25jYXQobil9LGUsXCIgXCIpfSkpOm4pfTt2YXIgdz1mdW5jdGlvbiBFcnJvcnMoZSl7dmFyIG49ZS5lcnJvcnM7dmFyIHQ9cyh1LnVzZVN0YXRlKHt9KSwyKSxyPXRbMF0sbz10WzFdO3ZhciBpPXModS51c2VNZW1vKChmdW5jdGlvbigpe3ZhciBlPVtdO3ZhciB0PW51bGw7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBvPW5bYV07dmFyIGk9by5pZDtpZihpIGluIHIpe2UucHVzaChyW2ldKTtjb250aW51ZX1pZihhPjApe3ZhciBsPW5bYS0xXTtpZihnZXRFcnJvclNpZ25hdHVyZShsKT09PWdldEVycm9yU2lnbmF0dXJlKG8pKXtjb250aW51ZX19dD1vO2JyZWFrfXJldHVybltlLHRdfSksW24scl0pLDIpLGw9aVswXSxjPWlbMV07dmFyIGc9dS51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBsLmxlbmd0aDwxJiZCb29sZWFuKG4ubGVuZ3RoKX0pLFtuLmxlbmd0aCxsLmxlbmd0aF0pO3UudXNlRWZmZWN0KChmdW5jdGlvbigpe2lmKGM9PW51bGwpe3JldHVybn12YXIgZT10cnVlOygwLG0uZ2V0RXJyb3JCeVR5cGUpKGMpLnRoZW4oKGZ1bmN0aW9uKG4pe2lmKGUpe28oKGZ1bmN0aW9uKGUpe3ZhciB0O3JldHVybiBhKGEoe30sZSksKHQ9e30sdFtuLmlkXT1uLHQpKX0pKX19KSwoZnVuY3Rpb24oKXt9KSk7cmV0dXJuIGZ1bmN0aW9uKCl7ZT1mYWxzZX19KSxbY10pO3ZhciB3PXModS51c2VTdGF0ZShcImZ1bGxzY3JlZW5cIiksMiksXz13WzBdLEU9d1sxXTt2YXIgaj1zKHUudXNlU3RhdGUoMCksMiksTz1qWzBdLGs9alsxXTt2YXIgUz11LnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtlPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS5wcmV2ZW50RGVmYXVsdCgpO2soKGZ1bmN0aW9uKGUpe3JldHVybiBNYXRoLm1heCgwLGUtMSl9KSl9KSxbXSk7dmFyIFQ9dS51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7ZT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUucHJldmVudERlZmF1bHQoKTtrKChmdW5jdGlvbihlKXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbihsLmxlbmd0aC0xLGUrMSkpfSkpfSksW2wubGVuZ3RoXSk7dmFyIEM9dS51c2VNZW1vKChmdW5jdGlvbigpe3ZhciBlO3JldHVybihlPWxbT10pIT09bnVsbCYmZSE9PXZvaWQgMD9lOm51bGx9KSxbTyxsXSk7dS51c2VFZmZlY3QoKGZ1bmN0aW9uKCl7aWYobi5sZW5ndGg8MSl7byh7fSk7RShcImhpZGRlblwiKTtrKDApfX0pLFtuLmxlbmd0aF0pO3ZhciBEPXUudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKGUpe2U9PT1udWxsfHxlPT09dm9pZCAwP3ZvaWQgMDplLnByZXZlbnREZWZhdWx0KCk7RShcIm1pbmltaXplZFwiKX0pLFtdKTt2YXIgTT11LnVzZUNhbGxiYWNrKChmdW5jdGlvbihlKXtlPT09bnVsbHx8ZT09PXZvaWQgMD92b2lkIDA6ZS5wcmV2ZW50RGVmYXVsdCgpO0UoXCJoaWRkZW5cIil9KSxbXSk7dmFyIFA9dS51c2VDYWxsYmFjaygoZnVuY3Rpb24oZSl7ZT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUucHJldmVudERlZmF1bHQoKTtFKFwiZnVsbHNjcmVlblwiKX0pLFtdKTtpZihuLmxlbmd0aDwxfHxDPT1udWxsKXtyZXR1cm4gbnVsbH1pZihnKXtyZXR1cm4gdS5jcmVhdGVFbGVtZW50KHYuT3ZlcmxheSxudWxsKX1pZihfPT09XCJoaWRkZW5cIil7cmV0dXJuIG51bGx9aWYoXz09PVwibWluaW1pemVkXCIpe3JldHVybiB1LmNyZWF0ZUVsZW1lbnQocC5Ub2FzdCx7Y2xhc3NOYW1lOlwibmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnRcIixvbkNsaWNrOlB9LHUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtjbGFzc05hbWU6XCJuZXh0anMtdG9hc3QtZXJyb3JzXCJ9LHUuY3JlYXRlRWxlbWVudChcInN2Z1wiLHt4bWxuczpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsd2lkdGg6XCIyNFwiLGhlaWdodDpcIjI0XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSx1LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7Y3g6XCIxMlwiLGN5OlwiMTJcIixyOlwiMTBcIn0pLHUuY3JlYXRlRWxlbWVudChcImxpbmVcIix7eDE6XCIxMlwiLHkxOlwiOFwiLHgyOlwiMTJcIix5MjpcIjEyXCJ9KSx1LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIse3gxOlwiMTJcIix5MTpcIjE2XCIseDI6XCIxMi4wMVwiLHkyOlwiMTZcIn0pKSx1LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxsLmxlbmd0aCxcIiBlcnJvclwiLGwubGVuZ3RoPjE/XCJzXCI6XCJcIiksdS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIse1wiZGF0YS1uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uXCI6dHJ1ZSxjbGFzc05hbWU6XCJuZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uXCIsdHlwZTpcImJ1dHRvblwiLG9uQ2xpY2s6ZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKTtNKCl9LFwiYXJpYS1sYWJlbFwiOlwiSGlkZSBFcnJvcnNcIn0sdS5jcmVhdGVFbGVtZW50KGguQ2xvc2VJY29uLG51bGwpKSkpfXZhciB6PVtcInNlcnZlclwiLFwiZWRnZS1zZXJ2ZXJcIl0uaW5jbHVkZXMoKDAsYi5nZXRFcnJvclNvdXJjZSkoQy5lcnJvcil8fFwiXCIpO3JldHVybiB1LmNyZWF0ZUVsZW1lbnQodi5PdmVybGF5LG51bGwsdS5jcmVhdGVFbGVtZW50KGYuRGlhbG9nLHt0eXBlOlwiZXJyb3JcIixcImFyaWEtbGFiZWxsZWRieVwiOlwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIsXCJhcmlhLWRlc2NyaWJlZGJ5XCI6XCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfZGVzY1wiLG9uQ2xvc2U6ej91bmRlZmluZWQ6RH0sdS5jcmVhdGVFbGVtZW50KGYuRGlhbG9nQ29udGVudCxudWxsLHUuY3JlYXRlRWxlbWVudChmLkRpYWxvZ0hlYWRlcix7Y2xhc3NOYW1lOlwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyXCJ9LHUuY3JlYXRlRWxlbWVudChkLkxlZnRSaWdodERpYWxvZ0hlYWRlcix7cHJldmlvdXM6Tz4wP1M6bnVsbCxuZXh0Ok88bC5sZW5ndGgtMT9UOm51bGwsY2xvc2U6ej91bmRlZmluZWQ6RH0sdS5jcmVhdGVFbGVtZW50KFwic21hbGxcIixudWxsLHUuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLE8rMSksXCIgb2ZcIixcIiBcIix1LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsbnVsbCxsLmxlbmd0aCksXCIgdW5oYW5kbGVkIGVycm9yXCIsbC5sZW5ndGg8Mj9cIlwiOlwic1wiKSksdS5jcmVhdGVFbGVtZW50KFwiaDFcIix7aWQ6XCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfbGFiZWxcIn0sej9cIlNlcnZlciBFcnJvclwiOlwiVW5oYW5kbGVkIFJ1bnRpbWUgRXJyb3JcIiksdS5jcmVhdGVFbGVtZW50KFwicFwiLHtpZDpcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCJ9LEMuZXJyb3IubmFtZSxcIjpcIixcIiBcIix1LmNyZWF0ZUVsZW1lbnQoeCx7dGV4dDpDLmVycm9yLm1lc3NhZ2V9KSksej91LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIixudWxsLHUuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsbnVsbCxcIlRoaXMgZXJyb3IgaGFwcGVuZWQgd2hpbGUgZ2VuZXJhdGluZyB0aGUgcGFnZS4gQW55IGNvbnNvbGUgbG9ncyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgdGVybWluYWwgd2luZG93LlwiKSk6dW5kZWZpbmVkKSx1LmNyZWF0ZUVsZW1lbnQoZi5EaWFsb2dCb2R5LHtjbGFzc05hbWU6XCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5XCJ9LHUuY3JlYXRlRWxlbWVudCh5LlJ1bnRpbWVFcnJvcix7a2V5OkMuaWQudG9TdHJpbmcoKSxlcnJvcjpDfSkpKSkpfTtuLkVycm9ycz13O24uc3R5bGVzPSgwLGcubm9vcCkoX3x8KF89cihbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBoMSB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCB7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMSk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciBzbWFsbCA+IHNwYW4ge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAge1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBkaXYgPiBzbWFsbCB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gcCA+IGEge1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyA+IHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtaGlkZS1idXR0b24ge1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtdHJpcGxlKTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjVzIGVhc2U7XFxuICAgIG9wYWNpdHk6IDAuNztcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gIH1cXG5cIl0sW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAgPiBhIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDU6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG5cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudCB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudDpob3ZlciB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMgPiBzdmcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLWhpZGUtYnV0dG9uIHtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwLXRyaXBsZSk7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1oaWRlLWJ1dHRvbjpob3ZlciB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuXCJdKSkpO3ZhciBffSw0ODQ6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O3ZhciBsPXRoaXMmJnRoaXMuX19yZWFkfHxmdW5jdGlvbihlLG4pe3ZhciB0PXR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcj10LmNhbGwoZSksYSxvPVtdLGk7dHJ5e3doaWxlKChuPT09dm9pZCAwfHxuLS0gPjApJiYhKGE9ci5uZXh0KCkpLmRvbmUpby5wdXNoKGEudmFsdWUpfWNhdGNoKGUpe2k9e2Vycm9yOmV9fWZpbmFsbHl7dHJ5e2lmKGEmJiFhLmRvbmUmJih0PXJbXCJyZXR1cm5cIl0pKXQuY2FsbChyKX1maW5hbGx5e2lmKGkpdGhyb3cgaS5lcnJvcn19cmV0dXJuIG99O24uX19lc01vZHVsZT10cnVlO24uUnVudGltZUVycm9yPW4uc3R5bGVzPXZvaWQgMDt2YXIgcz1pKHQoNTIyKSk7dmFyIHU9dCg0MTMpO3ZhciBjPXQoOTEwKTt2YXIgZj10KDUwNCk7dmFyIGQ9ZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoZSl7dmFyIG47dmFyIHQ9ZS5mcmFtZTt2YXIgcj0obj10Lm9yaWdpbmFsU3RhY2tGcmFtZSkhPT1udWxsJiZuIT09dm9pZCAwP246dC5zb3VyY2VTdGFja0ZyYW1lO3ZhciBhPUJvb2xlYW4odC5vcmlnaW5hbENvZGVGcmFtZSk7dmFyIG89cy51c2VDYWxsYmFjaygoZnVuY3Rpb24oKXt2YXIgZTtpZighYSlyZXR1cm47dmFyIG49bmV3IFVSTFNlYXJjaFBhcmFtcztmb3IodmFyIHQgaW4gcil7bi5hcHBlbmQodCwoKGU9clt0XSkhPT1udWxsJiZlIT09dm9pZCAwP2U6XCJcIikudG9TdHJpbmcoKSl9c2VsZi5mZXRjaChcIlwiLmNvbmNhdChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwiLFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIpLmNvbmNhdChuLnRvU3RyaW5nKCkpKS50aGVuKChmdW5jdGlvbigpe30pLChmdW5jdGlvbigpe2NvbnNvbGUuZXJyb3IoXCJUaGVyZSB3YXMgYW4gaXNzdWUgb3BlbmluZyB0aGlzIGNvZGUgaW4geW91ciBlZGl0b3IuXCIpfSkpfSksW2Escl0pO3JldHVybiBzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIix7XCJkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXCI6dHJ1ZX0scy5jcmVhdGVFbGVtZW50KFwiaDZcIix7XCJkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZFwiOkJvb2xlYW4odC5leHBhbmRlZCl9LHIubWV0aG9kTmFtZSkscy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse1wiZGF0YS1oYXMtc291cmNlXCI6YT9cInRydWVcIjp1bmRlZmluZWQsdGFiSW5kZXg6YT8xMDp1bmRlZmluZWQscm9sZTphP1wibGlua1wiOnVuZGVmaW5lZCxvbkNsaWNrOm8sdGl0bGU6YT9cIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIjp1bmRlZmluZWR9LHMuY3JlYXRlRWxlbWVudChcInNwYW5cIixudWxsLCgwLGYuZ2V0RnJhbWVTb3VyY2UpKHIpKSxzLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7eG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLHZpZXdCb3g6XCIwIDAgMjQgMjRcIixmaWxsOlwibm9uZVwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0scy5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIn0pLHMuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIse3BvaW50czpcIjE1IDMgMjEgMyAyMSA5XCJ9KSxzLmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIse3gxOlwiMTBcIix5MTpcIjE0XCIseDI6XCIyMVwiLHkyOlwiM1wifSkpKSl9O3ZhciB2PWZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihlKXt2YXIgbj1lLmVycm9yO3ZhciB0PXMudXNlTWVtbygoZnVuY3Rpb24oKXtyZXR1cm4gbi5mcmFtZXMuZmluZEluZGV4KChmdW5jdGlvbihlKXtyZXR1cm4gZS5leHBhbmRlZCYmQm9vbGVhbihlLm9yaWdpbmFsQ29kZUZyYW1lKSYmQm9vbGVhbihlLm9yaWdpbmFsU3RhY2tGcmFtZSl9KSl9KSxbbi5mcmFtZXNdKTt2YXIgcj1zLnVzZU1lbW8oKGZ1bmN0aW9uKCl7dmFyIGU7cmV0dXJuKGU9bi5mcmFtZXNbdF0pIT09bnVsbCYmZSE9PXZvaWQgMD9lOm51bGx9KSxbbi5mcmFtZXMsdF0pO3ZhciBhPXMudXNlTWVtbygoZnVuY3Rpb24oKXtyZXR1cm4gdDwwP1tdOm4uZnJhbWVzLnNsaWNlKDAsdCl9KSxbbi5mcmFtZXMsdF0pO3ZhciBvPWwocy51c2VTdGF0ZShyPT1udWxsKSwyKSxpPW9bMF0sYz1vWzFdO3ZhciBmPXMudXNlQ2FsbGJhY2soKGZ1bmN0aW9uKCl7YygoZnVuY3Rpb24oZSl7cmV0dXJuIWV9KSl9KSxbXSk7dmFyIHY9cy51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBhLmZpbHRlcigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZXhwYW5kZWR8fGl9KSl9KSxbaSxhXSk7dmFyIHA9cy51c2VNZW1vKChmdW5jdGlvbigpe3JldHVybiBuLmZyYW1lcy5zbGljZSh0KzEpfSksW24uZnJhbWVzLHRdKTt2YXIgbT1zLnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJuIHAuZmlsdGVyKChmdW5jdGlvbihlKXtyZXR1cm4gZS5leHBhbmRlZHx8aX0pKX0pLFtpLHBdKTt2YXIgYj1zLnVzZU1lbW8oKGZ1bmN0aW9uKCl7cmV0dXJuIHAubGVuZ3RoIT09bS5sZW5ndGh8fGkmJnIhPW51bGx9KSxbaSxwLmxlbmd0aCxyLG0ubGVuZ3RoXSk7cmV0dXJuIHMuY3JlYXRlRWxlbWVudChzLkZyYWdtZW50LG51bGwscj9zLmNyZWF0ZUVsZW1lbnQocy5GcmFnbWVudCxudWxsLHMuY3JlYXRlRWxlbWVudChcImg1XCIsbnVsbCxcIlNvdXJjZVwiKSx2Lm1hcCgoZnVuY3Rpb24oZSxuKXtyZXR1cm4gcy5jcmVhdGVFbGVtZW50KGQse2tleTpcImxlYWRpbmctZnJhbWUtXCIuY29uY2F0KG4sXCItXCIpLmNvbmNhdChpKSxmcmFtZTplfSl9KSkscy5jcmVhdGVFbGVtZW50KHUuQ29kZUZyYW1lLHtzdGFja0ZyYW1lOnIub3JpZ2luYWxTdGFja0ZyYW1lLGNvZGVGcmFtZTpyLm9yaWdpbmFsQ29kZUZyYW1lfSkpOnVuZGVmaW5lZCxtLmxlbmd0aD9zLmNyZWF0ZUVsZW1lbnQocy5GcmFnbWVudCxudWxsLHMuY3JlYXRlRWxlbWVudChcImg1XCIsbnVsbCxcIkNhbGwgU3RhY2tcIiksbS5tYXAoKGZ1bmN0aW9uKGUsbil7cmV0dXJuIHMuY3JlYXRlRWxlbWVudChkLHtrZXk6XCJjYWxsLXN0YWNrLVwiLmNvbmNhdChuLFwiLVwiKS5jb25jYXQoaSksZnJhbWU6ZX0pfSkpKTp1bmRlZmluZWQsYj9zLmNyZWF0ZUVsZW1lbnQocy5GcmFnbWVudCxudWxsLHMuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLHt0YWJJbmRleDoxMCxcImRhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXCI6dHJ1ZSx0eXBlOlwiYnV0dG9uXCIsb25DbGljazpmfSxpP1wiSGlkZVwiOlwiU2hvd1wiLFwiIGNvbGxhcHNlZCBmcmFtZXNcIikpOnVuZGVmaW5lZCl9O24uUnVudGltZUVycm9yPXY7bi5zdHlsZXM9KDAsYy5ub29wKShwfHwocD1yKFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdLFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdKSkpO3ZhciBwfSw0MDM6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihlLG4sdCxyKXtmdW5jdGlvbiBhZG9wdChlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHQ/ZTpuZXcgdCgoZnVuY3Rpb24obil7bihlKX0pKX1yZXR1cm4gbmV3KHR8fCh0PVByb21pc2UpKSgoZnVuY3Rpb24odCxhKXtmdW5jdGlvbiBmdWxmaWxsZWQoZSl7dHJ5e3N0ZXAoci5uZXh0KGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiByZWplY3RlZChlKXt0cnl7c3RlcChyW1widGhyb3dcIl0oZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIHN0ZXAoZSl7ZS5kb25lP3QoZS52YWx1ZSk6YWRvcHQoZS52YWx1ZSkudGhlbihmdWxmaWxsZWQscmVqZWN0ZWQpfXN0ZXAoKHI9ci5hcHBseShlLG58fFtdKSkubmV4dCgpKX0pKX07dmFyIGE9dGhpcyYmdGhpcy5fX2dlbmVyYXRvcnx8ZnVuY3Rpb24oZSxuKXt2YXIgdD17bGFiZWw6MCxzZW50OmZ1bmN0aW9uKCl7aWYob1swXSYxKXRocm93IG9bMV07cmV0dXJuIG9bMV19LHRyeXM6W10sb3BzOltdfSxyLGEsbyxpO3JldHVybiBpPXtuZXh0OnZlcmIoMCksdGhyb3c6dmVyYigxKSxyZXR1cm46dmVyYigyKX0sdHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmKGlbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSksaTtmdW5jdGlvbiB2ZXJiKGUpe3JldHVybiBmdW5jdGlvbihuKXtyZXR1cm4gc3RlcChbZSxuXSl9fWZ1bmN0aW9uIHN0ZXAoaSl7aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTt3aGlsZSh0KXRyeXtpZihyPTEsYSYmKG89aVswXSYyP2FbXCJyZXR1cm5cIl06aVswXT9hW1widGhyb3dcIl18fCgobz1hW1wicmV0dXJuXCJdKSYmby5jYWxsKGEpLDApOmEubmV4dCkmJiEobz1vLmNhbGwoYSxpWzFdKSkuZG9uZSlyZXR1cm4gbztpZihhPTAsbylpPVtpWzBdJjIsby52YWx1ZV07c3dpdGNoKGlbMF0pe2Nhc2UgMDpjYXNlIDE6bz1pO2JyZWFrO2Nhc2UgNDp0LmxhYmVsKys7cmV0dXJue3ZhbHVlOmlbMV0sZG9uZTpmYWxzZX07Y2FzZSA1OnQubGFiZWwrKzthPWlbMV07aT1bMF07Y29udGludWU7Y2FzZSA3Omk9dC5vcHMucG9wKCk7dC50cnlzLnBvcCgpO2NvbnRpbnVlO2RlZmF1bHQ6aWYoIShvPXQudHJ5cyxvPW8ubGVuZ3RoPjAmJm9bby5sZW5ndGgtMV0pJiYoaVswXT09PTZ8fGlbMF09PT0yKSl7dD0wO2NvbnRpbnVlfWlmKGlbMF09PT0zJiYoIW98fGlbMV0+b1swXSYmaVsxXTxvWzNdKSl7dC5sYWJlbD1pWzFdO2JyZWFrfWlmKGlbMF09PT02JiZ0LmxhYmVsPG9bMV0pe3QubGFiZWw9b1sxXTtvPWk7YnJlYWt9aWYobyYmdC5sYWJlbDxvWzJdKXt0LmxhYmVsPW9bMl07dC5vcHMucHVzaChpKTticmVha31pZihvWzJdKXQub3BzLnBvcCgpO3QudHJ5cy5wb3AoKTtjb250aW51ZX1pPW4uY2FsbChlLHQpfWNhdGNoKGUpe2k9WzYsZV07YT0wfWZpbmFsbHl7cj1vPTB9aWYoaVswXSY1KXRocm93IGlbMV07cmV0dXJue3ZhbHVlOmlbMF0/aVsxXTp2b2lkIDAsZG9uZTp0cnVlfX19O24uX19lc01vZHVsZT10cnVlO24uZ2V0RXJyb3JCeVR5cGU9dm9pZCAwO3ZhciBvPXQoODUxKTt2YXIgaT10KDIzMyk7dmFyIGw9dCg1MDQpO2Z1bmN0aW9uIGdldEVycm9yQnlUeXBlKGUpe3JldHVybiByKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgbix0LHIsczt2YXIgdTtyZXR1cm4gYSh0aGlzLChmdW5jdGlvbihhKXtzd2l0Y2goYS5sYWJlbCl7Y2FzZSAwOm49ZS5pZCx0PWUuZXZlbnQ7cj10LnR5cGU7c3dpdGNoKHIpe2Nhc2Ugby5UWVBFX1VOSEFORExFRF9FUlJPUjpyZXR1cm5bMywxXTtjYXNlIG8uVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOnJldHVyblszLDFdfXJldHVyblszLDNdO2Nhc2UgMTp1PXtpZDpuLHJ1bnRpbWU6dHJ1ZSxlcnJvcjp0LnJlYXNvbn07cmV0dXJuWzQsKDAsbC5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzKSh0LmZyYW1lcywoMCxpLmdldEVycm9yU291cmNlKSh0LnJlYXNvbiksdC5yZWFzb24udG9TdHJpbmcoKSldO2Nhc2UgMjpyZXR1cm5bMiwodS5mcmFtZXM9YS5zZW50KCksdSldO2Nhc2UgMzp7cmV0dXJuWzMsNF19YS5sYWJlbD00O2Nhc2UgNDpzPXQ7dGhyb3cgbmV3IEVycm9yKFwidHlwZSBzeXN0ZW0gaW52YXJpYW50IHZpb2xhdGlvblwiKX19KSl9KSl9bi5nZXRFcnJvckJ5VHlwZT1nZXRFcnJvckJ5VHlwZX0sMjMzOmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fYXNzaWdufHxmdW5jdGlvbigpe3I9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24oZSl7Zm9yKHZhciBuLHQ9MSxyPWFyZ3VtZW50cy5sZW5ndGg7dDxyO3QrKyl7bj1hcmd1bWVudHNbdF07Zm9yKHZhciBhIGluIG4paWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sYSkpZVthXT1uW2FdfXJldHVybiBlfTtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O24uX19lc01vZHVsZT10cnVlO24uZ2V0U2VydmVyRXJyb3I9bi5kZWNvcmF0ZVNlcnZlckVycm9yPW4uZ2V0RXJyb3JTb3VyY2U9bi5nZXRGaWxlc3lzdGVtRnJhbWU9dm9pZCAwO3ZhciBhPXQoOTc0KTtmdW5jdGlvbiBnZXRGaWxlc3lzdGVtRnJhbWUoZSl7dmFyIG49cih7fSxlKTtpZih0eXBlb2Ygbi5maWxlPT09XCJzdHJpbmdcIil7aWYobi5maWxlLnN0YXJ0c1dpdGgoXCIvXCIpfHwvXlthLXpdOlxcXFwvaS50ZXN0KG4uZmlsZSl8fG4uZmlsZS5zdGFydHNXaXRoKFwiXFxcXFxcXFxcIikpe24uZmlsZT1cImZpbGU6Ly9cIi5jb25jYXQobi5maWxlKX19cmV0dXJuIG59bi5nZXRGaWxlc3lzdGVtRnJhbWU9Z2V0RmlsZXN5c3RlbUZyYW1lO3ZhciBvPVN5bWJvbChcIk5leHRqc0Vycm9yXCIpO2Z1bmN0aW9uIGdldEVycm9yU291cmNlKGUpe3JldHVybiBlW29dfHxudWxsfW4uZ2V0RXJyb3JTb3VyY2U9Z2V0RXJyb3JTb3VyY2U7ZnVuY3Rpb24gZGVjb3JhdGVTZXJ2ZXJFcnJvcihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8se3dyaXRhYmxlOmZhbHNlLGVudW1lcmFibGU6ZmFsc2UsY29uZmlndXJhYmxlOmZhbHNlLHZhbHVlOm59KX1uLmRlY29yYXRlU2VydmVyRXJyb3I9ZGVjb3JhdGVTZXJ2ZXJFcnJvcjtmdW5jdGlvbiBnZXRTZXJ2ZXJFcnJvcihlLG4pe3ZhciB0O3RyeXt0aHJvdyBuZXcgRXJyb3IoZS5tZXNzYWdlKX1jYXRjaChlKXt0PWV9dC5uYW1lPWUubmFtZTt0cnl7dC5zdGFjaz1cIlwiLmNvbmNhdCh0LnRvU3RyaW5nKCksXCJcXG5cIikuY29uY2F0KCgwLGEucGFyc2UpKGUuc3RhY2spLm1hcChnZXRGaWxlc3lzdGVtRnJhbWUpLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG49XCIgICAgYXQgXCIuY29uY2F0KGUubWV0aG9kTmFtZSk7aWYoZS5maWxlKXt2YXIgdD1lLmZpbGU7aWYoZS5saW5lTnVtYmVyKXt0Kz1cIjpcIi5jb25jYXQoZS5saW5lTnVtYmVyKTtpZihlLmNvbHVtbil7dCs9XCI6XCIuY29uY2F0KGUuY29sdW1uKX19bis9XCIgKFwiLmNvbmNhdCh0LFwiKVwiKX1yZXR1cm4gbn0pKS5qb2luKFwiXFxuXCIpKX1jYXRjaChuKXt0LnN0YWNrPWUuc3RhY2t9ZGVjb3JhdGVTZXJ2ZXJFcnJvcih0LG4pO3JldHVybiB0fW4uZ2V0U2VydmVyRXJyb3I9Z2V0U2VydmVyRXJyb3J9LDkxMDpmdW5jdGlvbihlLG4pe24uX19lc01vZHVsZT10cnVlO24ubm9vcD12b2lkIDA7ZnVuY3Rpb24gbm9vcChlKXt2YXIgbj1bXTtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtuW3QtMV09YXJndW1lbnRzW3RdfXZhciByPWUubGVuZ3RoLTE7cmV0dXJuIGUuc2xpY2UoMCxyKS5yZWR1Y2UoKGZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZSt0K25bcl19KSxcIlwiKStlW3JdfW4ubm9vcD1ub29wfSw2MzY6ZnVuY3Rpb24oZSxuLHQpe24uX19lc01vZHVsZT10cnVlO24ucGFyc2VTdGFjaz12b2lkIDA7dmFyIHI9dCg5NzQpO3ZhciBhPS9cXC9fbmV4dChcXC9zdGF0aWNcXC8uKykvZztmdW5jdGlvbiBwYXJzZVN0YWNrKGUpe3ZhciBuPSgwLHIucGFyc2UpKGUpO3JldHVybiBuLm1hcCgoZnVuY3Rpb24oZSl7dmFyIG4sdDt0cnl7dmFyIHI9bmV3IFVSTChlLmZpbGUpO3ZhciBvPWEuZXhlYyhyLnBhdGhuYW1lKTtpZihvKXt2YXIgaT0odD0obj1wcm9jZXNzLmVudi5fX05FWFRfRElTVF9ESVIpPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5yZXBsYWNlKC9cXFxcL2csXCIvXCIpKT09PW51bGx8fHQ9PT12b2lkIDA/dm9pZCAwOnQucmVwbGFjZSgvXFwvJC8sXCJcIik7aWYoaSl7ZS5maWxlPVwiZmlsZTovL1wiK2kuY29uY2F0KG8ucG9wKCkpfX19Y2F0Y2goZSl7fXJldHVybiBlfSkpfW4ucGFyc2VTdGFjaz1wYXJzZVN0YWNrfSw1MDQ6ZnVuY3Rpb24oZSxuKXt2YXIgdD10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oZSxuLHQscil7ZnVuY3Rpb24gYWRvcHQoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiB0P2U6bmV3IHQoKGZ1bmN0aW9uKG4pe24oZSl9KSl9cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoKGZ1bmN0aW9uKHQsYSl7ZnVuY3Rpb24gZnVsZmlsbGVkKGUpe3RyeXtzdGVwKHIubmV4dChlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gcmVqZWN0ZWQoZSl7dHJ5e3N0ZXAocltcInRocm93XCJdKGUpKX1jYXRjaChlKXthKGUpfX1mdW5jdGlvbiBzdGVwKGUpe2UuZG9uZT90KGUudmFsdWUpOmFkb3B0KGUudmFsdWUpLnRoZW4oZnVsZmlsbGVkLHJlamVjdGVkKX1zdGVwKChyPXIuYXBwbHkoZSxufHxbXSkpLm5leHQoKSl9KSl9O3ZhciByPXRoaXMmJnRoaXMuX19nZW5lcmF0b3J8fGZ1bmN0aW9uKGUsbil7dmFyIHQ9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKG9bMF0mMSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX0scixhLG8saTtyZXR1cm4gaT17bmV4dDp2ZXJiKDApLHRocm93OnZlcmIoMSkscmV0dXJuOnZlcmIoMil9LHR5cGVvZiBTeW1ib2w9PT1cImZ1bmN0aW9uXCImJihpW1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLGk7ZnVuY3Rpb24gdmVyYihlKXtyZXR1cm4gZnVuY3Rpb24obil7cmV0dXJuIHN0ZXAoW2Usbl0pfX1mdW5jdGlvbiBzdGVwKGkpe2lmKHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7d2hpbGUodCl0cnl7aWYocj0xLGEmJihvPWlbMF0mMj9hW1wicmV0dXJuXCJdOmlbMF0/YVtcInRocm93XCJdfHwoKG89YVtcInJldHVyblwiXSkmJm8uY2FsbChhKSwwKTphLm5leHQpJiYhKG89by5jYWxsKGEsaVsxXSkpLmRvbmUpcmV0dXJuIG87aWYoYT0wLG8paT1baVswXSYyLG8udmFsdWVdO3N3aXRjaChpWzBdKXtjYXNlIDA6Y2FzZSAxOm89aTticmVhaztjYXNlIDQ6dC5sYWJlbCsrO3JldHVybnt2YWx1ZTppWzFdLGRvbmU6ZmFsc2V9O2Nhc2UgNTp0LmxhYmVsKys7YT1pWzFdO2k9WzBdO2NvbnRpbnVlO2Nhc2UgNzppPXQub3BzLnBvcCgpO3QudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz10LnRyeXMsbz1vLmxlbmd0aD4wJiZvW28ubGVuZ3RoLTFdKSYmKGlbMF09PT02fHxpWzBdPT09Mikpe3Q9MDtjb250aW51ZX1pZihpWzBdPT09MyYmKCFvfHxpWzFdPm9bMF0mJmlbMV08b1szXSkpe3QubGFiZWw9aVsxXTticmVha31pZihpWzBdPT09NiYmdC5sYWJlbDxvWzFdKXt0LmxhYmVsPW9bMV07bz1pO2JyZWFrfWlmKG8mJnQubGFiZWw8b1syXSl7dC5sYWJlbD1vWzJdO3Qub3BzLnB1c2goaSk7YnJlYWt9aWYob1syXSl0Lm9wcy5wb3AoKTt0LnRyeXMucG9wKCk7Y29udGludWV9aT1uLmNhbGwoZSx0KX1jYXRjaChlKXtpPVs2LGVdO2E9MH1maW5hbGx5e3I9bz0wfWlmKGlbMF0mNSl0aHJvdyBpWzFdO3JldHVybnt2YWx1ZTppWzBdP2lbMV06dm9pZCAwLGRvbmU6dHJ1ZX19fTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLmdldEZyYW1lU291cmNlPW4uZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcz1uLmdldE9yaWdpbmFsU3RhY2tGcmFtZT12b2lkIDA7ZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKGUsbixhKXt2YXIgbyxpO2Z1bmN0aW9uIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKXt2YXIgbyxpLGwscyx1O3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxjLGYsZCx2LHAsbSxiLGc7cmV0dXJuIHIodGhpcywoZnVuY3Rpb24ocil7c3dpdGNoKHIubGFiZWwpe2Nhc2UgMDp0PW5ldyBVUkxTZWFyY2hQYXJhbXM7dC5hcHBlbmQoXCJpc1NlcnZlclwiLFN0cmluZyhuPT09XCJzZXJ2ZXJcIikpO3QuYXBwZW5kKFwiaXNFZGdlU2VydmVyXCIsU3RyaW5nKG49PT1cImVkZ2Utc2VydmVyXCIpKTt0LmFwcGVuZChcImVycm9yTWVzc2FnZVwiLGEpO2ZvcihjIGluIGUpe3QuYXBwZW5kKGMsKChvPWVbY10pIT09bnVsbCYmbyE9PXZvaWQgMD9vOlwiXCIpLnRvU3RyaW5nKCkpfWY9bmV3IEFib3J0Q29udHJvbGxlcjtkPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7cmV0dXJuIGYuYWJvcnQoKX0pLDNlMyk7cmV0dXJuWzQsc2VsZi5mZXRjaChcIlwiLmNvbmNhdChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIfHxcIlwiLFwiL19fbmV4dGpzX29yaWdpbmFsLXN0YWNrLWZyYW1lP1wiKS5jb25jYXQodC50b1N0cmluZygpKSx7c2lnbmFsOmYuc2lnbmFsfSlbXCJmaW5hbGx5XCJdKChmdW5jdGlvbigpe2NsZWFyVGltZW91dChkKX0pKV07Y2FzZSAxOnY9ci5zZW50KCk7aWYoISghdi5va3x8di5zdGF0dXM9PT0yMDQpKXJldHVyblszLDNdO209KHA9UHJvbWlzZSkucmVqZWN0O2I9RXJyb3IuYmluZDtyZXR1cm5bNCx2LnRleHQoKV07Y2FzZSAyOnJldHVyblsyLG0uYXBwbHkocCxbbmV3KGIuYXBwbHkoRXJyb3IsW3ZvaWQgMCxyLnNlbnQoKV0pKV0pXTtjYXNlIDM6cmV0dXJuWzQsdi5qc29uKCldO2Nhc2UgNDpnPXIuc2VudCgpO3JldHVyblsyLHtlcnJvcjpmYWxzZSxyZWFzb246bnVsbCxleHRlcm5hbDpmYWxzZSxleHBhbmRlZDohQm9vbGVhbigodT0oKGk9ZS5maWxlKT09PW51bGx8fGk9PT12b2lkIDA/dm9pZCAwOmkuaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIikpfHwoKHM9KGw9Zy5vcmlnaW5hbFN0YWNrRnJhbWUpPT09bnVsbHx8bD09PXZvaWQgMD92b2lkIDA6bC5maWxlKT09PW51bGx8fHM9PT12b2lkIDA/dm9pZCAwOnMuaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIikpKSE9PW51bGwmJnUhPT12b2lkIDA/dTp0cnVlKSxzb3VyY2VTdGFja0ZyYW1lOmUsb3JpZ2luYWxTdGFja0ZyYW1lOmcub3JpZ2luYWxTdGFja0ZyYW1lLG9yaWdpbmFsQ29kZUZyYW1lOmcub3JpZ2luYWxDb2RlRnJhbWV8fG51bGx9XX19KSl9KSl9aWYoISgoKG89ZS5maWxlKT09PW51bGx8fG89PT12b2lkIDA/dm9pZCAwOm8uc3RhcnRzV2l0aChcIndlYnBhY2staW50ZXJuYWw6XCIpKXx8KChpPWUuZmlsZSk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkpKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtlcnJvcjpmYWxzZSxyZWFzb246bnVsbCxleHRlcm5hbDp0cnVlLGV4cGFuZGVkOmZhbHNlLHNvdXJjZVN0YWNrRnJhbWU6ZSxvcmlnaW5hbFN0YWNrRnJhbWU6bnVsbCxvcmlnaW5hbENvZGVGcmFtZTpudWxsfSl9cmV0dXJuIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKVtcImNhdGNoXCJdKChmdW5jdGlvbihuKXt2YXIgdCxyO3JldHVybntlcnJvcjp0cnVlLHJlYXNvbjoocj0odD1uPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi5tZXNzYWdlKSE9PW51bGwmJnQhPT12b2lkIDA/dDpuPT09bnVsbHx8bj09PXZvaWQgMD92b2lkIDA6bi50b1N0cmluZygpKSE9PW51bGwmJnIhPT12b2lkIDA/cjpcIlVua25vd24gRXJyb3JcIixleHRlcm5hbDpmYWxzZSxleHBhbmRlZDpmYWxzZSxzb3VyY2VTdGFja0ZyYW1lOmUsb3JpZ2luYWxTdGFja0ZyYW1lOm51bGwsb3JpZ2luYWxDb2RlRnJhbWU6bnVsbH19KSl9bi5nZXRPcmlnaW5hbFN0YWNrRnJhbWU9Z2V0T3JpZ2luYWxTdGFja0ZyYW1lO2Z1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoZSxuLHQpe3JldHVybiBQcm9taXNlLmFsbChlLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIGdldE9yaWdpbmFsU3RhY2tGcmFtZShlLG4sdCl9KSkpfW4uZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcz1nZXRPcmlnaW5hbFN0YWNrRnJhbWVzO2Z1bmN0aW9uIGdldEZyYW1lU291cmNlKGUpe3ZhciBuO3ZhciB0PVwiXCI7dHJ5e3ZhciByPW5ldyBVUkwoZS5maWxlKTtpZih0eXBlb2YgZ2xvYmFsVGhpcyE9PVwidW5kZWZpbmVkXCImJigobj1nbG9iYWxUaGlzLmxvY2F0aW9uKT09PW51bGx8fG49PT12b2lkIDA/dm9pZCAwOm4ub3JpZ2luKSE9PXIub3JpZ2luKXtpZihyLm9yaWdpbj09PVwibnVsbFwiKXt0Kz1yLnByb3RvY29sfWVsc2V7dCs9ci5vcmlnaW59fXQrPXIucGF0aG5hbWU7dCs9XCIgXCJ9Y2F0Y2gobil7dCs9KGUuZmlsZXx8XCIodW5rbm93bilcIikrXCIgXCJ9aWYoZS5saW5lTnVtYmVyIT1udWxsKXtpZihlLmNvbHVtbiE9bnVsbCl7dCs9XCIoXCIuY29uY2F0KGUubGluZU51bWJlcixcIjpcIikuY29uY2F0KGUuY29sdW1uLFwiKSBcIil9ZWxzZXt0Kz1cIihcIi5jb25jYXQoZS5saW5lTnVtYmVyLFwiKSBcIil9fXJldHVybiB0LnNsaWNlKDAsLTEpfW4uZ2V0RnJhbWVTb3VyY2U9Z2V0RnJhbWVTb3VyY2V9LDE2OTpmdW5jdGlvbihlLG4sdCl7dmFyIHI9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgYT10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIG89dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpcihuLGUsdCk7YShuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLnVzZU9uQ2xpY2tPdXRzaWRlPXZvaWQgMDt2YXIgaT1vKHQoNTIyKSk7ZnVuY3Rpb24gdXNlT25DbGlja091dHNpZGUoZSxuKXtpLnVzZUVmZmVjdCgoZnVuY3Rpb24oKXtpZihlPT1udWxsfHxuPT1udWxsKXtyZXR1cm59dmFyIGxpc3RlbmVyPWZ1bmN0aW9uKHQpe2lmKCFlfHxlLmNvbnRhaW5zKHQudGFyZ2V0KSl7cmV0dXJufW4odCl9O3ZhciB0PWUuZ2V0Um9vdE5vZGUoKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixsaXN0ZW5lcik7dC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGxpc3RlbmVyKTtyZXR1cm4gZnVuY3Rpb24oKXt0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIixsaXN0ZW5lcik7dC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLGxpc3RlbmVyKX19KSxbbixlXSl9bi51c2VPbkNsaWNrT3V0c2lkZT11c2VPbkNsaWNrT3V0c2lkZX0sODY1OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBhPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlyKG4sZSx0KTthKG4sZSk7cmV0dXJuIG59O24uX19lc01vZHVsZT10cnVlO24uQ2xvc2VJY29uPXZvaWQgMDt2YXIgaT1vKHQoNTIyKSk7dmFyIENsb3NlSWNvbj1mdW5jdGlvbigpe3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIix7d2lkdGg6XCIyNFwiLGhlaWdodDpcIjI0XCIsdmlld0JveDpcIjAgMCAyNCAyNFwiLGZpbGw6XCJub25lXCIseG1sbnM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifSxpLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse2Q6XCJNMTggNkw2IDE4XCIsc3Ryb2tlOlwiY3VycmVudENvbG9yXCIsc3Ryb2tlV2lkdGg6XCIyXCIsc3Ryb2tlTGluZWNhcDpcInJvdW5kXCIsc3Ryb2tlTGluZWpvaW46XCJyb3VuZFwifSksaS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtkOlwiTTYgNkwxOCAxOFwiLHN0cm9rZTpcImN1cnJlbnRDb2xvclwiLHN0cm9rZVdpZHRoOlwiMlwiLHN0cm9rZUxpbmVjYXA6XCJyb3VuZFwiLHN0cm9rZUxpbmVqb2luOlwicm91bmRcIn0pKX07bi5DbG9zZUljb249Q2xvc2VJY29ufSw4ODQ6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O24uX19lc01vZHVsZT10cnVlO24uQmFzZT12b2lkIDA7dmFyIGw9aSh0KDUyMikpO3ZhciBzPXQoOTEwKTtmdW5jdGlvbiBCYXNlKCl7cmV0dXJuIGwuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsbnVsbCwoMCxzLm5vb3ApKHV8fCh1PXIoW1wiXFxuICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogNHB4O1xcbiAgICAgICAgICAtLXNpemUtZ2FwOiA4cHg7XFxuICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxNnB4O1xcbiAgICAgICAgICAtLXNpemUtZ2FwLXRyaXBsZTogMjRweDtcXG4gICAgICAgICAgLS1zaXplLWdhcC1xdWFkOiAzMnB4O1xcblxcbiAgICAgICAgICAtLXNpemUtZm9udC1zbWFsbDogMTRweDtcXG4gICAgICAgICAgLS1zaXplLWZvbnQ6IDE2cHg7XFxuICAgICAgICAgIC0tc2l6ZS1mb250LWJpZzogMjBweDtcXG4gICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAyNHB4O1xcblxcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgLS1jb2xvci1hY2NlbnRzLTI6ICMyMjIyMjI7XFxuICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcywgJ0xpYmVyYXRpb24gTW9ubycsXFxuICAgICAgICAgICAgTWVubG8sIENvdXJpZXIsIG1vbm9zcGFjZTtcXG5cXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1mZzogI2NjY2NjYztcXG5cXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1ibHVlOiAjMDBhYWZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktbWFnZW50YTogI2FhODhmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC13aGl0ZTogI2ZmZmZmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWN5YW46ICNiYmVjZmY7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1yZWQ6ICNmZjg4ODg7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLm1vbm8ge1xcbiAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaDEsXFxuICAgICAgICBoMixcXG4gICAgICAgIGgzLFxcbiAgICAgICAgaDQsXFxuICAgICAgICBoNSxcXG4gICAgICAgIGg2IHtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaDEge1xcbiAgICAgICAgICBmb250LXNpemU6IDQwcHg7XFxuICAgICAgICB9XFxuICAgICAgICBoMiB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGgzIHtcXG4gICAgICAgICAgZm9udC1zaXplOiAyOHB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaDQge1xcbiAgICAgICAgICBmb250LXNpemU6IDI0cHg7XFxuICAgICAgICB9XFxuICAgICAgICBoNSB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGg2IHtcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgfVxcbiAgICAgIFwiXSxbXCJcXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiA0cHg7XFxuICAgICAgICAgIC0tc2l6ZS1nYXA6IDhweDtcXG4gICAgICAgICAgLS1zaXplLWdhcC1kb3VibGU6IDE2cHg7XFxuICAgICAgICAgIC0tc2l6ZS1nYXAtdHJpcGxlOiAyNHB4O1xcbiAgICAgICAgICAtLXNpemUtZ2FwLXF1YWQ6IDMycHg7XFxuXFxuICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAxNHB4O1xcbiAgICAgICAgICAtLXNpemUtZm9udDogMTZweDtcXG4gICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAyMHB4O1xcbiAgICAgICAgICAtLXNpemUtZm9udC1iaWdnZXI6IDI0cHg7XFxuXFxuICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgLS1jb2xvci1hY2NlbnRzLTM6ICM0MDQwNDA7XFxuXFxuICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLCAnTGliZXJhdGlvbiBNb25vJyxcXG4gICAgICAgICAgICBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktc2VsZWN0aW9uOiByZ2JhKDk1LCAxMjYsIDE1MSwgMC40OCk7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktd2hpdGU6ICM3Nzc3Nzc7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1jeWFuOiAjODhkZGZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktcmVkOiAjZmY1NTU1O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrOiAjNzc3Nzc3O1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ncmVlbjogI2I2ZjI5MjtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC15ZWxsb3c6ICNmZmQ5NjY7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAubW9ubyB7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoMSxcXG4gICAgICAgIGgyLFxcbiAgICAgICAgaDMsXFxuICAgICAgICBoNCxcXG4gICAgICAgIGg1LFxcbiAgICAgICAgaDYge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBoMSB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogNDBweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGgyIHtcXG4gICAgICAgICAgZm9udC1zaXplOiAzMnB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaDMge1xcbiAgICAgICAgICBmb250LXNpemU6IDI4cHg7XFxuICAgICAgICB9XFxuICAgICAgICBoNCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgICAgIH1cXG4gICAgICAgIGg1IHtcXG4gICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICAgICAgfVxcbiAgICAgICAgaDYge1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICB9XFxuICAgICAgXCJdKSkpKX1uLkJhc2U9QmFzZTt2YXIgdX0sNDY0OmZ1bmN0aW9uKGUsbix0KXt2YXIgcj10aGlzJiZ0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0fHxmdW5jdGlvbihlLG4pe2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJyYXdcIix7dmFsdWU6bn0pfWVsc2V7ZS5yYXc9bn1yZXR1cm4gZX07dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O3ZhciBhPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KTtpZighYXx8KFwiZ2V0XCJpbiBhPyFuLl9fZXNNb2R1bGU6YS53cml0YWJsZXx8YS5jb25maWd1cmFibGUpKXthPXtlbnVtZXJhYmxlOnRydWUsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG5bdF19fX1PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLGEpfTpmdW5jdGlvbihlLG4sdCxyKXtpZihyPT09dW5kZWZpbmVkKXI9dDtlW3JdPW5bdF19KTt2YXIgbz10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTp0cnVlLHZhbHVlOm59KX06ZnVuY3Rpb24oZSxuKXtlW1wiZGVmYXVsdFwiXT1ufSk7dmFyIGk9dGhpcyYmdGhpcy5fX2ltcG9ydFN0YXJ8fGZ1bmN0aW9uKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKWlmKHQhPT1cImRlZmF1bHRcIiYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkpYShuLGUsdCk7byhuLGUpO3JldHVybiBufTtuLl9fZXNNb2R1bGU9dHJ1ZTtuLkNvbXBvbmVudFN0eWxlcz12b2lkIDA7dmFyIGw9aSh0KDUyMikpO3ZhciBzPXQoMzk5KTt2YXIgdT10KDY1MSk7dmFyIGM9dCg1NDMpO3ZhciBmPXQoOTkzKTt2YXIgZD10KDQ4OCk7dmFyIHY9dCgxMjApO3ZhciBwPXQoOTM2KTt2YXIgbT10KDM1NSk7dmFyIGI9dCg0ODQpO3ZhciBnPXQoOTEwKTtmdW5jdGlvbiBDb21wb25lbnRTdHlsZXMoKXtyZXR1cm4gbC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIixudWxsLCgwLGcubm9vcCkoaHx8KGg9cihbXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgIFwiXSxbXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFxcbiAgICAgICAgXCIsXCJcXG4gICAgICAgIFwiLFwiXFxuICAgICAgICBcIixcIlxcbiAgICAgIFwiXSkpLGYuc3R5bGVzLHYuc3R5bGVzLHUuc3R5bGVzLGMuc3R5bGVzLHMuc3R5bGVzLGQuc3R5bGVzLHAuc3R5bGVzLG0uc3R5bGVzLGIuc3R5bGVzKSl9bi5Db21wb25lbnRTdHlsZXM9Q29tcG9uZW50U3R5bGVzO3ZhciBofSw0OTU6ZnVuY3Rpb24oZSxuLHQpe3ZhciByPXRoaXMmJnRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3R8fGZ1bmN0aW9uKGUsbil7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpufSl9ZWxzZXtlLnJhdz1ufXJldHVybiBlfTt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSxuLHQscil7aWYocj09PXVuZGVmaW5lZClyPXQ7dmFyIGE9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpO2lmKCFhfHwoXCJnZXRcImluIGE/IW4uX19lc01vZHVsZTphLndyaXRhYmxlfHxhLmNvbmZpZ3VyYWJsZSkpe2E9e2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gblt0XX19fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIsYSl9OmZ1bmN0aW9uKGUsbix0LHIpe2lmKHI9PT11bmRlZmluZWQpcj10O2Vbcl09blt0XX0pO3ZhciBvPXRoaXMmJnRoaXMuX19zZXRNb2R1bGVEZWZhdWx0fHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOnRydWUsdmFsdWU6bn0pfTpmdW5jdGlvbihlLG4pe2VbXCJkZWZhdWx0XCJdPW59KTt2YXIgaT10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPXt9O2lmKGUhPW51bGwpZm9yKHZhciB0IGluIGUpaWYodCE9PVwiZGVmYXVsdFwiJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KSlhKG4sZSx0KTtvKG4sZSk7cmV0dXJuIG59O24uX19lc01vZHVsZT10cnVlO24uQ3NzUmVzZXQ9dm9pZCAwO3ZhciBsPWkodCg1MjIpKTt2YXIgcz10KDkxMCk7ZnVuY3Rpb24gQ3NzUmVzZXQoKXtyZXR1cm4gbC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIixudWxsLCgwLHMubm9vcCkodXx8KHU9cihbXCJcXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgYWxsOiBpbml0aWFsO1xcblxcbiAgICAgICAgICAvKiB0aGUgZGlyZWN0aW9uIHByb3BlcnR5IGlzIG5vdCByZXNldCBieSAnYWxsJyAqL1xcbiAgICAgICAgICBkaXJlY3Rpb246IGx0cjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8qIVxcbiAgICAgICAgICogQm9vdHN0cmFwIFJlYm9vdCB2NC40LjEgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXFxuICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFKVxcbiAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgKi9cXG4gICAgICAgICosXFxuICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICB9XFxuXFxuICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgYXNpZGUsXFxuICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgZmlndXJlLFxcbiAgICAgICAgZm9vdGVyLFxcbiAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgbWFpbixcXG4gICAgICAgIG5hdixcXG4gICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICdBcHBsZSBDb2xvciBFbW9qaScsICdTZWdvZSBVSSBFbW9qaScsICdTZWdvZSBVSSBTeW1ib2wnLFxcbiAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICBmb250LXdlaWdodDogNDAwO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFt0YWJpbmRleD0nLTEnXTpmb2N1czpub3QoOmZvY3VzLXZpc2libGUpIHtcXG4gICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaHIge1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGgxLFxcbiAgICAgICAgaDIsXFxuICAgICAgICBoMyxcXG4gICAgICAgIGg0LFxcbiAgICAgICAgaDUsXFxuICAgICAgICBoNiB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHAge1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWJiclt0aXRsZV0sXFxuICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgYm9yZGVyLWJvdHRvbTogMDtcXG4gICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgICBmb250LXN0eWxlOiBub3JtYWw7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2wsXFxuICAgICAgICB1bCxcXG4gICAgICAgIGRsIHtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG9sIG9sLFxcbiAgICAgICAgdWwgdWwsXFxuICAgICAgICBvbCB1bCxcXG4gICAgICAgIHVsIG9sIHtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGR0IHtcXG4gICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRkIHtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICBtYXJnaW46IDAgMCAxNnB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYixcXG4gICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogODAlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3ViLFxcbiAgICAgICAgc3VwIHtcXG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDA7XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN1YiB7XFxuICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN1cCB7XFxuICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYSB7XFxuICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgIGNvbG9yOiAjMDA1NmIzO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGE6bm90KFtocmVmXSkge1xcbiAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcmUsXFxuICAgICAgICBjb2RlLFxcbiAgICAgICAga2JkLFxcbiAgICAgICAgc2FtcCB7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsXFxuICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcmUge1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZpZ3VyZSB7XFxuICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbWcge1xcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdmcge1xcbiAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGFibGUge1xcbiAgICAgICAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgIHBhZGRpbmctdG9wOiAxMnB4O1xcbiAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMTJweDtcXG4gICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGgge1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGFiZWwge1xcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICBvdXRsaW5lOiA1cHggYXV0byAtd2Via2l0LWZvY3VzLXJpbmctY29sb3I7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpbnB1dCxcXG4gICAgICAgIGJ1dHRvbixcXG4gICAgICAgIHNlbGVjdCxcXG4gICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICBmb250LXNpemU6IGluaGVyaXQ7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbixcXG4gICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgd29yZC13cmFwOiBub3JtYWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b24sXFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ10sXFxuICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgW3R5cGU9J2J1dHRvbiddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlucHV0W3R5cGU9J3JhZGlvJ10sXFxuICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J3RpbWUnXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBsaXN0Ym94O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGZpZWxkc2V0IHtcXG4gICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGxlZ2VuZCB7XFxuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcHJvZ3Jlc3Mge1xcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbdHlwZT0nc2VhcmNoJ10ge1xcbiAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgIGZvbnQ6IGluaGVyaXQ7XFxuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb3V0cHV0IHtcXG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3VtbWFyeSB7XFxuICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGVtcGxhdGUge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgW2hpZGRlbl0ge1xcbiAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICB9XFxuICAgICAgXCJdLFtcIlxcbiAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICBhbGw6IGluaXRpYWw7XFxuXFxuICAgICAgICAgIC8qIHRoZSBkaXJlY3Rpb24gcHJvcGVydHkgaXMgbm90IHJlc2V0IGJ5ICdhbGwnICovXFxuICAgICAgICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLyohXFxuICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAqIENvcHlyaWdodCAyMDExLTIwMTkgVGhlIEJvb3RzdHJhcCBBdXRob3JzXFxuICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgKiBGb3JrZWQgZnJvbSBOb3JtYWxpemUuY3NzLCBsaWNlbnNlZCBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZClcXG4gICAgICAgICAqL1xcbiAgICAgICAgKixcXG4gICAgICAgICo6OmJlZm9yZSxcXG4gICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjE1O1xcbiAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGFydGljbGUsXFxuICAgICAgICBhc2lkZSxcXG4gICAgICAgIGZpZ2NhcHRpb24sXFxuICAgICAgICBmaWd1cmUsXFxuICAgICAgICBmb290ZXIsXFxuICAgICAgICBoZWFkZXIsXFxuICAgICAgICBoZ3JvdXAsXFxuICAgICAgICBtYWluLFxcbiAgICAgICAgbmF2LFxcbiAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsICdTZWdvZSBVSScsIFJvYm90byxcXG4gICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgJ05vdG8gQ29sb3IgRW1vamknO1xcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICBvdXRsaW5lOiAwICFpbXBvcnRhbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBociB7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGNvbnRlbnQtYm94O1xcbiAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaDEsXFxuICAgICAgICBoMixcXG4gICAgICAgIGgzLFxcbiAgICAgICAgaDQsXFxuICAgICAgICBoNSxcXG4gICAgICAgIGg2IHtcXG4gICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcCB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgIGFiYnJbZGF0YS1vcmlnaW5hbC10aXRsZV0ge1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYWRkcmVzcyB7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvbCxcXG4gICAgICAgIHVsLFxcbiAgICAgICAgZGwge1xcbiAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgb2wgb2wsXFxuICAgICAgICB1bCB1bCxcXG4gICAgICAgIG9sIHVsLFxcbiAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZHQge1xcbiAgICAgICAgICBmb250LXdlaWdodDogNzAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGQge1xcbiAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYmxvY2txdW90ZSB7XFxuICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBiLFxcbiAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdWIsXFxuICAgICAgICBzdXAge1xcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3ViIHtcXG4gICAgICAgICAgYm90dG9tOiAtMC4yNWVtO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3VwIHtcXG4gICAgICAgICAgdG9wOiAtMC41ZW07XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhIHtcXG4gICAgICAgICAgY29sb3I6ICMwMDdiZmY7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBhOm5vdChbaHJlZl0pOmhvdmVyIHtcXG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByZSxcXG4gICAgICAgIGNvZGUsXFxuICAgICAgICBrYmQsXFxuICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAnTGliZXJhdGlvbiBNb25vJywgJ0NvdXJpZXIgTmV3JywgbW9ub3NwYWNlO1xcbiAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByZSB7XFxuICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgbWFyZ2luOiAwIDAgMTZweDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGltZyB7XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHN2ZyB7XFxuICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgcGFkZGluZy10b3A6IDEycHg7XFxuICAgICAgICAgIHBhZGRpbmctYm90dG9tOiAxMnB4O1xcbiAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgY2FwdGlvbi1zaWRlOiBib3R0b207XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aCB7XFxuICAgICAgICAgIHRleHQtYWxpZ246IGluaGVyaXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uIHtcXG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbjpmb2N1cyB7XFxuICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlucHV0LFxcbiAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgc2VsZWN0LFxcbiAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b24sXFxuICAgICAgICBpbnB1dCB7XFxuICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbixcXG4gICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgIFt0eXBlPSdyZXNldCddLFxcbiAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICB9XFxuXFxuICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICBbdHlwZT0ncmVzZXQnXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgIFt0eXBlPSdyZXNldCddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgYm9yZGVyLXN0eWxlOiBub25lO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J2NoZWNrYm94J10ge1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZXRpbWUtbG9jYWwnXSxcXG4gICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICByZXNpemU6IHZlcnRpY2FsO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICBtaW4td2lkdGg6IDA7XFxuICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgYm9yZGVyOiAwO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xcbiAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFt0eXBlPSdzZWFyY2gnXSB7XFxuICAgICAgICAgIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgZGlzcGxheTogbGlzdC1pdGVtO1xcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZW1wbGF0ZSB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBbaGlkZGVuXSB7XFxuICAgICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgIH1cXG4gICAgICBcIl0pKSkpfW4uQ3NzUmVzZXQ9Q3NzUmVzZXQ7dmFyIHV9LDk5NzpmdW5jdGlvbihlKXtlLmV4cG9ydHM9cmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9hbnNlclwiKX0sMjkyOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy5lc2NhcGVcIil9LDcwOTpmdW5jdGlvbihlKXtlLmV4cG9ydHM9cmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9wbGF0Zm9ybVwiKX0sOTc0OmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1yZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3N0YWNrdHJhY2UtcGFyc2VyXCIpfSw1MTg6ZnVuY3Rpb24oZSl7ZS5leHBvcnRzPXJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKX0sNTIyOmZ1bmN0aW9uKGUpe2UuZXhwb3J0cz1yZXF1aXJlKFwicmVhY3RcIil9LDI1NTpmdW5jdGlvbihlKXtlLmV4cG9ydHM9cmVxdWlyZShcInJlYWN0LWRvbVwiKX19O3ZhciBuPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIHI9blt0XTtpZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gci5leHBvcnRzfXZhciBhPW5bdF09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2VbdF0uY2FsbChhLmV4cG9ydHMsYSxhLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIG5bdF19cmV0dXJuIGEuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXygyMDQpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\n"));

/***/ }),

/***/ "./components/Navbar.jsx":
/*!*******************************!*\
  !*** ./components/Navbar.jsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/client */ \"./node_modules/next/client.js\");\n/* harmony import */ var next_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var framer_motion__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! framer-motion */ \"./node_modules/framer-motion/dist/es/render/dom/motion.mjs\");\n/* harmony import */ var _styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles */ \"./styles/index.js\");\n/* harmony import */ var _utils_motion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/motion */ \"./utils/motion.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst Navbar = ()=>{\n    _s();\n    const [connected, setConnected] = client.useState(false);\n    async function connectMetaMask() {\n        try {\n            const provider = await detectEthereumProvider();\n            if (provider) {\n                // Prompt the user to connect their MetaMask wallet\n                await provider.request({\n                    method: \"eth_requestAccounts\"\n                });\n                console.log(\"Connected to MetaMask!\");\n                setConnected(true);\n            } else {\n                console.log(\"Please install MetaMask to connect your wallet.\");\n            }\n        } catch (err) {\n            console.error(err);\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(framer_motion__WEBPACK_IMPORTED_MODULE_4__.motion.nav, {\n        variants: _utils_motion__WEBPACK_IMPORTED_MODULE_3__.navVariants,\n        initial: \"hidden\",\n        whileInView: \"show\",\n        className: \"\".concat(_styles__WEBPACK_IMPORTED_MODULE_2__[\"default\"].xPaddings, \" py-8 relative\"),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute w-[50%] inset-0 gradient-01\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n                lineNumber: 36,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"\".concat(_styles__WEBPACK_IMPORTED_MODULE_2__[\"default\"].innerWidth, \" mx-auto flex justify-between gap-8\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                        src: \"/search.svg\",\n                        alt: \"search\",\n                        className: \"w-[24px] h-[24px] object-contain\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n                        lineNumber: 40,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"font-extrabold text-[24px] leading-[30px] text-white\",\n                        children: \"ALTEYE\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n                        lineNumber: 45,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: connectMetaMask,\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            src: \"/metamask.svg\",\n                            alt: \"metamask\",\n                            className: \"w-[24px] h-[24px] object-contain \"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n                            lineNumber: 48,\n                            columnNumber: 43\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n                        lineNumber: 48,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n                lineNumber: 37,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\SHASHWAT\\\\Desktop\\\\HC\\\\components\\\\Navbar.jsx\",\n        lineNumber: 30,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Navbar, \"LY4Aeu5UcHHYjglHE9bCC5TH818=\");\n_c = Navbar;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Navbar);\nvar _c;\n$RefreshReg$(_c, \"Navbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL05hdmJhci5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUV3QztBQUNEO0FBQ1I7QUFDZTtBQUU5QyxNQUFNSSxTQUFTLElBQU07O0lBRW5CLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHQyxPQUFPQyxRQUFRLENBQUMsS0FBSztJQUV2RCxlQUFlQyxrQkFBa0I7UUFDL0IsSUFBSTtZQUNGLE1BQU1DLFdBQVcsTUFBTUM7WUFFdkIsSUFBSUQsVUFBVTtnQkFDWixtREFBbUQ7Z0JBQ25ELE1BQU1BLFNBQVNFLE9BQU8sQ0FBQztvQkFBRUMsUUFBUTtnQkFBc0I7Z0JBQ3ZEQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1pULGFBQWEsSUFBSTtZQUNuQixPQUFPO2dCQUNMUSxRQUFRQyxHQUFHLENBQUM7WUFDZCxDQUFDO1FBQ0gsRUFBRSxPQUFPQyxLQUFLO1lBQ1pGLFFBQVFHLEtBQUssQ0FBQ0Q7UUFDaEI7SUFDRjtJQUVBLHFCQUNFLDhEQUFDZixxREFBVTtRQUNUa0IsVUFBVWhCLHNEQUFXQTtRQUNyQmlCLFNBQVE7UUFDUkMsYUFBWTtRQUNaQyxXQUFXLEdBQW9CLE9BQWpCcEIseURBQWdCLEVBQUM7OzBCQUUvQiw4REFBQ3NCO2dCQUFJRixXQUFVOzs7Ozs7MEJBQ2YsOERBQUNFO2dCQUNDRixXQUFXLEdBQXFCLE9BQWxCcEIsMERBQWlCLEVBQUM7O2tDQUVoQyw4REFBQ3dCO3dCQUNDQyxLQUFJO3dCQUNKQyxLQUFJO3dCQUNKTixXQUFVOzs7Ozs7a0NBRVosOERBQUNPO3dCQUFHUCxXQUFVO2tDQUF1RDs7Ozs7O2tDQUdyRSw4REFBQ1E7d0JBQU9DLFNBQVN0QjtrQ0FBaUIsNEVBQUNpQjs0QkFDakNDLEtBQUk7NEJBQ0pDLEtBQUk7NEJBQ0pOLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS3BCO0dBaERNbEI7S0FBQUE7QUFrRE4sK0RBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9OYXZiYXIuanN4PzNhYWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XHJcblxyXG5pbXBvcnQgeyB1c2VDbGllbnQgfSBmcm9tIFwibmV4dC9jbGllbnRcIjtcclxuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIjtcclxuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi4vc3R5bGVzXCI7XHJcbmltcG9ydCB7IG5hdlZhcmlhbnRzIH0gZnJvbSBcIi4uL3V0aWxzL21vdGlvblwiO1xyXG5cclxuY29uc3QgTmF2YmFyID0gKCkgPT4ge1xyXG5cclxuICBjb25zdCBbY29ubmVjdGVkLCBzZXRDb25uZWN0ZWRdID0gY2xpZW50LnVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gY29ubmVjdE1ldGFNYXNrKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBkZXRlY3RFdGhlcmV1bVByb3ZpZGVyKCk7XHJcblxyXG4gICAgICBpZiAocHJvdmlkZXIpIHtcclxuICAgICAgICAvLyBQcm9tcHQgdGhlIHVzZXIgdG8gY29ubmVjdCB0aGVpciBNZXRhTWFzayB3YWxsZXRcclxuICAgICAgICBhd2FpdCBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycgfSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCB0byBNZXRhTWFzayEnKTtcclxuICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1BsZWFzZSBpbnN0YWxsIE1ldGFNYXNrIHRvIGNvbm5lY3QgeW91ciB3YWxsZXQuJyk7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPG1vdGlvbi5uYXZcclxuICAgICAgdmFyaWFudHM9e25hdlZhcmlhbnRzfVxyXG4gICAgICBpbml0aWFsPVwiaGlkZGVuXCJcclxuICAgICAgd2hpbGVJblZpZXc9XCJzaG93XCJcclxuICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMueFBhZGRpbmdzfSBweS04IHJlbGF0aXZlYH1cclxuICAgID5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB3LVs1MCVdIGluc2V0LTAgZ3JhZGllbnQtMDFcIiAvPlxyXG4gICAgICA8ZGl2XHJcbiAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMuaW5uZXJXaWR0aH0gbXgtYXV0byBmbGV4IGp1c3RpZnktYmV0d2VlbiBnYXAtOGB9XHJcbiAgICAgID5cclxuICAgICAgICA8aW1nXHJcbiAgICAgICAgICBzcmM9XCIvc2VhcmNoLnN2Z1wiXHJcbiAgICAgICAgICBhbHQ9XCJzZWFyY2hcIlxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwidy1bMjRweF0gaC1bMjRweF0gb2JqZWN0LWNvbnRhaW5cIlxyXG4gICAgICAgIC8+XHJcbiAgICAgICAgPGgyIGNsYXNzTmFtZT1cImZvbnQtZXh0cmFib2xkIHRleHQtWzI0cHhdIGxlYWRpbmctWzMwcHhdIHRleHQtd2hpdGVcIj5cclxuICAgICAgICAgIEFMVEVZRVxyXG4gICAgICAgIDwvaDI+XHJcbiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtjb25uZWN0TWV0YU1hc2t9PjxpbWdcclxuICAgICAgICAgIHNyYz1cIi9tZXRhbWFzay5zdmdcIlxyXG4gICAgICAgICAgYWx0PVwibWV0YW1hc2tcIlxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwidy1bMjRweF0gaC1bMjRweF0gb2JqZWN0LWNvbnRhaW4gXCJcclxuICAgICAgICAvPjwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvbW90aW9uLm5hdj5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTmF2YmFyO1xyXG4iXSwibmFtZXMiOlsidXNlQ2xpZW50IiwibW90aW9uIiwic3R5bGVzIiwibmF2VmFyaWFudHMiLCJOYXZiYXIiLCJjb25uZWN0ZWQiLCJzZXRDb25uZWN0ZWQiLCJjbGllbnQiLCJ1c2VTdGF0ZSIsImNvbm5lY3RNZXRhTWFzayIsInByb3ZpZGVyIiwiZGV0ZWN0RXRoZXJldW1Qcm92aWRlciIsInJlcXVlc3QiLCJtZXRob2QiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwiZXJyb3IiLCJuYXYiLCJ2YXJpYW50cyIsImluaXRpYWwiLCJ3aGlsZUluVmlldyIsImNsYXNzTmFtZSIsInhQYWRkaW5ncyIsImRpdiIsImlubmVyV2lkdGgiLCJpbWciLCJzcmMiLCJhbHQiLCJoMiIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/Navbar.jsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/add-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/add-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addBasePath = addBasePath;\nvar _addPathPrefix = __webpack_require__(/*! ../shared/lib/router/utils/add-path-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction addBasePath(path, required) {\n    if (false) {}\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash((0, _addPathPrefix).addPathPrefix(path, basePath));\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHVIQUE0QztBQUN6RSxJQUFJQywwQkFBMEJELG1CQUFPQSxDQUFDLCtGQUE0QjtBQUNsRSxNQUFNRSxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNMLFlBQVlRLElBQUksRUFBRUMsUUFBUSxFQUFFO0lBQ2pDLElBQUlKLEtBQTBDLEVBQUUsRUFJL0M7SUFDRCxPQUFPLENBQUMsR0FBR0YsdUJBQXVCLEVBQUVRLDBCQUEwQixDQUFDLENBQUMsR0FBR1YsY0FBYyxFQUFFVyxhQUFhLENBQUNKLE1BQU1KO0FBQzNHO0FBRUEsSUFBSSxDQUFDLE9BQU9OLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPbUIsTUFBTSxDQUFDakIsUUFBUWUsT0FBTyxFQUFFZjtJQUMvQmtCLE9BQU9sQixPQUFPLEdBQUdBLFFBQVFlLE9BQU87QUFDbEMsQ0FBQyxDQUVELHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtYmFzZS1wYXRoLmpzPzYxMzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZEJhc2VQYXRoID0gYWRkQmFzZVBhdGg7XG52YXIgX2FkZFBhdGhQcmVmaXggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4XCIpO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gYWRkQmFzZVBhdGgocGF0aCwgcmVxdWlyZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIKSB7XG4gICAgICAgIGlmICghcmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKCgwLCBfYWRkUGF0aFByZWZpeCkuYWRkUGF0aFByZWZpeChwYXRoLCBiYXNlUGF0aCkpO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtYmFzZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZEJhc2VQYXRoIiwiX2FkZFBhdGhQcmVmaXgiLCJyZXF1aXJlIiwiX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2giLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsInJlcXVpcmVkIiwiX19ORVhUX01BTlVBTF9DTElFTlRfQkFTRV9QQVRIIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJhZGRQYXRoUHJlZml4IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/add-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/add-locale.js":
/*!*****************************************************!*\
  !*** ./node_modules/next/dist/client/add-locale.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addLocale = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst addLocale = function(path) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    if (false) {}\n    return path;\n};\nexports.addLocale = addLocale;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsSUFBSUcsMEJBQTBCQyxtQkFBT0EsQ0FBQywrRkFBNEI7QUFDbEUsTUFBTUYsWUFBWSxTQUFDRyxNQUFnQjtxQ0FBUEM7UUFBQUE7O0lBQ3hCLElBQUlDLEtBQStCLEVBQUUsRUFFcEM7SUFDRCxPQUFPRjtBQUNYO0FBQ0FMLGlCQUFpQixHQUFHRTtBQUVwQixJQUFJLENBQUMsT0FBT0YsUUFBUVcsT0FBTyxLQUFLLGNBQWUsT0FBT1gsUUFBUVcsT0FBTyxLQUFLLFlBQVlYLFFBQVFXLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1gsUUFBUVcsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2QsT0FBT0MsY0FBYyxDQUFDQyxRQUFRVyxPQUFPLEVBQUUsY0FBYztRQUFFVixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2UsTUFBTSxDQUFDYixRQUFRVyxPQUFPLEVBQUVYO0lBQy9CYyxPQUFPZCxPQUFPLEdBQUdBLFFBQVFXLE9BQU87QUFDbEMsQ0FBQyxDQUVELHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hZGQtbG9jYWxlLmpzP2UyZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZExvY2FsZSA9IHZvaWQgMDtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaFwiKTtcbmNvbnN0IGFkZExvY2FsZSA9IChwYXRoLCAuLi5hcmdzKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIHJldHVybiAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUnKS5hZGRMb2NhbGUocGF0aCwgLi4uYXJncykpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn07XG5leHBvcnRzLmFkZExvY2FsZSA9IGFkZExvY2FsZTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRMb2NhbGUiLCJfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCIsInJlcXVpcmUiLCJwYXRoIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/add-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/detect-domain-locale.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/client/detect-domain-locale.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.detectDomainLocale = void 0;\nconst detectDomainLocale = function() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    if (false) {}\n};\nexports.detectDomainLocale = detectDomainLocale;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=detect-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBRyxLQUFLO0FBQ2xDLE1BQU1FLHFCQUFxQixXQUFXO3FDQUFQQztRQUFBQTs7SUFDM0IsSUFBSUMsS0FBK0IsRUFBRSxFQUVwQztBQUNMO0FBQ0FKLDBCQUEwQixHQUFHRTtBQUU3QixJQUFJLENBQUMsT0FBT0YsUUFBUVEsT0FBTyxLQUFLLGNBQWUsT0FBT1IsUUFBUVEsT0FBTyxLQUFLLFlBQVlSLFFBQVFRLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT1IsUUFBUVEsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS1gsT0FBT0MsY0FBYyxDQUFDQyxRQUFRUSxPQUFPLEVBQUUsY0FBYztRQUFFUCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT1ksTUFBTSxDQUFDVixRQUFRUSxPQUFPLEVBQUVSO0lBQy9CVyxPQUFPWCxPQUFPLEdBQUdBLFFBQVFRLE9BQU87QUFDbEMsQ0FBQyxDQUVELGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZS5qcz8wM2I1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZXRlY3REb21haW5Mb2NhbGUgPSB2b2lkIDA7XG5jb25zdCBkZXRlY3REb21haW5Mb2NhbGUgPSAoLi4uYXJncyk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJykuZGV0ZWN0RG9tYWluTG9jYWxlKC4uLmFyZ3MpO1xuICAgIH1cbn07XG5leHBvcnRzLmRldGVjdERvbWFpbkxvY2FsZSA9IGRldGVjdERvbWFpbkxvY2FsZTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0LWRvbWFpbi1sb2NhbGUuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiYXJncyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/detect-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/has-base-path.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/has-base-path.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.hasBasePath = hasBasePath;\nvar _pathHasPrefix = __webpack_require__(/*! ../shared/lib/router/utils/path-has-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nconst basePath =  false || \"\";\nfunction hasBasePath(path) {\n    return (0, _pathHasPrefix).pathHasPrefix(path, basePath);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=has-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oYXMtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG1CQUFtQixHQUFHRTtBQUN0QixJQUFJQyxpQkFBaUJDLG1CQUFPQSxDQUFDLHVIQUE0QztBQUN6RSxNQUFNQyxXQUFXQyxNQUFrQyxJQUFJO0FBQ3ZELFNBQVNKLFlBQVlPLElBQUksRUFBRTtJQUN2QixPQUFPLENBQUMsR0FBR04sY0FBYyxFQUFFTyxhQUFhLENBQUNELE1BQU1KO0FBQ25EO0FBRUEsSUFBSSxDQUFDLE9BQU9MLFFBQVFXLE9BQU8sS0FBSyxjQUFlLE9BQU9YLFFBQVFXLE9BQU8sS0FBSyxZQUFZWCxRQUFRVyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9YLFFBQVFXLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktkLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVcsT0FBTyxFQUFFLGNBQWM7UUFBRVYsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9lLE1BQU0sQ0FBQ2IsUUFBUVcsT0FBTyxFQUFFWDtJQUMvQmMsT0FBT2QsT0FBTyxHQUFHQSxRQUFRVyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGFzLWJhc2UtcGF0aC5qcz81YTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5oYXNCYXNlUGF0aCA9IGhhc0Jhc2VQYXRoO1xudmFyIF9wYXRoSGFzUHJlZml4ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeFwiKTtcbmNvbnN0IGJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbmZ1bmN0aW9uIGhhc0Jhc2VQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gKDAsIF9wYXRoSGFzUHJlZml4KS5wYXRoSGFzUHJlZml4KHBhdGgsIGJhc2VQYXRoKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYXNCYXNlUGF0aCIsIl9wYXRoSGFzUHJlZml4IiwicmVxdWlyZSIsImJhc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJwYXRoIiwicGF0aEhhc1ByZWZpeCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/has-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = initHeadManager;\nexports.isEqualNode = isEqualNode;\nexports.DOMAttributeNames = void 0;\nfunction initHeadManager() {\n    return {\n        mountedInstances: new Set(),\n        updateHead: (head)=>{\n            const tags = {};\n            head.forEach((h)=>{\n                if (// it won't be inlined. In this case revert to the original behavior\n                h.type === \"link\" && h.props[\"data-optimized-fonts\"]) {\n                    if (document.querySelector('style[data-href=\"'.concat(h.props[\"data-href\"], '\"]'))) {\n                        return;\n                    } else {\n                        h.props.href = h.props[\"data-href\"];\n                        h.props[\"data-href\"] = undefined;\n                    }\n                }\n                const components = tags[h.type] || [];\n                components.push(h);\n                tags[h.type] = components;\n            });\n            const titleComponent = tags.title ? tags.title[0] : null;\n            let title = \"\";\n            if (titleComponent) {\n                const { children  } = titleComponent.props;\n                title = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n            }\n            if (title !== document.title) document.title = title;\n            [\n                \"meta\",\n                \"base\",\n                \"link\",\n                \"style\",\n                \"script\"\n            ].forEach((type)=>{\n                updateElements(type, tags[type] || []);\n            });\n        }\n    };\n}\nconst DOMAttributeNames = {\n    acceptCharset: \"accept-charset\",\n    className: \"class\",\n    htmlFor: \"for\",\n    httpEquiv: \"http-equiv\",\n    noModule: \"noModule\"\n};\nexports.DOMAttributeNames = DOMAttributeNames;\nfunction reactElementToDOM(param) {\n    let { type , props  } = param;\n    const el = document.createElement(type);\n    for(const p in props){\n        if (!props.hasOwnProperty(p)) continue;\n        if (p === \"children\" || p === \"dangerouslySetInnerHTML\") continue;\n        // we don't render undefined props to the DOM\n        if (props[p] === undefined) continue;\n        const attr = DOMAttributeNames[p] || p.toLowerCase();\n        if (type === \"script\" && (attr === \"async\" || attr === \"defer\" || attr === \"noModule\")) {\n            el[attr] = !!props[p];\n        } else {\n            el.setAttribute(attr, props[p]);\n        }\n    }\n    const { children , dangerouslySetInnerHTML  } = props;\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n    }\n    return el;\n}\nfunction isEqualNode(oldTag, newTag) {\n    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n        const nonce = newTag.getAttribute(\"nonce\");\n        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n        // be stripped if there is no content security policy response header that includes a nonce.\n        if (nonce && !oldTag.getAttribute(\"nonce\")) {\n            const cloneTag = newTag.cloneNode(true);\n            cloneTag.setAttribute(\"nonce\", \"\");\n            cloneTag.nonce = nonce;\n            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n        }\n    }\n    return oldTag.isEqualNode(newTag);\n}\nfunction updateElements(type, components) {\n    const headEl = document.getElementsByTagName(\"head\")[0];\n    const headCountEl = headEl.querySelector(\"meta[name=next-head-count]\");\n    if (true) {\n        if (!headCountEl) {\n            console.error(\"Warning: next-head-count is missing. https://nextjs.org/docs/messages/next-head-count-missing\");\n            return;\n        }\n    }\n    const headCount = Number(headCountEl.content);\n    const oldTags = [];\n    for(let i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = (j == null ? void 0 : j.previousElementSibling) || null){\n        var ref;\n        if ((j == null ? void 0 : (ref = j.tagName) == null ? void 0 : ref.toLowerCase()) === type) {\n            oldTags.push(j);\n        }\n    }\n    const newTags = components.map(reactElementToDOM).filter((newTag)=>{\n        for(let k = 0, len = oldTags.length; k < len; k++){\n            const oldTag = oldTags[k];\n            if (isEqualNode(oldTag, newTag)) {\n                oldTags.splice(k, 1);\n                return false;\n            }\n        }\n        return true;\n    });\n    oldTags.forEach((t)=>{\n        var ref;\n        return (ref = t.parentNode) == null ? void 0 : ref.removeChild(t);\n    });\n    newTags.forEach((t)=>headEl.insertBefore(t, headCountEl));\n    headCountEl.content = (headCount - oldTags.length + newTags.length).toString();\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oZWFkLW1hbmFnZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEJILG1CQUFtQixHQUFHSTtBQUN0QkoseUJBQXlCLEdBQUcsS0FBSztBQUNqQyxTQUFTRyxrQkFBa0I7SUFDdkIsT0FBTztRQUNIRyxrQkFBa0IsSUFBSUM7UUFDdEJDLFlBQVksQ0FBQ0MsT0FBTztZQUNoQixNQUFNQyxPQUFPLENBQUM7WUFDZEQsS0FBS0UsT0FBTyxDQUFDLENBQUNDLElBQUk7Z0JBQ2QsSUFDQSxvRUFBb0U7Z0JBQ3BFQSxFQUFFQyxJQUFJLEtBQUssVUFBVUQsRUFBRUUsS0FBSyxDQUFDLHVCQUF1QixFQUFFO29CQUNsRCxJQUFJQyxTQUFTQyxhQUFhLENBQUMsb0JBQXlDLE9BQXJCSixFQUFFRSxLQUFLLENBQUMsWUFBWSxFQUFDLFFBQU07d0JBQ3RFO29CQUNKLE9BQU87d0JBQ0hGLEVBQUVFLEtBQUssQ0FBQ0csSUFBSSxHQUFHTCxFQUFFRSxLQUFLLENBQUMsWUFBWTt3QkFDbkNGLEVBQUVFLEtBQUssQ0FBQyxZQUFZLEdBQUdJO29CQUMzQixDQUFDO2dCQUNMLENBQUM7Z0JBQ0QsTUFBTUMsYUFBYVQsSUFBSSxDQUFDRSxFQUFFQyxJQUFJLENBQUMsSUFBSSxFQUFFO2dCQUNyQ00sV0FBV0MsSUFBSSxDQUFDUjtnQkFDaEJGLElBQUksQ0FBQ0UsRUFBRUMsSUFBSSxDQUFDLEdBQUdNO1lBQ25CO1lBQ0EsTUFBTUUsaUJBQWlCWCxLQUFLWSxLQUFLLEdBQUdaLEtBQUtZLEtBQUssQ0FBQyxFQUFFLEdBQUcsSUFBSTtZQUN4RCxJQUFJQSxRQUFRO1lBQ1osSUFBSUQsZ0JBQWdCO2dCQUNoQixNQUFNLEVBQUVFLFNBQVEsRUFBRyxHQUFHRixlQUFlUCxLQUFLO2dCQUMxQ1EsUUFBUSxPQUFPQyxh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LENBQUMsT0FBTzlFLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQzZFLFVBQVUsS0FBSyxhQUFhO0lBQ3JLakYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2tGLE1BQU0sQ0FBQ2hGLFFBQVFFLE9BQU8sRUFBRUY7SUFDL0JpRixPQUFPakYsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGVhZC1tYW5hZ2VyLmpzP2NhNGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbml0SGVhZE1hbmFnZXI7XG5leHBvcnRzLmlzRXF1YWxOb2RlID0gaXNFcXVhbE5vZGU7XG5leHBvcnRzLkRPTUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdXBkYXRlSGVhZDogKGhlYWQpPT57XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICBoZWFkLmZvckVhY2goKGgpPT57XG4gICAgICAgICAgICAgICAgaWYgKC8vIElmIHRoZSBmb250IHRhZyBpcyBsb2FkZWQgb25seSBvbiBjbGllbnQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIGl0IHdvbid0IGJlIGlubGluZWQuIEluIHRoaXMgY2FzZSByZXZlcnQgdG8gdGhlIG9yaWdpbmFsIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgaC50eXBlID09PSAnbGluaycgJiYgaC5wcm9wc1snZGF0YS1vcHRpbWl6ZWQtZm9udHMnXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1ocmVmPVwiJHtoLnByb3BzWydkYXRhLWhyZWYnXX1cIl1gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaC5wcm9wcy5ocmVmID0gaC5wcm9wc1snZGF0YS1ocmVmJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBoLnByb3BzWydkYXRhLWhyZWYnXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGFnc1toLnR5cGVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChoKTtcbiAgICAgICAgICAgICAgICB0YWdzW2gudHlwZV0gPSBjb21wb25lbnRzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB0aXRsZUNvbXBvbmVudCA9IHRhZ3MudGl0bGUgPyB0YWdzLnRpdGxlWzBdIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB0aXRsZSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRpdGxlQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjaGlsZHJlbiAgfSA9IHRpdGxlQ29tcG9uZW50LnByb3BzO1xuICAgICAgICAgICAgICAgIHRpdGxlID0gdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJyA/IGNoaWxkcmVuIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbi5qb2luKCcnKSA6ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpdGxlICE9PSBkb2N1bWVudC50aXRsZSkgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTtcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnbWV0YScsXG4gICAgICAgICAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICdsaW5rJyxcbiAgICAgICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgICAgICdzY3JpcHQnXG4gICAgICAgICAgICBdLmZvckVhY2goKHR5cGUpPT57XG4gICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudHModHlwZSwgdGFnc1t0eXBlXSB8fCBbXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBET01BdHRyaWJ1dGVOYW1lcyA9IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2JyxcbiAgICBub01vZHVsZTogJ25vTW9kdWxlJ1xufTtcbmV4cG9ydHMuRE9NQXR0cmlidXRlTmFtZXMgPSBET01BdHRyaWJ1dGVOYW1lcztcbmZ1bmN0aW9uIHJlYWN0RWxlbWVudFRvRE9NKHsgdHlwZSAsIHByb3BzICB9KSB7XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIGZvcihjb25zdCBwIGluIHByb3BzKXtcbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XG4gICAgICAgIGlmIChwID09PSAnY2hpbGRyZW4nIHx8IHAgPT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIGNvbnRpbnVlO1xuICAgICAgICAvLyB3ZSBkb24ndCByZW5kZXIgdW5kZWZpbmVkIHByb3BzIHRvIHRoZSBET01cbiAgICAgICAgaWYgKHByb3BzW3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBhdHRyID0gRE9NQXR0cmlidXRlTmFtZXNbcF0gfHwgcC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcgJiYgKGF0dHIgPT09ICdhc3luYycgfHwgYXR0ciA9PT0gJ2RlZmVyJyB8fCBhdHRyID09PSAnbm9Nb2R1bGUnKSkge1xuICAgICAgICAgICAgZWxbYXR0cl0gPSAhIXByb3BzW3BdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKGF0dHIsIHByb3BzW3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuICwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIH0gPSBwcm9wcztcbiAgICBpZiAoZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpIHtcbiAgICAgICAgZWwuaW5uZXJIVE1MID0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sIHx8ICcnO1xuICAgIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgZWwudGV4dENvbnRlbnQgPSB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnID8gY2hpbGRyZW4gOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuLmpvaW4oJycpIDogJyc7XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGlzRXF1YWxOb2RlKG9sZFRhZywgbmV3VGFnKSB7XG4gICAgaWYgKG9sZFRhZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIG5ld1RhZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gbmV3VGFnLmdldEF0dHJpYnV0ZSgnbm9uY2UnKTtcbiAgICAgICAgLy8gT25seSBzdHJpcCB0aGUgbm9uY2UgaWYgYG9sZFRhZ2AgaGFzIGhhZCBpdCBzdHJpcHBlZC4gQW4gZWxlbWVudCdzIG5vbmNlIGF0dHJpYnV0ZSB3aWxsIG5vdFxuICAgICAgICAvLyBiZSBzdHJpcHBlZCBpZiB0aGVyZSBpcyBubyBjb250ZW50IHNlY3VyaXR5IHBvbGljeSByZXNwb25zZSBoZWFkZXIgdGhhdCBpbmNsdWRlcyBhIG5vbmNlLlxuICAgICAgICBpZiAobm9uY2UgJiYgIW9sZFRhZy5nZXRBdHRyaWJ1dGUoJ25vbmNlJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lVGFnID0gbmV3VGFnLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgIGNsb25lVGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCAnJyk7XG4gICAgICAgICAgICBjbG9uZVRhZy5ub25jZSA9IG5vbmNlO1xuICAgICAgICAgICAgcmV0dXJuIG5vbmNlID09PSBvbGRUYWcubm9uY2UgJiYgb2xkVGFnLmlzRXF1YWxOb2RlKGNsb25lVGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkVGFnLmlzRXF1YWxOb2RlKG5ld1RhZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVFbGVtZW50cyh0eXBlLCBjb21wb25lbnRzKSB7XG4gICAgY29uc3QgaGVhZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBjb25zdCBoZWFkQ291bnRFbCA9IGhlYWRFbC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9bmV4dC1oZWFkLWNvdW50XScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghaGVhZENvdW50RWwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1dhcm5pbmc6IG5leHQtaGVhZC1jb3VudCBpcyBtaXNzaW5nLiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWhlYWQtY291bnQtbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhlYWRDb3VudCA9IE51bWJlcihoZWFkQ291bnRFbC5jb250ZW50KTtcbiAgICBjb25zdCBvbGRUYWdzID0gW107XG4gICAgZm9yKGxldCBpID0gMCwgaiA9IGhlYWRDb3VudEVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IGkgPCBoZWFkQ291bnQ7IGkrKywgaiA9IChqID09IG51bGwgPyB2b2lkIDAgOiBqLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHx8IG51bGwpe1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBpZiAoKGogPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYgPSBqLnRhZ05hbWUpID09IG51bGwgPyB2b2lkIDAgOiByZWYudG9Mb3dlckNhc2UoKSkgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIG9sZFRhZ3MucHVzaChqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdUYWdzID0gY29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pLmZpbHRlcigobmV3VGFnKT0+e1xuICAgICAgICBmb3IobGV0IGsgPSAwLCBsZW4gPSBvbGRUYWdzLmxlbmd0aDsgayA8IGxlbjsgaysrKXtcbiAgICAgICAgICAgIGNvbnN0IG9sZFRhZyA9IG9sZFRhZ3Nba107XG4gICAgICAgICAgICBpZiAoaXNFcXVhbE5vZGUob2xkVGFnLCBuZXdUYWcpKSB7XG4gICAgICAgICAgICAgICAgb2xkVGFncy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIG9sZFRhZ3MuZm9yRWFjaCgodCk9PntcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcmV0dXJuIChyZWYgPSB0LnBhcmVudE5vZGUpID09IG51bGwgPyB2b2lkIDAgOiByZWYucmVtb3ZlQ2hpbGQodCk7XG4gICAgfSk7XG4gICAgbmV3VGFncy5mb3JFYWNoKCh0KT0+aGVhZEVsLmluc2VydEJlZm9yZSh0LCBoZWFkQ291bnRFbCkpO1xuICAgIGhlYWRDb3VudEVsLmNvbnRlbnQgPSAoaGVhZENvdW50IC0gb2xkVGFncy5sZW5ndGggKyBuZXdUYWdzLmxlbmd0aCkudG9TdHJpbmcoKTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC1tYW5hZ2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJpbml0SGVhZE1hbmFnZXIiLCJpc0VxdWFsTm9kZSIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwibW91bnRlZEluc3RhbmNlcyIsIlNldCIsInVwZGF0ZUhlYWQiLCJoZWFkIiwidGFncyIsImZvckVhY2giLCJoIiwidHlwZSIsInByb3BzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiaHJlZiIsInVuZGVmaW5lZCIsImNvbXBvbmVudHMiLCJwdXNoIiwidGl0bGVDb21wb25lbnQiLCJ0aXRsZSIsImNoaWxkcmVuIiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsInVwZGF0ZUVsZW1lbnRzIiwiYWNjZXB0Q2hhcnNldCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJub01vZHVsZSIsInJlYWN0RWxlbWVudFRvRE9NIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwicCIsImhhc093blByb3BlcnR5IiwiYXR0ciIsInRvTG93ZXJDYXNlIiwic2V0QXR0cmlidXRlIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJpbm5lckhUTUwiLCJfX2h0bWwiLCJ0ZXh0Q29udGVudCIsIm9sZFRhZyIsIm5ld1RhZyIsIkhUTUxFbGVtZW50Iiwibm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJjbG9uZVRhZyIsImNsb25lTm9kZSIsImhlYWRFbCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaGVhZENvdW50RWwiLCJwcm9jZXNzIiwiY29uc29sZSIsImVycm9yIiwiaGVhZENvdW50IiwiTnVtYmVyIiwiY29udGVudCIsIm9sZFRhZ3MiLCJpIiwiaiIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJyZWYiLCJ0YWdOYW1lIiwibmV3VGFncyIsIm1hcCIsImZpbHRlciIsImsiLCJsZW4iLCJsZW5ndGgiLCJzcGxpY2UiLCJ0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiaW5zZXJ0QmVmb3JlIiwidG9TdHJpbmciLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/head-manager.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interopRequireWildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.initialize = initialize;\nexports.hydrate = hydrate;\nexports.emitter = exports.router = exports.version = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _client = _interop_require_default(__webpack_require__(/*! react-dom/client */ \"./node_modules/next/dist/compiled/react-dom/client.js\"));\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _runtimeConfig = __webpack_require__(/*! ../shared/lib/runtime-config */ \"./node_modules/next/dist/shared/lib/runtime-config.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nvar _headManager = _interop_require_default(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nvar _pageLoader = _interop_require_default(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nvar _performanceRelayer = _interop_require_default(__webpack_require__(/*! ./performance-relayer */ \"./node_modules/next/dist/client/performance-relayer.js\"));\nvar _routeAnnouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nvar _isError = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _removeBasePath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _appRouterContext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nvar _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"./node_modules/next/dist/shared/lib/router/adapters.js\");\nvar _hooksClientContext = __webpack_require__(/*! ../shared/lib/hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nconst version = \"13.0.3\";\nexports.version = version;\nlet router;\nexports.router = router;\nconst emitter = (0, _mitt).default();\nexports.emitter = emitter;\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet webpackHMR;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nself.__next_require__ = __webpack_require__;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && // We don't update for 404 requests as this can modify\n        // the asPath unexpectedly e.g. adding basePath when\n        // it wasn't originally present\n        initialData.page !== \"/404\" && initialData.page !== \"/_error\" && (initialData.isFallback || initialData.nextExport && ((0, _isDynamic).isDynamicRoute(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + \"?\" + String((0, _querystring).assign((0, _querystring).urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash  } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { ReactDevOverlay  } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            return /*#__PURE__*/ _react.default.createElement(ReactDevOverlay, null, this.props.children);\n        }\n    }\n}\nfunction initialize() {\n    return _initialize.apply(this, arguments);\n}\nfunction _initialize() {\n    _initialize = _async_to_generator(function*() {\n        let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        // This makes sure this specific lines are removed in production\n        if (true) {\n            webpackHMR = opts.webpackHMR;\n        }\n        initialData = JSON.parse(document.getElementById(\"__NEXT_DATA__\").textContent);\n        window.__NEXT_DATA__ = initialData;\n        defaultLocale = initialData.defaultLocale;\n        const prefix = initialData.assetPrefix || \"\";\n        // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time\n        // So, this is how we do it in the client side at runtime\n        __webpack_require__.p = \"\".concat(prefix, \"/_next/\") //eslint-disable-line\n        ;\n        // Initialize next/config with the environment configuration\n        (0, _runtimeConfig).setConfig({\n            serverRuntimeConfig: {},\n            publicRuntimeConfig: initialData.runtimeConfig || {}\n        });\n        asPath = (0, _utils).getURL();\n        // make sure not to attempt stripping basePath for 404s\n        if ((0, _hasBasePath).hasBasePath(asPath)) {\n            asPath = (0, _removeBasePath).removeBasePath(asPath);\n        }\n        if (false) {}\n        if (initialData.scriptLoader) {\n            const { initScriptLoader  } = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\");\n            initScriptLoader(initialData.scriptLoader);\n        }\n        pageLoader = new _pageLoader.default(initialData.buildId, prefix);\n        const register = (param)=>{\n            let [r, f] = param;\n            return pageLoader.routeLoader.onEntrypoint(r, f);\n        };\n        if (window.__NEXT_P) {\n            // Defer page registration for another tick. This will increase the overall\n            // latency in hydrating the page, but reduce the total blocking time.\n            window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n        }\n        window.__NEXT_P = [];\n        window.__NEXT_P.push = register;\n        headManager = (0, _headManager).default();\n        headManager.getIsSsr = ()=>{\n            return router.isSsr;\n        };\n        appElement = document.getElementById(\"__next\");\n        return {\n            assetPrefix: prefix\n        };\n    });\n    return _initialize.apply(this, arguments);\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ _react.default.createElement(App, Object.assign({}, appProps));\n}\nfunction AppContainer(param) {\n    let { children  } = param;\n    var _autoExport;\n    return /*#__PURE__*/ _react.default.createElement(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error(\"Error rendering page: \", err))\n    }, /*#__PURE__*/ _react.default.createElement(_appRouterContext.AppRouterContext.Provider, {\n        value: (0, _adapters).adaptForAppRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_hooksClientContext.SearchParamsContext.Provider, {\n        value: (0, _adapters).adaptForSearchParams(router)\n    }, /*#__PURE__*/ _react.default.createElement(_adapters.PathnameContextProviderAdapter, {\n        router: router,\n        isAutoExport: (_autoExport = self.__NEXT_DATA__.autoExport) != null ? _autoExport : false\n    }, /*#__PURE__*/ _react.default.createElement(_routerContext.RouterContext.Provider, {\n        value: (0, _router).makePublicRouterInstance(router)\n    }, /*#__PURE__*/ _react.default.createElement(_headManagerContext.HeadManagerContext.Provider, {\n        value: headManager\n    }, /*#__PURE__*/ _react.default.createElement(_imageConfigContext.ImageConfigContext.Provider, {\n        value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    }, children)))))));\n}\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = _extends({}, wrappedAppProps, {\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        });\n        return /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps));\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App , err  } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        webpackHMR.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage(\"/_error\").then((param)=>{\n        let { page: ErrorComponent , styleSheets  } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interopRequireWildcard(__webpack_require__(/*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent , styleSheets  } = param;\n        var ref;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((ref = renderErrorProps.props) == null ? void 0 : ref.err) ? renderErrorProps.props : (0, _utils).loadGetInitialProps(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender(_extends({}, renderErrorProps, {\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            })));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    let { callback  } = param;\n    _s();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect(()=>callback(), [\n        callback\n    ]);\n    return null;\n}\n_s(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    [\n        \"beforeRender\",\n        \"afterHydrate\",\n        \"afterRender\",\n        \"routeChange\"\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterHydrate\") // mark end of hydration\n    ;\n    performance.measure(\"Next.js-before-hydration\", \"navigationStart\", \"beforeRender\");\n    performance.measure(\"Next.js-hydration\", \"beforeRender\", \"afterHydrate\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-hydration\").forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(\"afterRender\") // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(\"routeChange\", \"mark\");\n    if (!navStartEntries.length) return;\n    performance.measure(\"Next.js-route-change-to-render\", navStartEntries[0].name, \"beforeRender\");\n    performance.measure(\"Next.js-render\", \"beforeRender\", \"afterRender\");\n    if (onPerfEntry) {\n        performance.getEntriesByName(\"Next.js-render\").forEach(onPerfEntry);\n        performance.getEntriesByName(\"Next.js-route-change-to-render\").forEach(onPerfEntry);\n    }\n    clearMarks();\n    [\n        \"Next.js-route-change-to-render\",\n        \"Next.js-render\"\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(\"beforeRender\");\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl);\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    let { callbacks , children  } = param;\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect(()=>callbacks.forEach((callback)=>callback()), [\n        callbacks\n    ]);\n    // We should ask to measure the Web Vitals after rendering completes so we\n    // don't cause any hydration delay:\n    _react.default.useEffect(()=>{\n        (0, _performanceRelayer).default(onPerfEntry);\n    }, []);\n    if (false) {}\n    return children;\n}\n_s1(Root, \"Gjgl5rfcc2T4sFnfEMfRvL6K4Q4=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App , Component , props , err  } = input;\n    let styleSheets = \"initial\" in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = _extends({}, props, {\n        Component,\n        err,\n        router\n    });\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error(\"Cancel rendering route\");\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== \"production\") {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll(\"style[data-n-href]\"));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute(\"data-n-href\")));\n        const noscript = document.querySelector(\"noscript[data-n-css]\");\n        const nonce = noscript == null ? void 0 : noscript.getAttribute(\"data-n-css\");\n        styleSheets.forEach((param)=>{\n            let { href , text  } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement(\"style\");\n                styleTag.setAttribute(\"data-n-href\", href);\n                styleTag.setAttribute(\"media\", \"x\");\n                if (nonce) {\n                    styleTag.setAttribute(\"nonce\", nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (// unless we're in production:\n        false) {}\n        if (input.scroll) {\n            const htmlElement = document.documentElement;\n            const existing = htmlElement.style.scrollBehavior;\n            htmlElement.style.scrollBehavior = \"auto\";\n            window.scrollTo(input.scroll.x, input.scroll.y);\n            htmlElement.style.scrollBehavior = existing;\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(Head, {\n        callback: onHeadCommit\n    }), /*#__PURE__*/ _react.default.createElement(AppContainer, null, renderApp(App, appProps), /*#__PURE__*/ _react.default.createElement(_portal.Portal, {\n        type: \"next-route-announcer\"\n    }, /*#__PURE__*/ _react.default.createElement(_routeAnnouncer.RouteAnnouncer, null))));\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ _react.default.createElement(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ]\n        },  false ? /*#__PURE__*/ 0 : elem));\n    return renderPromise;\n}\nfunction render(renderingProps) {\n    return _render.apply(this, arguments);\n}\nfunction _render() {\n    _render = _async_to_generator(function*(renderingProps) {\n        if (renderingProps.err) {\n            yield renderError(renderingProps);\n            return;\n        }\n        try {\n            yield doRender(renderingProps);\n        } catch (err) {\n            const renderErr = (0, _isError).getProperError(err);\n            // bubble up cancelation errors\n            if (renderErr.cancelled) {\n                throw renderErr;\n            }\n            if (true) {\n                // Ensure this error is displayed in the overlay in development\n                setTimeout(()=>{\n                    throw renderErr;\n                });\n            }\n            yield renderError(_extends({}, renderingProps, {\n                err: renderErr\n            }));\n        }\n    });\n    return _render.apply(this, arguments);\n}\nfunction hydrate(opts) {\n    return _hydrate.apply(this, arguments);\n}\nfunction _hydrate() {\n    _hydrate = _async_to_generator(function*(opts) {\n        let initialErr = initialData.err;\n        try {\n            const appEntrypoint = yield pageLoader.routeLoader.whenEntrypoint(\"/_app\");\n            if (\"error\" in appEntrypoint) {\n                throw appEntrypoint.error;\n            }\n            const { component: app , exports: mod  } = appEntrypoint;\n            CachedApp = app;\n            if (mod && mod.reportWebVitals) {\n                onPerfEntry = (param)=>{\n                    let { id , name , startTime , value , duration , entryType , entries , attribution  } = param;\n                    // Combines timestamp with random number for unique ID\n                    const uniqueID = \"\".concat(Date.now(), \"-\").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                    let perfStartEntry;\n                    if (entries && entries.length) {\n                        perfStartEntry = entries[0].startTime;\n                    }\n                    const webVitals = {\n                        id: id || uniqueID,\n                        name,\n                        startTime: startTime || perfStartEntry,\n                        value: value == null ? duration : value,\n                        label: entryType === \"mark\" || entryType === \"measure\" ? \"custom\" : \"web-vital\"\n                    };\n                    if (attribution) {\n                        webVitals.attribution = attribution;\n                    }\n                    mod.reportWebVitals(webVitals);\n                };\n            }\n            const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n             true && initialData.err ? {\n                error: initialData.err\n            } : yield pageLoader.routeLoader.whenEntrypoint(initialData.page);\n            if (\"error\" in pageEntrypoint) {\n                throw pageEntrypoint.error;\n            }\n            CachedComponent = pageEntrypoint.component;\n            if (true) {\n                const { isValidElementType  } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(CachedComponent)) {\n                    throw new Error('The default export is not a React Component in page: \"'.concat(initialData.page, '\"'));\n                }\n            }\n        } catch (error1) {\n            // This catches errors like throwing in the top level of a module\n            initialErr = (0, _isError).getProperError(error1);\n        }\n        if (true) {\n            const { getServerError  } = __webpack_require__(/*! next/dist/compiled/@next/react-dev-overlay/dist/client */ \"./node_modules/next/dist/compiled/@next/react-dev-overlay/dist/client.js\");\n            // Server-side runtime errors need to be re-thrown on the client-side so\n            // that the overlay is rendered.\n            if (initialErr) {\n                if (initialErr === initialData.err) {\n                    setTimeout(()=>{\n                        let error;\n                        try {\n                            // Generate a new error object. We `throw` it because some browsers\n                            // will set the `stack` when thrown, and we want to ensure ours is\n                            // not overridden when we re-throw it below.\n                            throw new Error(initialErr.message);\n                        } catch (e) {\n                            error = e;\n                        }\n                        error.name = initialErr.name;\n                        error.stack = initialErr.stack;\n                        throw getServerError(error, initialErr.source);\n                    });\n                } else {\n                    setTimeout(()=>{\n                        throw initialErr;\n                    });\n                }\n            }\n        }\n        if (window.__NEXT_PRELOADREADY) {\n            yield window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n        }\n        exports.router = router = (0, _router).createRouter(initialData.page, initialData.query, asPath, {\n            initialProps: initialData.props,\n            pageLoader,\n            App: CachedApp,\n            Component: CachedComponent,\n            wrapApp,\n            err: initialErr,\n            isFallback: Boolean(initialData.isFallback),\n            subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                    App,\n                    scroll\n                })),\n            locale: initialData.locale,\n            locales: initialData.locales,\n            defaultLocale,\n            domainLocales: initialData.domainLocales,\n            isPreview: initialData.isPreview\n        });\n        initialMatchesMiddleware = yield router._initialMatchesMiddlewarePromise;\n        const renderCtx = {\n            App: CachedApp,\n            initial: true,\n            Component: CachedComponent,\n            props: initialData.props,\n            err: initialErr\n        };\n        if (opts == null ? void 0 : opts.beforeRender) {\n            yield opts.beforeRender();\n        }\n        render(renderCtx);\n    });\n    return _hydrate.apply(this, arguments);\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFrQixHQUFHRTtBQUNyQkYsZUFBZSxHQUFHRztBQUNsQkgsZUFBZSxHQUFHQSxjQUFjLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQzFELElBQUlPLHNCQUFzQkMseUlBQTBEO0FBQ3BGLElBQUlFLFdBQVdGLG1IQUErQztBQUM5RCxJQUFJRywyQkFBMkJILG1KQUErRDtBQUM5RixJQUFJSSw0QkFBNEJKLHFKQUFnRTtBQUNoR0EsbUJBQU9BLENBQUMsdUdBQW9DO0FBQzVDLElBQUlLLFNBQVNGLHlCQUF5QkgsbUJBQU9BLENBQUMsK0RBQU87QUFDckQsSUFBSU0sVUFBVUgseUJBQXlCSCxtQkFBT0EsQ0FBQywrRUFBa0I7QUFDakUsSUFBSU8sc0JBQXNCUCxtQkFBT0EsQ0FBQyx1R0FBb0M7QUFDdEUsSUFBSVEsUUFBUUwseUJBQXlCSCxtQkFBT0EsQ0FBQyx1RUFBb0I7QUFDakUsSUFBSVMsaUJBQWlCVCxtQkFBT0EsQ0FBQywyRkFBOEI7QUFDM0QsSUFBSVUsYUFBYVYsbUJBQU9BLENBQUMsNkdBQXVDO0FBQ2hFLElBQUlXLGVBQWVYLG1CQUFPQSxDQUFDLCtHQUF3QztBQUNuRSxJQUFJWSxpQkFBaUJaLG1CQUFPQSxDQUFDLDJGQUE4QjtBQUMzRCxJQUFJYSxTQUFTYixtQkFBT0EsQ0FBQyx5RUFBcUI7QUFDMUMsSUFBSWMsVUFBVWQsbUJBQU9BLENBQUMsaUVBQVU7QUFDaEMsSUFBSWUsZUFBZVoseUJBQXlCSCxtQkFBT0EsQ0FBQyx1RUFBZ0I7QUFDcEUsSUFBSWdCLGNBQWNiLHlCQUF5QkgsbUJBQU9BLENBQUMscUVBQWU7QUFDbEUsSUFBSWlCLHNCQUFzQmQseUJBQXlCSCxtQkFBT0EsQ0FBQyxxRkFBdUI7QUFDbEYsSUFBSWtCLGtCQUFr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VDtJQUMvQjBULE9BQU8xVCxPQUFPLEdBQUdBLFFBQVFTLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcz80NmNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pbml0aWFsaXplID0gaW5pdGlhbGl6ZTtcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5leHBvcnRzLmVtaXR0ZXIgPSBleHBvcnRzLnJvdXRlciA9IGV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xucmVxdWlyZShcIi4uL2J1aWxkL3BvbHlmaWxscy9wb2x5ZmlsbC1tb2R1bGVcIik7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2NsaWVudCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tL2NsaWVudFwiKSk7XG52YXIgX2hlYWRNYW5hZ2VyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0XCIpO1xudmFyIF9taXR0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL21pdHRcIikpO1xudmFyIF9yb3V0ZXJDb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZ1wiKTtcbnZhciBfcnVudGltZUNvbmZpZyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3J1bnRpbWUtY29uZmlnXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xudmFyIF9wb3J0YWwgPSByZXF1aXJlKFwiLi9wb3J0YWxcIik7XG52YXIgX2hlYWRNYW5hZ2VyID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuL2hlYWQtbWFuYWdlclwiKSk7XG52YXIgX3BhZ2VMb2FkZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vcGFnZS1sb2FkZXJcIikpO1xudmFyIF9wZXJmb3JtYW5jZVJlbGF5ZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vcGVyZm9ybWFuY2UtcmVsYXllclwiKSk7XG52YXIgX3JvdXRlQW5ub3VuY2VyID0gcmVxdWlyZShcIi4vcm91dGUtYW5ub3VuY2VyXCIpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi9yb3V0ZXJcIik7XG52YXIgX2lzRXJyb3IgPSByZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpO1xudmFyIF9pbWFnZUNvbmZpZ0NvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dFwiKTtcbnZhciBfcmVtb3ZlQmFzZVBhdGggPSByZXF1aXJlKFwiLi9yZW1vdmUtYmFzZS1wYXRoXCIpO1xudmFyIF9oYXNCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2hhcy1iYXNlLXBhdGhcIik7XG52YXIgX2FwcFJvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHRcIik7XG52YXIgX2FkYXB0ZXJzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL2FkYXB0ZXJzXCIpO1xudmFyIF9ob29rc0NsaWVudENvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9ob29rcy1jbGllbnQtY29udGV4dFwiKTtcbmNvbnN0IHZlcnNpb24gPSBcIjEzLjAuM1wiO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmxldCByb3V0ZXI7XG5leHBvcnRzLnJvdXRlciA9IHJvdXRlcjtcbmNvbnN0IGVtaXR0ZXIgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZW1pdHRlciA9IGVtaXR0ZXI7XG5jb25zdCBsb29zZVRvQXJyYXkgPSAoaW5wdXQpPT5bXS5zbGljZS5jYWxsKGlucHV0KTtcbmxldCBpbml0aWFsRGF0YTtcbmxldCBkZWZhdWx0TG9jYWxlID0gdW5kZWZpbmVkO1xubGV0IGFzUGF0aDtcbmxldCBwYWdlTG9hZGVyO1xubGV0IGFwcEVsZW1lbnQ7XG5sZXQgaGVhZE1hbmFnZXI7XG5sZXQgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0gZmFsc2U7XG5sZXQgbGFzdEFwcFByb3BzO1xubGV0IGxhc3RSZW5kZXJSZWplY3Q7XG5sZXQgd2VicGFja0hNUjtcbmxldCBDYWNoZWRBcHAsIG9uUGVyZkVudHJ5O1xubGV0IENhY2hlZENvbXBvbmVudDtcbnNlbGYuX19uZXh0X3JlcXVpcmVfXyA9IF9fd2VicGFja19yZXF1aXJlX187XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBfcmVhY3QuZGVmYXVsdC5Db21wb25lbnQge1xuICAgIGNvbXBvbmVudERpZENhdGNoKGNvbXBvbmVudEVyciwgaW5mbykge1xuICAgICAgICB0aGlzLnByb3BzLmZuKGNvbXBvbmVudEVyciwgaW5mbyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHJvdXRlciBzdGF0ZSBpZjpcbiAgICAgICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgICAgICAvLyAtIGl0IHdhcyBhdXRvIGV4cG9ydGVkIGFuZCBpcyBhIGR5bmFtaWMgcm91dGUgKHRvIHByb3ZpZGUgcGFyYW1zKVxuICAgICAgICAvLyAtIGlmIGl0IGlzIGEgY2xpZW50LXNpZGUgc2tlbGV0b24gKGZhbGxiYWNrIHJlbmRlcilcbiAgICAgICAgLy8gLSBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgdGhlIGN1cnJlbnQgcGFnZSAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgICAgIC8vIC0gaWYgcmV3cml0ZXMgaW4gbmV4dC5jb25maWcuanMgbWF0Y2ggKG1heSBoYXZlIHJld3JpdGUgcGFyYW1zKVxuICAgICAgICBpZiAocm91dGVyLmlzU3NyICYmIC8vIFdlIGRvbid0IHVwZGF0ZSBmb3IgNDA0IHJlcXVlc3RzIGFzIHRoaXMgY2FuIG1vZGlmeVxuICAgICAgICAvLyB0aGUgYXNQYXRoIHVuZXhwZWN0ZWRseSBlLmcuIGFkZGluZyBiYXNlUGF0aCB3aGVuXG4gICAgICAgIC8vIGl0IHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnRcbiAgICAgICAgaW5pdGlhbERhdGEucGFnZSAhPT0gJy80MDQnICYmIGluaXRpYWxEYXRhLnBhZ2UgIT09ICcvX2Vycm9yJyAmJiAoaW5pdGlhbERhdGEuaXNGYWxsYmFjayB8fCBpbml0aWFsRGF0YS5uZXh0RXhwb3J0ICYmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGVyLnBhdGhuYW1lKSB8fCBsb2NhdGlvbi5zZWFyY2ggfHwgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpIHx8IGluaXRpYWxEYXRhLnByb3BzICYmIGluaXRpYWxEYXRhLnByb3BzLl9fTl9TU0cgJiYgKGxvY2F0aW9uLnNlYXJjaCB8fCBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpKSB7XG4gICAgICAgICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICAgICAgICByb3V0ZXIucmVwbGFjZShyb3V0ZXIucGF0aG5hbWUgKyAnPycgKyBTdHJpbmcoKDAsIF9xdWVyeXN0cmluZykuYXNzaWduKCgwLCBfcXVlcnlzdHJpbmcpLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocm91dGVyLnF1ZXJ5KSwgbmV3IFVSTFNlYXJjaFBhcmFtcyhsb2NhdGlvbi5zZWFyY2gpKSksIGFzUGF0aCwge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICAgICAgICAgIF9oOiAxLFxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHBhZ2VzIG11c3QgdHJpZ2dlciB0aGUgZGF0YSBmZXRjaCwgc28gdGhlIHRyYW5zaXRpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBub3Qgc2hhbGxvdy5cbiAgICAgICAgICAgICAgICAvLyBPdGhlciBwYWdlcyAoc3RyaWN0bHkgdXBkYXRpbmcgcXVlcnkpIGhhcHBlbnMgc2hhbGxvd2x5LCBhcyBkYXRhXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIHdvdWxkIGFscmVhZHkgYmUgcHJlc2VudC5cbiAgICAgICAgICAgICAgICBzaGFsbG93OiAhaW5pdGlhbERhdGEuaXNGYWxsYmFjayAmJiAhaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGlmICghZXJyLmNhbmNlbGxlZCkgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaCgpO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goKSB7XG4gICAgICAgIGxldCB7IGhhc2ggIH0gPSBsb2NhdGlvbjtcbiAgICAgICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmICghaGFzaCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpO1xuICAgICAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICAgICAgc2V0VGltZW91dCgoKT0+ZWwuc2Nyb2xsSW50b1ZpZXcoKSwgMCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBSZWFjdERldk92ZXJsYXkgLCAgfSA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9kaXN0L2NsaWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdERldk92ZXJsYXksIG51bGwsIHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICByZXR1cm4gX2luaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9pbml0aWFsaXplKCkge1xuICAgIF9pbml0aWFsaXplID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioob3B0cyA9IHt9KSB7XG4gICAgICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGlzIHNwZWNpZmljIGxpbmVzIGFyZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICB3ZWJwYWNrSE1SID0gb3B0cy53ZWJwYWNrSE1SO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxEYXRhID0gSlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9EQVRBX18gPSBpbml0aWFsRGF0YTtcbiAgICAgICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGluaXRpYWxEYXRhLmFzc2V0UHJlZml4IHx8ICcnO1xuICAgICAgICAvLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4gICAgICAgIC8vIFNvLCB0aGlzIGlzIGhvdyB3ZSBkbyBpdCBpbiB0aGUgY2xpZW50IHNpZGUgYXQgcnVudGltZVxuICAgICAgICBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyA9IGAke3ByZWZpeH0vX25leHQvYCAvL2VzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgO1xuICAgICAgICAvLyBJbml0aWFsaXplIG5leHQvY29uZmlnIHdpdGggdGhlIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgKDAsIF9ydW50aW1lQ29uZmlnKS5zZXRDb25maWcoe1xuICAgICAgICAgICAgc2VydmVyUnVudGltZUNvbmZpZzoge30sXG4gICAgICAgICAgICBwdWJsaWNSdW50aW1lQ29uZmlnOiBpbml0aWFsRGF0YS5ydW50aW1lQ29uZmlnIHx8IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBhc1BhdGggPSAoMCwgX3V0aWxzKS5nZXRVUkwoKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuICAgICAgICBpZiAoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXNQYXRoKSkge1xuICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXNQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoICB9ID0gcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpO1xuICAgICAgICAgICAgY29uc3QgeyBkZXRlY3REb21haW5Mb2NhbGUgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGFyc2VSZWxhdGl2ZVVybCAgfSA9IHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCcpO1xuICAgICAgICAgICAgY29uc3QgeyBmb3JtYXRVcmwgIH0gPSByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJyk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbERhdGEubG9jYWxlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBpbml0aWFsRGF0YS5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVyaXZlIHRoZSBkZWZhdWx0IGxvY2FsZSBpZiBpdCB3YXNuJ3QgZGV0ZWN0ZWQgaW4gdGhlIGFzUGF0aFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jYWxlc1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IGRldGVjdGluZyBkZWZhdWx0IGxvY2FsZSBiYXNlZCBvbiBob3N0bmFtZVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX0RPTUFJTlMsIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgICAgICAgICAgICAvLyBoeWRyYXRpb24gdG8gcHJldmVudCBtaXNtYXRjaGVkIHJlbmRlcnNcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaW5pdFNjcmlwdExvYWRlciAgfSA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG4gICAgICAgICAgICBpbml0U2NyaXB0TG9hZGVyKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcGFnZUxvYWRlciA9IG5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGluaXRpYWxEYXRhLmJ1aWxkSWQsIHByZWZpeCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyID0gKFtyLCBmXSk9PnBhZ2VMb2FkZXIucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHIsIGYpO1xuICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9QKSB7XG4gICAgICAgICAgICAvLyBEZWZlciBwYWdlIHJlZ2lzdHJhdGlvbiBmb3IgYW5vdGhlciB0aWNrLiBUaGlzIHdpbGwgaW5jcmVhc2UgdGhlIG92ZXJhbGxcbiAgICAgICAgICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9QLm1hcCgocCk9PnNldFRpbWVvdXQoKCk9PnJlZ2lzdGVyKHApLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93Ll9fTkVYVF9QID0gW107XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoID0gcmVnaXN0ZXI7XG4gICAgICAgIGhlYWRNYW5hZ2VyID0gKDAsIF9oZWFkTWFuYWdlcikuZGVmYXVsdCgpO1xuICAgICAgICBoZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpPT57XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmlzU3NyO1xuICAgICAgICB9O1xuICAgICAgICBhcHBFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dCcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXNzZXRQcmVmaXg6IHByZWZpeFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gcmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcCwgT2JqZWN0LmFzc2lnbih7fSwgYXBwUHJvcHMpKTtcbn1cbmZ1bmN0aW9uIEFwcENvbnRhaW5lcih7IGNoaWxkcmVuICB9KSB7XG4gICAgdmFyIF9hdXRvRXhwb3J0O1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgICAgIGZuOiAoZXJyb3IpPT4vLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIHJlbmRlckVycm9yKHtcbiAgICAgICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgICAgICBlcnI6IGVycm9yXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+Y29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHBhZ2U6ICcsIGVycikpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9hcHBSb3V0ZXJDb250ZXh0LkFwcFJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfYWRhcHRlcnMpLmFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2Uocm91dGVyKVxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NDbGllbnRDb250ZXh0LlNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6ICgwLCBfYWRhcHRlcnMpLmFkYXB0Rm9yU2VhcmNoUGFyYW1zKHJvdXRlcilcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2FkYXB0ZXJzLlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciwge1xuICAgICAgICByb3V0ZXI6IHJvdXRlcixcbiAgICAgICAgaXNBdXRvRXhwb3J0OiAoX2F1dG9FeHBvcnQgPSBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydCkgIT0gbnVsbCA/IF9hdXRvRXhwb3J0IDogZmFsc2VcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JvdXRlckNvbnRleHQuUm91dGVyQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogKDAsIF9yb3V0ZXIpLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpXG4gICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9oZWFkTWFuYWdlckNvbnRleHQuSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBoZWFkTWFuYWdlclxuICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9LCBjaGlsZHJlbikpKSkpKSk7XG59XG5jb25zdCB3cmFwQXBwID0gKEFwcCk9Pih3cmFwcGVkQXBwUHJvcHMpPT57XG4gICAgICAgIGNvbnN0IGFwcFByb3BzID0gX2V4dGVuZHMoe30sIHdyYXBwZWRBcHBQcm9wcywge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgICAgICAgICBlcnI6IGluaXRpYWxEYXRhLmVycixcbiAgICAgICAgICAgIHJvdXRlclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChBcHBDb250YWluZXIsIG51bGwsIHJlbmRlckFwcChBcHAsIGFwcFByb3BzKSk7XG4gICAgfTtcbi8vIFRoaXMgbWV0aG9kIGhhbmRsZXMgYWxsIHJ1bnRpbWUgYW5kIGRlYnVnIGVycm9ycy5cbi8vIDQwNCBhbmQgNTAwIGVycm9ycyBhcmUgc3BlY2lhbCBraW5kIG9mIGVycm9yc1xuLy8gYW5kIHRoZXkgYXJlIHN0aWxsIGhhbmRsZSB2aWEgdGhlIG1haW4gcmVuZGVyIG1ldGhvZC5cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHMpIHtcbiAgICBsZXQgeyBBcHAgLCBlcnIgIH0gPSByZW5kZXJFcnJvclByb3BzO1xuICAgIC8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbiAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIEEgTmV4dC5qcyByZW5kZXJpbmcgcnVudGltZSBlcnJvciBpcyBhbHdheXMgdW5yZWNvdmVyYWJsZVxuICAgICAgICAvLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG4gICAgICAgIHdlYnBhY2tITVIub25VbnJlY292ZXJhYmxlRXJyb3IoKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAgICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICAgICAgLy8gVE9ETzogRml4IGRpc2FibGVkIGVzbGludCBydWxlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgcmV0dXJuIGRvUmVuZGVyKHtcbiAgICAgICAgICAgIEFwcDogKCk9Pm51bGwsXG4gICAgICAgICAgICBwcm9wczoge30sXG4gICAgICAgICAgICBDb21wb25lbnQ6ICgpPT5udWxsLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICBjb25zb2xlLmVycm9yKGBBIGNsaWVudC1zaWRlIGV4Y2VwdGlvbiBoYXMgb2NjdXJyZWQsIHNlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2NsaWVudC1zaWRlLWV4Y2VwdGlvbi1vY2N1cnJlZGApO1xuICAgIHJldHVybiBwYWdlTG9hZGVyLmxvYWRQYWdlKCcvX2Vycm9yJykudGhlbigoeyBwYWdlOiBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9KT0+e1xuICAgICAgICByZXR1cm4gKGxhc3RBcHBQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogbGFzdEFwcFByb3BzLkNvbXBvbmVudCkgPT09IEVycm9yQ29tcG9uZW50ID8gaW1wb3J0KCcuLi9wYWdlcy9fZXJyb3InKS50aGVuKChlcnJvck1vZHVsZSk9PntcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnQoJy4uL3BhZ2VzL19hcHAnKS50aGVuKChhcHBNb2R1bGUpPT57XG4gICAgICAgICAgICAgICAgQXBwID0gYXBwTW9kdWxlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgcmVuZGVyRXJyb3JQcm9wcy5BcHAgPSBBcHA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yTW9kdWxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKG0pPT4oe1xuICAgICAgICAgICAgICAgIEVycm9yQ29tcG9uZW50OiBtLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgICAgICB9KSkgOiB7XG4gICAgICAgICAgICBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICAgIHN0eWxlU2hlZXRzXG4gICAgICAgIH07XG4gICAgfSkudGhlbigoeyBFcnJvckNvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9KT0+e1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbiAgICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB3cmFwQXBwKEFwcCk7XG4gICAgICAgIGNvbnN0IGFwcEN0eCA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgcm91dGVyLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgICAgICAgQXBwVHJlZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCgocmVmID0gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5lcnIpID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wcyA6ICgwLCBfdXRpbHMpLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCBhcHBDdHgpKS50aGVuKChpbml0UHJvcHMpPT4vLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgICAgIGRvUmVuZGVyKF9leHRlbmRzKHt9LCByZW5kZXJFcnJvclByb3BzLCB7XG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRQcm9wc1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9KTtcbn1cbi8vIER1bW15IGNvbXBvbmVudCB0aGF0IHdlIHJlbmRlciBhcyBhIGNoaWxkIG9mIFJvb3Qgc28gdGhhdCB3ZSBjYW5cbi8vIHRvZ2dsZSB0aGUgY29ycmVjdCBzdHlsZXMgYmVmb3JlIHRoZSBwYWdlIGlzIHJlbmRlcmVkLlxuZnVuY3Rpb24gSGVhZCh7IGNhbGxiYWNrICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWRcbiAgICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgICBfcmVhY3QuZGVmYXVsdC51c2VMYXlvdXRFZmZlY3QoKCk9PmNhbGxiYWNrKCksIFtcbiAgICAgICAgY2FsbGJhY2tcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmxldCByZWFjdFJvb3QgPSBudWxsO1xuLy8gT24gaW5pdGlhbCByZW5kZXIgYSBoeWRyYXRlIHNob3VsZCBhbHdheXMgaGFwcGVuXG5sZXQgc2hvdWxkSHlkcmF0ZSA9IHRydWU7XG5mdW5jdGlvbiBjbGVhck1hcmtzKCkge1xuICAgIFtcbiAgICAgICAgJ2JlZm9yZVJlbmRlcicsXG4gICAgICAgICdhZnRlckh5ZHJhdGUnLFxuICAgICAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICAncm91dGVDaGFuZ2UnXG4gICAgXS5mb3JFYWNoKChtYXJrKT0+cGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSk7XG59XG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghX3V0aWxzLlNUKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWFyaygnYWZ0ZXJIeWRyYXRlJykgLy8gbWFyayBlbmQgb2YgaHlkcmF0aW9uXG4gICAgO1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtYmVmb3JlLWh5ZHJhdGlvbicsICduYXZpZ2F0aW9uU3RhcnQnLCAnYmVmb3JlUmVuZGVyJyk7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpO1xuICAgIGlmIChvblBlcmZFbnRyeSkge1xuICAgICAgICBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdOZXh0LmpzLWh5ZHJhdGlvbicpLmZvckVhY2gob25QZXJmRW50cnkpO1xuICAgIH1cbiAgICBjbGVhck1hcmtzKCk7XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gICAgaWYgKCFfdXRpbHMuU1QpIHJldHVybjtcbiAgICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpIC8vIG1hcmsgZW5kIG9mIHJlbmRlclxuICAgIDtcbiAgICBjb25zdCBuYXZTdGFydEVudHJpZXMgPSBwZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsICdtYXJrJyk7XG4gICAgaWYgKCFuYXZTdGFydEVudHJpZXMubGVuZ3RoKSByZXR1cm47XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsICdiZWZvcmVSZW5kZXInKTtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsICdiZWZvcmVSZW5kZXInLCAnYWZ0ZXJSZW5kZXInKTtcbiAgICBpZiAob25QZXJmRW50cnkpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yZW5kZXInKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTtcbiAgICAgICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7XG4gICAgfVxuICAgIGNsZWFyTWFya3MoKTtcbiAgICBbXG4gICAgICAgICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLFxuICAgICAgICAnTmV4dC5qcy1yZW5kZXInXG4gICAgXS5mb3JFYWNoKChtZWFzdXJlKT0+cGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhtZWFzdXJlKSk7XG59XG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoZG9tRWwsIGZuKSB7XG4gICAgLy8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygnYmVmb3JlUmVuZGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWN0RWwgPSBmbihzaG91bGRIeWRyYXRlID8gbWFya0h5ZHJhdGVDb21wbGV0ZSA6IG1hcmtSZW5kZXJDb21wbGV0ZSk7XG4gICAgaWYgKCFyZWFjdFJvb3QpIHtcbiAgICAgICAgLy8gVW5saWtlIHdpdGggY3JlYXRlUm9vdCwgeW91IGRvbid0IG5lZWQgYSBzZXBhcmF0ZSByb290LnJlbmRlcigpIGNhbGwgaGVyZVxuICAgICAgICByZWFjdFJvb3QgPSBfY2xpZW50LmRlZmF1bHQuaHlkcmF0ZVJvb3QoZG9tRWwsIHJlYWN0RWwpO1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgICAgIHNob3VsZEh5ZHJhdGUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdGFydFRyYW5zaXRpb24gPSBfcmVhY3QuZGVmYXVsdC5zdGFydFRyYW5zaXRpb247XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKT0+e1xuICAgICAgICAgICAgcmVhY3RSb290LnJlbmRlcihyZWFjdEVsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gUm9vdCh7IGNhbGxiYWNrcyAsIGNoaWxkcmVuICB9KSB7XG4gICAgLy8gV2UgdXNlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGd1YXJhbnRlZSB0aGUgY2FsbGJhY2tzIGFyZSBleGVjdXRlZFxuICAgIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlXG4gICAgX3JlYWN0LmRlZmF1bHQudXNlTGF5b3V0RWZmZWN0KCgpPT5jYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spPT5jYWxsYmFjaygpKSwgW1xuICAgICAgICBjYWxsYmFja3NcbiAgICBdKTtcbiAgICAvLyBXZSBzaG91bGQgYXNrIHRvIG1lYXN1cmUgdGhlIFdlYiBWaXRhbHMgYWZ0ZXIgcmVuZGVyaW5nIGNvbXBsZXRlcyBzbyB3ZVxuICAgIC8vIGRvbid0IGNhdXNlIGFueSBoeWRyYXRpb24gZGVsYXk6XG4gICAgX3JlYWN0LmRlZmF1bHQudXNlRWZmZWN0KCgpPT57XG4gICAgICAgICgwLCBfcGVyZm9ybWFuY2VSZWxheWVyKS5kZWZhdWx0KG9uUGVyZkVudHJ5KTtcbiAgICB9LCBbXSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRCA9IHRydWU7XG4gICAgICAgICAgICBpZiAod2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBkb1JlbmRlcihpbnB1dCkge1xuICAgIGxldCB7IEFwcCAsIENvbXBvbmVudCAsIHByb3BzICwgZXJyICB9ID0gaW5wdXQ7XG4gICAgbGV0IHN0eWxlU2hlZXRzID0gJ2luaXRpYWwnIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHM7XG4gICAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnQ7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHM7XG4gICAgY29uc3QgYXBwUHJvcHMgPSBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBlcnIsXG4gICAgICAgIHJvdXRlclxuICAgIH0pO1xuICAgIC8vIGxhc3RBcHBQcm9wcyBoYXMgdG8gYmUgc2V0IGJlZm9yZSBSZWFjdERvbS5yZW5kZXIgdG8gYWNjb3VudCBmb3IgUmVhY3REb20gdGhyb3dpbmcgYW4gZXJyb3IuXG4gICAgbGFzdEFwcFByb3BzID0gYXBwUHJvcHM7XG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgIGNvbnN0IHJlbmRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBpZiAobGFzdFJlbmRlclJlamVjdCkge1xuICAgICAgICAgICAgbGFzdFJlbmRlclJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVQcm9taXNlID0gKCk9PntcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gKCk9PntcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0NhbmNlbCByZW5kZXJpbmcgcm91dGUnKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGFzIGEgcmV0dXJuIHR5cGUgdG8gZW5zdXJlIGl0IGRvZXNuJ3Qgc3RhcnQgcmV0dXJuaW5nIGFcbiAgICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICAgIGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIGlmICghc3R5bGVTaGVldHMgfHwgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IG5ldyBTZXQoY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZyk9PnRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykpKTtcbiAgICAgICAgY29uc3Qgbm9zY3JpcHQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdub3NjcmlwdFtkYXRhLW4tY3NzXScpO1xuICAgICAgICBjb25zdCBub25jZSA9IG5vc2NyaXB0ID09IG51bGwgPyB2b2lkIDAgOiBub3NjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1jc3MnKTtcbiAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoeyBocmVmICwgdGV4dCAgfSk9PntcbiAgICAgICAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJywgaHJlZik7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdtZWRpYScsICd4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkhlYWRDb21taXQoKSB7XG4gICAgICAgIGlmICgvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgICAgLy8gdW5sZXNzIHdlJ3JlIGluIHByb2R1Y3Rpb246XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgICBzdHlsZVNoZWV0cyAmJiAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgICAhY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRIcmVmcyA9IG5ldyBTZXQoc3R5bGVTaGVldHMubWFwKChzKT0+cy5ocmVmKSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtbi1ocmVmXScpKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpPT50YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpKTtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgICAgICAgZm9yKGxldCBpZHggPSAwOyBpZHggPCBjdXJyZW50SHJlZnMubGVuZ3RoOyArK2lkeCl7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICAgICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJyk7XG4gICAgICAgICAgICBpZiAoLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0YXJnZXRUYWcsIHJlZmVyZW5jZU5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgICAgICAgbG9vc2VUb0FycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJykpLmZvckVhY2goKGVsKT0+e1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0LnNjcm9sbCkge1xuICAgICAgICAgICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgICAgICAgICAgaHRtbEVsZW1lbnQuc3R5bGUuc2Nyb2xsQmVoYXZpb3IgPSAnYXV0byc7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oaW5wdXQuc2Nyb2xsLngsIGlucHV0LnNjcm9sbC55KTtcbiAgICAgICAgICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Sb290Q29tbWl0KCkge1xuICAgICAgICByZXNvbHZlUHJvbWlzZSgpO1xuICAgIH1cbiAgICBvblN0YXJ0KCk7XG4gICAgY29uc3QgZWxlbSA9IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhlYWQsIHtcbiAgICAgICAgY2FsbGJhY2s6IG9uSGVhZENvbW1pdFxuICAgIH0pLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXBwQ29udGFpbmVyLCBudWxsLCByZW5kZXJBcHAoQXBwLCBhcHBQcm9wcyksIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcG9ydGFsLlBvcnRhbCwge1xuICAgICAgICB0eXBlOiBcIm5leHQtcm91dGUtYW5ub3VuY2VyXCJcbiAgICB9LCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JvdXRlQW5ub3VuY2VyLlJvdXRlQW5ub3VuY2VyLCBudWxsKSkpKTtcbiAgICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgICByZW5kZXJSZWFjdEVsZW1lbnQoYXBwRWxlbWVudCwgKGNhbGxiYWNrKT0+LyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJvb3QsIHtcbiAgICAgICAgICAgIGNhbGxiYWNrczogW1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIG9uUm9vdENvbW1pdFxuICAgICAgICAgICAgXVxuICAgICAgICB9LCBwcm9jZXNzLmVudi5fX05FWFRfU1RSSUNUX01PREUgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuU3RyaWN0TW9kZSwgbnVsbCwgZWxlbSkgOiBlbGVtKSk7XG4gICAgcmV0dXJuIHJlbmRlclByb21pc2U7XG59XG5mdW5jdGlvbiByZW5kZXIocmVuZGVyaW5nUHJvcHMpIHtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX3JlbmRlcigpIHtcbiAgICBfcmVuZGVyID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioocmVuZGVyaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKHJlbmRlcmluZ1Byb3BzLmVycikge1xuICAgICAgICAgICAgeWllbGQgcmVuZGVyRXJyb3IocmVuZGVyaW5nUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB5aWVsZCBkb1JlbmRlcihyZW5kZXJpbmdQcm9wcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyRXJyID0gKDAsIF9pc0Vycm9yKS5nZXRQcm9wZXJFcnJvcihlcnIpO1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZW5kZXJFcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhpcyBlcnJvciBpcyBkaXNwbGF5ZWQgaW4gdGhlIG92ZXJsYXkgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJlbmRlckVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHJlbmRlckVycm9yKF9leHRlbmRzKHt9LCByZW5kZXJpbmdQcm9wcywge1xuICAgICAgICAgICAgICAgIGVycjogcmVuZGVyRXJyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3JlbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZShvcHRzKSB7XG4gICAgcmV0dXJuIF9oeWRyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfaHlkcmF0ZSgpIHtcbiAgICBfaHlkcmF0ZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdHMpIHtcbiAgICAgICAgbGV0IGluaXRpYWxFcnIgPSBpbml0aWFsRGF0YS5lcnI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhcHBFbnRyeXBvaW50ID0geWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludCgnL19hcHAnKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIGFwcEVudHJ5cG9pbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCAsIGV4cG9ydHM6IG1vZCAgfSA9IGFwcEVudHJ5cG9pbnQ7XG4gICAgICAgICAgICBDYWNoZWRBcHAgPSBhcHA7XG4gICAgICAgICAgICBpZiAobW9kICYmIG1vZC5yZXBvcnRXZWJWaXRhbHMpIHtcbiAgICAgICAgICAgICAgICBvblBlcmZFbnRyeSA9ICh7IGlkICwgbmFtZSAsIHN0YXJ0VGltZSAsIHZhbHVlICwgZHVyYXRpb24gLCBlbnRyeVR5cGUgLCBlbnRyaWVzICwgYXR0cmlidXRpb24gIH0pPT57XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbWJpbmVzIHRpbWVzdGFtcCB3aXRoIHJhbmRvbSBudW1iZXIgZm9yIHVuaXF1ZSBJRFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVJRCA9IGAke0RhdGUubm93KCl9LSR7TWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyfWA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwZXJmU3RhcnRFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJpZXMgJiYgZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2ViVml0YWxzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkIHx8IHVuaXF1ZUlELFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlID09IG51bGwgPyBkdXJhdGlvbiA6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGVudHJ5VHlwZSA9PT0gJ21hcmsnIHx8IGVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnID8gJ2N1c3RvbScgOiAnd2ViLXZpdGFsJ1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYlZpdGFscy5hdHRyaWJ1dGlvbiA9IGF0dHJpYnV0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFnZUVudHJ5cG9pbnQgPSAvLyBUaGUgZGV2IHNlcnZlciBmYWlscyB0byBzZXJ2ZSBzY3JpcHQgYXNzZXRzIHdoZW4gdGhlcmUncyBhIGh5ZHJhdGlvblxuICAgICAgICAgICAgLy8gZXJyb3IsIHNvIHdlIG5lZWQgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgZW50cnlwb2ludC5cbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnICYmIGluaXRpYWxEYXRhLmVyciA/IHtcbiAgICAgICAgICAgICAgICBlcnJvcjogaW5pdGlhbERhdGEuZXJyXG4gICAgICAgICAgICB9IDogeWllbGQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChpbml0aWFsRGF0YS5wYWdlKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGFnZUVudHJ5cG9pbnQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlICB9ID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke2luaXRpYWxEYXRhLnBhZ2V9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yMSkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICAgICAgICAgIGluaXRpYWxFcnIgPSAoMCwgX2lzRXJyb3IpLmdldFByb3BlckVycm9yKGVycm9yMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICBjb25zdCB7IGdldFNlcnZlckVycm9yICwgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvZGlzdC9jbGllbnQnKTtcbiAgICAgICAgICAgIC8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuICAgICAgICAgICAgLy8gdGhhdCB0aGUgb3ZlcmxheSBpcyByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxFcnIgPT09IGluaXRpYWxEYXRhLmVycikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIHNldCB0aGUgYHN0YWNrYCB3aGVuIHRocm93biwgYW5kIHdlIHdhbnQgdG8gZW5zdXJlIG91cnMgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBnZXRTZXJ2ZXJFcnJvcihlcnJvciwgaW5pdGlhbEVyci5zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgICAgICAgICB5aWVsZCB3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWShpbml0aWFsRGF0YS5keW5hbWljSWRzKTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLnJvdXRlciA9IHJvdXRlciA9ICgwLCBfcm91dGVyKS5jcmVhdGVSb3V0ZXIoaW5pdGlhbERhdGEucGFnZSwgaW5pdGlhbERhdGEucXVlcnksIGFzUGF0aCwge1xuICAgICAgICAgICAgaW5pdGlhbFByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgd3JhcEFwcCxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbEVycixcbiAgICAgICAgICAgIGlzRmFsbGJhY2s6IEJvb2xlYW4oaW5pdGlhbERhdGEuaXNGYWxsYmFjayksXG4gICAgICAgICAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCk9PnJlbmRlcihPYmplY3QuYXNzaWduKHt9LCBpbmZvLCB7XG4gICAgICAgICAgICAgICAgICAgIEFwcCxcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgbG9jYWxlOiBpbml0aWFsRGF0YS5sb2NhbGUsXG4gICAgICAgICAgICBsb2NhbGVzOiBpbml0aWFsRGF0YS5sb2NhbGVzLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIGRvbWFpbkxvY2FsZXM6IGluaXRpYWxEYXRhLmRvbWFpbkxvY2FsZXMsXG4gICAgICAgICAgICBpc1ByZXZpZXc6IGluaXRpYWxEYXRhLmlzUHJldmlld1xuICAgICAgICB9KTtcbiAgICAgICAgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlID0geWllbGQgcm91dGVyLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlO1xuICAgICAgICBjb25zdCByZW5kZXJDdHggPSB7XG4gICAgICAgICAgICBBcHA6IENhY2hlZEFwcCxcbiAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgICAgICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICAgICAgICAgIGVycjogaW5pdGlhbEVyclxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIHlpZWxkIG9wdHMuYmVmb3JlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyKHJlbmRlckN0eCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9oeWRyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImluaXRpYWxpemUiLCJoeWRyYXRlIiwiZW1pdHRlciIsInJvdXRlciIsInZlcnNpb24iLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsImRlZmF1bHQiLCJfZXh0ZW5kcyIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVhY3QiLCJfY2xpZW50IiwiX2hlYWRNYW5hZ2VyQ29udGV4dCIsIl9taXR0IiwiX3JvdXRlckNvbnRleHQiLCJfaXNEeW5hbWljIiwiX3F1ZXJ5c3RyaW5nIiwiX3J1bnRpbWVDb25maWciLCJfdXRpbHMiLCJfcG9ydGFsIiwiX2hlYWRNYW5hZ2VyIiwiX3BhZ2VMb2FkZXIiLCJfcGVyZm9ybWFuY2VSZWxheWVyIiwiX3JvdXRlQW5ub3VuY2VyIiwiX3JvdXRlciIsIl9pc0Vycm9yIiwiX2ltYWdlQ29uZmlnQ29udGV4dCIsIl9yZW1vdmVCYXNlUGF0aCIsIl9oYXNCYXNlUGF0aCIsIl9hcHBSb3V0ZXJDb250ZXh0IiwiX2FkYXB0ZXJzIiwiX2hvb2tzQ2xpZW50Q29udGV4dCIsImxvb3NlVG9BcnJheSIsImlucHV0Iiwic2xpY2UiLCJjYWxsIiwiaW5pdGlhbERhdGEiLCJkZWZhdWx0TG9jYWxlIiwidW5kZWZpbmVkIiwiYXNQYXRoIiwicGFnZUxvYWRlciIsImFwcEVsZW1lbnQiLCJoZWFkTWFuYWdlciIsImluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSIsImxhc3RBcHBQcm9wcyIsImxhc3RSZW5kZXJSZWplY3QiLCJ3ZWJwYWNrSE1SIiwiQ2FjaGVkQXBwIiwib25QZXJmRW50cnkiLCJDYWNoZWRDb21wb25lbnQiLCJzZWxmIiwiX19uZXh0X3JlcXVpcmVfXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJDb250YWluZXIiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsImluZm8iLCJwcm9wcyIsImZuIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJpc1NzciIsInBhZ2UiLCJpc0ZhbGxiYWNrIiwibmV4dEV4cG9ydCIsImlzRHluYW1pY1JvdXRlIiwicGF0aG5hbWUiLCJsb2NhdGlvbiIsInNlYXJjaCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJfaCIsInNoYWxsb3ciLCJjYXRjaCIsImVyciIsImNhbmNlbGxlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImhhc2giLCJzdWJzdHJpbmciLCJlbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJyZW5kZXIiLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsImNyZWF0ZUVsZW1lbnQiLCJfaW5pdGlhbGl6ZSIsImFwcGx5IiwiYXJndW1lbnRzIiwib3B0cyIsIkpTT04iLCJwYXJzZSIsInRleHRDb250ZW50Iiwid2luZG93IiwiX19ORVhUX0RBVEFfXyIsInByZWZpeCIsImFzc2V0UHJlZml4IiwiX193ZWJwYWNrX3B1YmxpY19wYXRoX18iLCJzZXRDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsInJ1bnRpbWVDb25maWciLCJnZXRVUkwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiZm9ybWF0VXJsIiwibG9jYWxlcyIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwibG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwiaG9zdG5hbWUiLCJzY3JpcHRMb2FkZXIiLCJpbml0U2NyaXB0TG9hZGVyIiwiYnVpbGRJZCIsInJlZ2lzdGVyIiwiciIsImYiLCJyb3V0ZUxvYWRlciIsIm9uRW50cnlwb2ludCIsIl9fTkVYVF9QIiwibWFwIiwicCIsInB1c2giLCJnZXRJc1NzciIsInJlbmRlckFwcCIsIkFwcCIsImFwcFByb3BzIiwiQXBwQ29udGFpbmVyIiwiX2F1dG9FeHBvcnQiLCJlcnJvciIsInJlbmRlckVycm9yIiwiY29uc29sZSIsIkFwcFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiYWRhcHRGb3JTZWFyY2hQYXJhbXMiLCJQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIiLCJpc0F1dG9FeHBvcnQiLCJhdXRvRXhwb3J0IiwiUm91dGVyQ29udGV4dCIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid3JhcEFwcCIsIndyYXBwZWRBcHBQcm9wcyIsInJlbmRlckVycm9yUHJvcHMiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImRvUmVuZGVyIiwic3R5bGVTaGVldHMiLCJsb2FkUGFnZSIsInRoZW4iLCJFcnJvckNvbXBvbmVudCIsImVycm9yTW9kdWxlIiwiYXBwTW9kdWxlIiwibSIsInJlZiIsIkFwcFRyZWUiLCJhcHBDdHgiLCJjdHgiLCJQcm9taXNlIiwicmVzb2x2ZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJpbml0UHJvcHMiLCJIZWFkIiwiY2FsbGJhY2siLCJ1c2VMYXlvdXRFZmZlY3QiLCJyZWFjdFJvb3QiLCJzaG91bGRIeWRyYXRlIiwiY2xlYXJNYXJrcyIsImZvckVhY2giLCJtYXJrIiwicGVyZm9ybWFuY2UiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwiU1QiLCJtZWFzdXJlIiwiZ2V0RW50cmllc0J5TmFtZSIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsImxlbmd0aCIsIm5hbWUiLCJjbGVhck1lYXN1cmVzIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiZG9tRWwiLCJyZWFjdEVsIiwiaHlkcmF0ZVJvb3QiLCJzdGFydFRyYW5zaXRpb24iLCJSb290IiwiY2FsbGJhY2tzIiwidXNlRWZmZWN0IiwiX19ORVhUX1RFU1RfTU9ERSIsIl9fTkVYVF9IWURSQVRFRCIsIl9fTkVYVF9IWURSQVRFRF9DQiIsImNhbmNlbGVkIiwicmVzb2x2ZVByb21pc2UiLCJyZW5kZXJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJvblN0YXJ0IiwiY3VycmVudFN0eWxlVGFncyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjdXJyZW50SHJlZnMiLCJTZXQiLCJ0YWciLCJnZXRBdHRyaWJ1dGUiLCJub3NjcmlwdCIsInF1ZXJ5U2VsZWN0b3IiLCJub25jZSIsImhyZWYiLCJ0ZXh0IiwiaGFzIiwic3R5bGVUYWciLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9uSGVhZENvbW1pdCIsImRlc2lyZWRIcmVmcyIsInMiLCJpZHgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZWZlcmVuY2VOb2RlIiwidGFyZ2V0VGFnIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwicmVtb3ZlQ2hpbGQiLCJzY3JvbGwiLCJodG1sRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImV4aXN0aW5nIiwic3R5bGUiLCJzY3JvbGxCZWhhdmlvciIsInNjcm9sbFRvIiwieCIsInkiLCJvblJvb3RDb21taXQiLCJlbGVtIiwiRnJhZ21lbnQiLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwicmVuZGVyaW5nUHJvcHMiLCJfcmVuZGVyIiwicmVuZGVyRXJyIiwiZ2V0UHJvcGVyRXJyb3IiLCJfaHlkcmF0ZSIsImluaXRpYWxFcnIiLCJhcHBFbnRyeXBvaW50Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJhcHAiLCJtb2QiLCJyZXBvcnRXZWJWaXRhbHMiLCJpZCIsInN0YXJ0VGltZSIsImR1cmF0aW9uIiwiZW50cnlUeXBlIiwiZW50cmllcyIsImF0dHJpYnV0aW9uIiwidW5pcXVlSUQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZXJyb3IxIiwiZ2V0U2VydmVyRXJyb3IiLCJtZXNzYWdlIiwiZSIsInN0YWNrIiwic291cmNlIiwiX19ORVhUX1BSRUxPQURSRUFEWSIsImR5bmFtaWNJZHMiLCJjcmVhdGVSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJCb29sZWFuIiwic3Vic2NyaXB0aW9uIiwiZG9tYWluTG9jYWxlcyIsImlzUHJldmlldyIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwicmVuZGVyQ3R4IiwiaW5pdGlhbCIsImJlZm9yZVJlbmRlciIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePathTrailingSlash = void 0;\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst normalizePathTrailingSlash = (path)=>{\n    if (!path.startsWith(\"/\")) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    if (false) {}\n    return \"\".concat((0, _removeTrailingSlash).removeTrailingSlash(pathname)).concat(query).concat(hash);\n};\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=normalize-trailing-slash.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0NBQWtDLEdBQUcsS0FBSztBQUMxQyxJQUFJRyx1QkFBdUJDLG1CQUFPQSxDQUFDLG1JQUFrRDtBQUNyRixJQUFJQyxhQUFhRCxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDaEUsTUFBTUYsNkJBQTZCLENBQUNJLE9BQU87SUFDdkMsSUFBSSxDQUFDQSxLQUFLQyxVQUFVLENBQUMsTUFBTTtRQUN2QixPQUFPRDtJQUNYLENBQUM7SUFDRCxNQUFNLEVBQUVFLFNBQVEsRUFBR0MsTUFBSyxFQUFHQyxLQUFJLEVBQUcsR0FBRyxDQUFDLEdBQUdMLFVBQVUsRUFBRU0sU0FBUyxDQUFDTDtJQUMvRCxJQUFJTSxLQUFpQyxFQUFFLEVBUXRDO0lBQ0QsT0FBTyxHQUE2REgsT0FBMUQsQ0FBQyxHQUFHTixvQkFBb0IsRUFBRWEsbUJBQW1CLENBQUNSLFdBQW9CRSxPQUFSRCxPQUFhLE9BQUxDO0FBQ2hGO0FBQ0FWLGtDQUFrQyxHQUFHRTtBQUVyQyxJQUFJLENBQUMsT0FBT0YsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQixNQUFNLENBQUNwQixRQUFRa0IsT0FBTyxFQUFFbEI7SUFDL0JxQixPQUFPckIsT0FBTyxHQUFHQSxRQUFRa0IsT0FBTztBQUNsQyxDQUFDLENBRUQsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcz80YzJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5ub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbnZhciBfcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3BhcnNlUGF0aCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3Qgbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2ggPSAocGF0aCk9PntcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgLCBoYXNoICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgIGlmICgvXFwuW14vXStcXC8/JC8udGVzdChwYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHsoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpfSR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH0gZWxzZSBpZiAocGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3BhdGhuYW1lfSR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7cGF0aG5hbWV9LyR7cXVlcnl9JHtoYXNofWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAkeygwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSl9JHtxdWVyeX0ke2hhc2h9YDtcbn07XG5leHBvcnRzLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2g7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsIl9yZW1vdmVUcmFpbGluZ1NsYXNoIiwicmVxdWlyZSIsIl9wYXJzZVBhdGgiLCJwYXRoIiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwicXVlcnkiLCJoYXNoIiwicGFyc2VQYXRoIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInRlc3QiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZW5kc1dpdGgiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/normalize-trailing-slash.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _addBasePath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _router = __webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\");\nvar _getAssetPathFromRoute = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _isDynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ../shared/lib/router/utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _removeTrailingSlash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ./route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nclass PageLoader {\n    getPageList() {\n        if (false) {} else {\n            if (window.__DEV_PAGES_MANIFEST) {\n                return window.__DEV_PAGES_MANIFEST.pages;\n            } else {\n                this.promisedDevPagesManifest || (this.promisedDevPagesManifest = fetch(\"\".concat(this.assetPrefix, \"/_next/static/development/_devPagesManifest.json\")).then((res)=>res.json()).then((manifest)=>{\n                    window.__DEV_PAGES_MANIFEST = manifest;\n                    return manifest.pages;\n                }).catch((err)=>{\n                    console.log(\"Failed to fetch devPagesManifest:\", err);\n                    throw new Error(\"Failed to fetch _devPagesManifest.json. Is something blocking that network request?\\n\" + \"Read more: https://nextjs.org/docs/messages/failed-to-fetch-devpagesmanifest\");\n                }));\n                return this.promisedDevPagesManifest;\n            }\n        }\n    }\n    getMiddleware() {\n        if (false) {} else {\n            if (window.__DEV_MIDDLEWARE_MATCHERS) {\n                return window.__DEV_MIDDLEWARE_MATCHERS;\n            } else {\n                if (!this.promisedMiddlewareMatchers) {\n                    // TODO: Decide what should happen when fetching fails instead of asserting\n                    // @ts-ignore\n                    this.promisedMiddlewareMatchers = fetch(\"\".concat(this.assetPrefix, \"/_next/static/\").concat(this.buildId, \"/_devMiddlewareManifest.json\")).then((res)=>res.json()).then((matchers)=>{\n                        window.__DEV_MIDDLEWARE_MATCHERS = matchers;\n                        return matchers;\n                    }).catch((err)=>{\n                        console.log(\"Failed to fetch _devMiddlewareManifest\", err);\n                    });\n                }\n                // TODO Remove this assertion as this could be undefined\n                return this.promisedMiddlewareMatchers;\n            }\n        }\n    }\n    getDataHref(params) {\n        const { asPath , href , locale  } = params;\n        const { pathname: hrefPathname , query , search  } = (0, _parseRelativeUrl).parseRelativeUrl(href);\n        const { pathname: asPathname  } = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(hrefPathname);\n        if (route[0] !== \"/\") {\n            throw new Error('Route name should start with a \"/\", got \"'.concat(route, '\"'));\n        }\n        const getHrefForSlug = (path)=>{\n            const dataRoute = (0, _getAssetPathFromRoute).default((0, _removeTrailingSlash).removeTrailingSlash((0, _addLocale).addLocale(path, locale)), \".json\");\n            return (0, _addBasePath).addBasePath(\"/_next/data/\".concat(this.buildId).concat(dataRoute).concat(search), true);\n        };\n        return getHrefForSlug(params.skipInterpolation ? asPathname : (0, _isDynamic).isDynamicRoute(route) ? (0, _router).interpolateAs(hrefPathname, asPathname, query).result : route);\n    }\n    /**\n   * @param {string} route - the route (file-system path)\n   */ _isSsg(route) {\n        return this.promisedSsgManifest.then((manifest)=>manifest.has(route));\n    }\n    loadPage(route) {\n        return this.routeLoader.loadRoute(route).then((res)=>{\n            if (\"component\" in res) {\n                return {\n                    page: res.component,\n                    mod: res.exports,\n                    styleSheets: res.styles.map((o)=>({\n                            href: o.href,\n                            text: o.content\n                        }))\n                };\n            }\n            throw res.error;\n        });\n    }\n    prefetch(route) {\n        return this.routeLoader.prefetch(route);\n    }\n    constructor(buildId, assetPrefix){\n        this.routeLoader = (0, _routeLoader).createRouteLoader(assetPrefix);\n        this.buildId = buildId;\n        this.assetPrefix = assetPrefix;\n        this.promisedSsgManifest = new Promise((resolve)=>{\n            if (window.__SSG_MANIFEST) {\n                resolve(window.__SSG_MANIFEST);\n            } else {\n                window.__SSG_MANIFEST_CB = ()=>{\n                    resolve(window.__SSG_MANIFEST);\n                };\n            }\n        });\n    }\n}\nexports[\"default\"] = PageLoader;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=page-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsMkJBQTJCQyxtSkFBK0Q7QUFDOUYsSUFBSUMsZUFBZUQsbUJBQU9BLENBQUMseUVBQWlCO0FBQzVDLElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDLHlGQUE2QjtBQUNuRCxJQUFJRyx5QkFBeUJKLHlCQUF5QkMsbUJBQU9BLENBQUMsMklBQXNEO0FBQ3BILElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDLG1FQUFjO0FBQ3ZDLElBQUlLLGFBQWFMLG1CQUFPQSxDQUFDLDZHQUF1QztBQUNoRSxJQUFJTSxvQkFBb0JOLG1CQUFPQSxDQUFDLDZIQUErQztBQUMvRSxJQUFJTyx1QkFBdUJQLG1CQUFPQSxDQUFDLG1JQUFrRDtBQUNyRixJQUFJUSxlQUFlUixtQkFBT0EsQ0FBQyx1RUFBZ0I7QUFDM0MsTUFBTVM7SUFDRkMsY0FBYztRQUNWLElBQUlDLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtZQUNILElBQUlLLE9BQU9DLG9CQUFvQixFQUFFO2dCQUM3QixPQUFPRCxPQUFPQyxvQkFBb0IsQ0FBQ0MsS0FBSztZQUM1QyxPQUFPO2dCQUNILElBQUksQ0FBQ0Msd0JBQXdCLElBQUssS0FBSSxDQUFDQSx3QkFBd0IsR0FBR0MsTUFBTSxHQUFvQixPQUFqQixJQUFJLENBQUNDLFdBQVcsRUFBQyxxREFBbURSLElBQUksQ0FBQyxDQUFDUyxNQUFNQSxJQUFJQyxJQUFJLElBQUlWLElBQUksQ0FBQyxDQUFDQyxXQUFXO29CQUNwTEUsT0FBT0Msb0JBQW9CLEdBQUdIO29CQUM5QixPQUFPQSxTQUFTSSxLQUFLO2dCQUN6QixHQUFHTSxLQUFLLENBQUMsQ0FBQ0MsTUFBTTtvQkFDWkMsUUFBUUMsR0FBRyxDQUFFLHFDQUFvQ0Y7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QU87QUFDbEMsQ0FBQyxDQUVELHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcz9lODdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuL2FkZC1iYXNlLXBhdGhcIik7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXJcIik7XG52YXIgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZVwiKSk7XG52YXIgX2FkZExvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG52YXIgX2lzRHluYW1pYyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbnZhciBfcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX3JvdXRlTG9hZGVyID0gcmVxdWlyZShcIi4vcm91dGUtbG9hZGVyXCIpO1xuY2xhc3MgUGFnZUxvYWRlciB7XG4gICAgZ2V0UGFnZUxpc3QoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+bWFuaWZlc3Quc29ydGVkUGFnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuX19ERVZfUEFHRVNfTUFOSUZFU1QucGFnZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0IHx8ICh0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCA9IGZldGNoKGAke3RoaXMuYXNzZXRQcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYCkudGhlbigocmVzKT0+cmVzLmpzb24oKSkudGhlbigobWFuaWZlc3QpPT57XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBkZXZQYWdlc01hbmlmZXN0OmAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIF9kZXZQYWdlc01hbmlmZXN0Lmpzb24uIElzIHNvbWV0aGluZyBibG9ja2luZyB0aGF0IG5ldHdvcmsgcmVxdWVzdD9cXG5gICsgJ1JlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZmFpbGVkLXRvLWZldGNoLWRldnBhZ2VzbWFuaWZlc3QnKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pZGRsZXdhcmUoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBtaWRkbGV3YXJlTWF0Y2hlcnMgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9NQVRDSEVSUztcbiAgICAgICAgICAgIHdpbmRvdy5fX01JRERMRVdBUkVfTUFUQ0hFUlMgPSBtaWRkbGV3YXJlTWF0Y2hlcnMgPyBtaWRkbGV3YXJlTWF0Y2hlcnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Ll9fTUlERExFV0FSRV9NQVRDSEVSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERlY2lkZSB3aGF0IHNob3VsZCBoYXBwZW4gd2hlbiBmZXRjaGluZyBmYWlscyBpbnN0ZWFkIG9mIGFzc2VydGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZWRNaWRkbGV3YXJlTWF0Y2hlcnMgPSBmZXRjaChgJHt0aGlzLmFzc2V0UHJlZml4fS9fbmV4dC9zdGF0aWMvJHt0aGlzLmJ1aWxkSWR9L19kZXZNaWRkbGV3YXJlTWFuaWZlc3QuanNvbmApLnRoZW4oKHJlcyk9PnJlcy5qc29uKCkpLnRoZW4oKG1hdGNoZXJzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFUQ0hFUlMgPSBtYXRjaGVycztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVycztcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWlsZWQgdG8gZmV0Y2ggX2Rldk1pZGRsZXdhcmVNYW5pZmVzdGAsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGFzc2VydGlvbiBhcyB0aGlzIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldERhdGFIcmVmKHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGFzUGF0aCAsIGhyZWYgLCBsb2NhbGUgIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGhyZWZQYXRobmFtZSAsIHF1ZXJ5ICwgc2VhcmNoICB9ID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGhyZWYpO1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKGhyZWZQYXRobmFtZSk7XG4gICAgICAgIGlmIChyb3V0ZVswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSBcIi9cIiwgZ290IFwiJHtyb3V0ZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdldEhyZWZGb3JTbHVnID0gKHBhdGgpPT57XG4gICAgICAgICAgICBjb25zdCBkYXRhUm91dGUgPSAoMCwgX2dldEFzc2V0UGF0aEZyb21Sb3V0ZSkuZGVmYXVsdCgoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2goKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShwYXRoLCBsb2NhbGUpKSwgJy5qc29uJyk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoYC9fbmV4dC9kYXRhLyR7dGhpcy5idWlsZElkfSR7ZGF0YVJvdXRlfSR7c2VhcmNofWAsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ2V0SHJlZkZvclNsdWcocGFyYW1zLnNraXBJbnRlcnBvbGF0aW9uID8gYXNQYXRobmFtZSA6ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZSkgPyAoMCwgX3JvdXRlcikuaW50ZXJwb2xhdGVBcyhocmVmUGF0aG5hbWUsIGFzUGF0aG5hbWUsIHF1ZXJ5KS5yZXN1bHQgOiByb3V0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm91dGUgLSB0aGUgcm91dGUgKGZpbGUtc3lzdGVtIHBhdGgpXG4gICAqLyBfaXNTc2cocm91dGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdC50aGVuKChtYW5pZmVzdCk9Pm1hbmlmZXN0Lmhhcyhyb3V0ZSkpO1xuICAgIH1cbiAgICBsb2FkUGFnZShyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5sb2FkUm91dGUocm91dGUpLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgIGlmICgnY29tcG9uZW50JyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiByZXMuY29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBtb2Q6IHJlcy5leHBvcnRzLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlcy5tYXAoKG8pPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IG8uaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBvLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVmZXRjaChyb3V0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5wcmVmZXRjaChyb3V0ZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkSWQsIGFzc2V0UHJlZml4KXtcbiAgICAgICAgdGhpcy5yb3V0ZUxvYWRlciA9ICgwLCBfcm91dGVMb2FkZXIpLmNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4KTtcbiAgICAgICAgdGhpcy5idWlsZElkID0gYnVpbGRJZDtcbiAgICAgICAgdGhpcy5hc3NldFByZWZpeCA9IGFzc2V0UHJlZml4O1xuICAgICAgICB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgIGlmICh3aW5kb3cuX19TU0dfTUFOSUZFU1QpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5fX1NTR19NQU5JRkVTVF9DQiA9ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQYWdlTG9hZGVyO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9hZGRCYXNlUGF0aCIsIl9yb3V0ZXIiLCJfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiX2FkZExvY2FsZSIsIl9pc0R5bmFtaWMiLCJfcGFyc2VSZWxhdGl2ZVVybCIsIl9yZW1vdmVUcmFpbGluZ1NsYXNoIiwiX3JvdXRlTG9hZGVyIiwiUGFnZUxvYWRlciIsImdldFBhZ2VMaXN0IiwicHJvY2VzcyIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwibWFuaWZlc3QiLCJzb3J0ZWRQYWdlcyIsIndpbmRvdyIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwicGFnZXMiLCJwcm9taXNlZERldlBhZ2VzTWFuaWZlc3QiLCJmZXRjaCIsImFzc2V0UHJlZml4IiwicmVzIiwianNvbiIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImxvZyIsIkVycm9yIiwiZ2V0TWlkZGxld2FyZSIsIm1pZGRsZXdhcmVNYXRjaGVycyIsImVudiIsIl9fTkVYVF9NSURETEVXQVJFX01BVENIRVJTIiwiX19NSURETEVXQVJFX01BVENIRVJTIiwidW5kZWZpbmVkIiwiX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUyIsInByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzIiwiYnVpbGRJZCIsIm1hdGNoZXJzIiwiZ2V0RGF0YUhyZWYiLCJwYXJhbXMiLCJhc1BhdGgiLCJocmVmIiwibG9jYWxlIiwicGF0aG5hbWUiLCJocmVmUGF0aG5hbWUiLCJxdWVyeSIsInNlYXJjaCIsInBhcnNlUmVsYXRpdmVVcmwiLCJhc1BhdGhuYW1lIiwicm91dGUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZ2V0SHJlZkZvclNsdWciLCJwYXRoIiwiZGF0YVJvdXRlIiwiYWRkTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJza2lwSW50ZXJwb2xhdGlvbiIsImlzRHluYW1pY1JvdXRlIiwiaW50ZXJwb2xhdGVBcyIsInJlc3VsdCIsIl9pc1NzZyIsInByb21pc2VkU3NnTWFuaWZlc3QiLCJoYXMiLCJsb2FkUGFnZSIsInJvdXRlTG9hZGVyIiwibG9hZFJvdXRlIiwicGFnZSIsImNvbXBvbmVudCIsIm1vZCIsInN0eWxlU2hlZXRzIiwic3R5bGVzIiwibWFwIiwibyIsInRleHQiLCJjb250ZW50IiwiZXJyb3IiLCJwcmVmZXRjaCIsImNvbnN0cnVjdG9yIiwiY3JlYXRlUm91dGVMb2FkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9fU1NHX01BTklGRVNUIiwiX19TU0dfTUFOSUZFU1RfQ0IiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/page-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\n// copied to prevent pulling in un-necessary utils\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nconst initialHref = location.href;\nlet isRegistered = false;\nlet userReportHandler;\nfunction onReport(metric) {\n    if (userReportHandler) {\n        userReportHandler(metric);\n    }\n    // This code is not shipped, executed, or present in the client-side\n    // JavaScript bundle unless explicitly enabled in your application.\n    //\n    // When this feature is enabled, we'll make it very clear by printing a\n    // message during the build (`next build`).\n    if (false) { var ref; }\n}\nvar _default = (onPerfEntry)=>{\n    // Update function if it changes:\n    userReportHandler = onPerfEntry;\n    // Only register listeners once:\n    if (isRegistered) {\n        return;\n    }\n    isRegistered = true;\n    const attributions = undefined;\n    for (const webVital of WEB_VITALS){\n        try {\n            let mod;\n            if (false) {}\n            if (!mod) {\n                mod = __webpack_require__(/*! next/dist/compiled/web-vitals */ \"./node_modules/next/dist/compiled/web-vitals/web-vitals.js\");\n            }\n            mod[\"on\".concat(webVital)](onReport);\n        } catch (err) {\n            // Do nothing if the module fails to load\n            console.warn(\"Failed to track \".concat(webVital, \" web-vital\"), err);\n        }\n    }\n};\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=performance-relayer.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wZXJmb3JtYW5jZS1yZWxheWVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUcsS0FBSztBQUN2QixrREFBa0Q7QUFDbEQsTUFBTUcsYUFBYTtJQUNmO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsY0FBY0MsU0FBU0MsSUFBSTtBQUNqQyxJQUFJQyxlQUFlLEtBQUs7QUFDeEIsSUFBSUM7QUFDSixTQUFTQyxTQUFTQyxNQUFNLEVBQUU7SUFDdEIsSUFBSUYsbUJBQW1CO1FBQ25CQSxrQkFBa0JFO0lBQ3RCLENBQUM7SUFDRCxvRUFBb0U7SUFDcEUsbUVBQW1FO0lBQ25FLEVBQUU7SUFDRix1RUFBdUU7SUFDdkUsMkNBQTJDO0lBQzNDLElBQUlDLEtBQzJCLEVBQUUsWUFtQ2hDO0FBQ0w7QUFDQSxJQUFJZ0MsV0FBVyxDQUFDQyxjQUFjO0lBQzFCLGlDQUFpQztJQUNqQ3BDLG9CQUFvQm9DO0lBQ3BCLGdDQUFnQztJQUNoQyxJQUFJckMsY0FBYztRQUNkO0lBQ0osQ0FBQztJQUNEQSxlQUFlLElBQUk7SUFDbkIsTUFBTXNDLGVBQWVsQyxTQUF5QztJQUM5RCxLQUFLLE1BQU1vQyxZQUFZNUMsV0FBVztRQUM5QixJQUFJO1lBQ0EsSUFBSTZDO1lBQ0osSUFBSXJDLEtBQTZDLEVBQUUsRUFJbEQ7WUFDRCxJQUFJLENBQUNxQyxLQUFLO2dCQUNOQSxNQUFNRyxtQkFBT0EsQ0FBQztZQUNsQixDQUFDO1lBQ0RILEdBQUcsQ0FBQyxLQUFjLE9BQVRELFVBQVcsQ0FBQ3RDO1FBQ3pCLEVBQUUsT0FBT2lDLEtBQUs7WUFDVix5Q0FBeUM7WUFDekNGLFFBQVFZLElBQUksQ0FBQyxtQkFBNEIsT0FBVEwsVUFBUyxlQUFhTDtRQUMxRDtJQUNKO0FBQ0o7QUFDQTFDLGtCQUFlLEdBQUcyQztBQUVsQixJQUFJLENBQUMsT0FBTzNDLFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ21ELFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkQsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3dELE1BQU0sQ0FBQ3RELFFBQVFFLE9BQU8sRUFBRUY7SUFDL0J1RCxPQUFPdkQsT0FBTyxHQUFHQSxRQUFRRSxPQUFPO0FBQ2xDLENBQUMsQ0FFRCwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcGVyZm9ybWFuY2UtcmVsYXllci5qcz9lZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuLy8gY29waWVkIHRvIHByZXZlbnQgcHVsbGluZyBpbiB1bi1uZWNlc3NhcnkgdXRpbHNcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgJ0NMUycsXG4gICAgJ0ZDUCcsXG4gICAgJ0ZJRCcsXG4gICAgJ0lOUCcsXG4gICAgJ0xDUCcsXG4gICAgJ1RURkInXG5dO1xuY29uc3QgaW5pdGlhbEhyZWYgPSBsb2NhdGlvbi5ocmVmO1xubGV0IGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xubGV0IHVzZXJSZXBvcnRIYW5kbGVyO1xuZnVuY3Rpb24gb25SZXBvcnQobWV0cmljKSB7XG4gICAgaWYgKHVzZXJSZXBvcnRIYW5kbGVyKSB7XG4gICAgICAgIHVzZXJSZXBvcnRIYW5kbGVyKG1ldHJpYyk7XG4gICAgfVxuICAgIC8vIFRoaXMgY29kZSBpcyBub3Qgc2hpcHBlZCwgZXhlY3V0ZWQsIG9yIHByZXNlbnQgaW4gdGhlIGNsaWVudC1zaWRlXG4gICAgLy8gSmF2YVNjcmlwdCBidW5kbGUgdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGlzIGZlYXR1cmUgaXMgZW5hYmxlZCwgd2UnbGwgbWFrZSBpdCB2ZXJ5IGNsZWFyIGJ5IHByaW50aW5nIGFcbiAgICAvLyBtZXNzYWdlIGR1cmluZyB0aGUgYnVpbGQgKGBuZXh0IGJ1aWxkYCkuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgLy8gVGhpcyBmaWVsZCBpcyBlbXB0eSB1bmxlc3MgeW91IGV4cGxpY2l0bHkgY29uZmlndXJlIGl0OlxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9BTkFMWVRJQ1NfSUQpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGRzbjogcHJvY2Vzcy5lbnYuX19ORVhUX0FOQUxZVElDU19JRCxcbiAgICAgICAgICAgIGlkOiBtZXRyaWMuaWQsXG4gICAgICAgICAgICBwYWdlOiAocmVmID0gd2luZG93Ll9fTkVYVF9EQVRBX18pID09IG51bGwgPyB2b2lkIDAgOiByZWYucGFnZSxcbiAgICAgICAgICAgIGhyZWY6IGluaXRpYWxIcmVmLFxuICAgICAgICAgICAgZXZlbnRfbmFtZTogbWV0cmljLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0cmljLnZhbHVlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBzcGVlZDogJ2Nvbm5lY3Rpb24nIGluIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3JbJ2Nvbm5lY3Rpb24nXSAmJiAnZWZmZWN0aXZlVHlwZScgaW4gbmF2aWdhdG9yWydjb25uZWN0aW9uJ10gPyBuYXZpZ2F0b3JbJ2Nvbm5lY3Rpb24nXVsnZWZmZWN0aXZlVHlwZSddIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtcbiAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoYm9keSkudG9TdHJpbmcoKVxuICAgICAgICBdLCB7XG4gICAgICAgICAgICAvLyBUaGlzIGNvbnRlbnQgdHlwZSBpcyBuZWNlc3NhcnkgZm9yIGBzZW5kQmVhY29uYDpcbiAgICAgICAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2aXRhbHNVcmwgPSAnaHR0cHM6Ly92aXRhbHMudmVyY2VsLWluc2lnaHRzLmNvbS92MS92aXRhbHMnO1xuICAgICAgICAvLyBOYXZpZ2F0b3IgaGFzIHRvIGJlIGJvdW5kIHRvIGVuc3VyZSBpdCBkb2VzIG5vdCBlcnJvciBpbiBzb21lIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHBzOi8veGd3YW5nLm1lL3Bvc3RzL3lvdS1tYXktbm90LWtub3ctYmVhY29uLyNpdC1tYXktdGhyb3ctZXJyb3IlMkMtYmUtc3VyZS10by1jYXRjaFxuICAgICAgICBjb25zdCBzZW5kID0gbmF2aWdhdG9yLnNlbmRCZWFjb24gJiYgbmF2aWdhdG9yLnNlbmRCZWFjb24uYmluZChuYXZpZ2F0b3IpO1xuICAgICAgICBmdW5jdGlvbiBmYWxsYmFja1NlbmQoKSB7XG4gICAgICAgICAgICBmZXRjaCh2aXRhbHNVcmwsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBibG9iLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCcsXG4gICAgICAgICAgICAgICAga2VlcGFsaXZlOiB0cnVlXG4gICAgICAgICAgICB9KS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgc2VuZCBpcyB1bmRlZmluZWQgaXQnbGwgdGhyb3cgYXMgd2VsbC4gVGhpcyByZWR1Y2VzIG91dHB1dCBjb2RlIHNpemUuXG4gICAgICAgICAgICBzZW5kKHZpdGFsc1VybCwgYmxvYikgfHwgZmFsbGJhY2tTZW5kKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmFsbGJhY2tTZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgX2RlZmF1bHQgPSAob25QZXJmRW50cnkpPT57XG4gICAgLy8gVXBkYXRlIGZ1bmN0aW9uIGlmIGl0IGNoYW5nZXM6XG4gICAgdXNlclJlcG9ydEhhbmRsZXIgPSBvblBlcmZFbnRyeTtcbiAgICAvLyBPbmx5IHJlZ2lzdGVyIGxpc3RlbmVycyBvbmNlOlxuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIGNvbnN0IGF0dHJpYnV0aW9ucyA9IHByb2Nlc3MuZW52Ll9fTkVYVF9XRUJfVklUQUxTX0FUVFJJQlVUSU9OO1xuICAgIGZvciAoY29uc3Qgd2ViVml0YWwgb2YgV0VCX1ZJVEFMUyl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbW9kO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfV0VCX1ZJVEFMU19BVFRSSUJVVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGF0dHJpYnV0aW9ucy5pbmNsdWRlcyh3ZWJWaXRhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kID0gcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3dlYi12aXRhbHMtYXR0cmlidXRpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vZCkge1xuICAgICAgICAgICAgICAgIG1vZCA9IHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC93ZWItdml0YWxzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb2RbYG9uJHt3ZWJWaXRhbH1gXShvblJlcG9ydCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbW9kdWxlIGZhaWxzIHRvIGxvYWRcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIHRyYWNrICR7d2ViVml0YWx9IHdlYi12aXRhbGAsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlLXJlbGF5ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIldFQl9WSVRBTFMiLCJpbml0aWFsSHJlZiIsImxvY2F0aW9uIiwiaHJlZiIsImlzUmVnaXN0ZXJlZCIsInVzZXJSZXBvcnRIYW5kbGVyIiwib25SZXBvcnQiLCJtZXRyaWMiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0FOQUxZVElDU19JRCIsInJlZiIsImJvZHkiLCJkc24iLCJpZCIsInBhZ2UiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwiZXZlbnRfbmFtZSIsIm5hbWUiLCJ0b1N0cmluZyIsInNwZWVkIiwibmF2aWdhdG9yIiwiYmxvYiIsIkJsb2IiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0eXBlIiwidml0YWxzVXJsIiwic2VuZCIsInNlbmRCZWFjb24iLCJiaW5kIiwiZmFsbGJhY2tTZW5kIiwiZmV0Y2giLCJtZXRob2QiLCJjcmVkZW50aWFscyIsImtlZXBhbGl2ZSIsImNhdGNoIiwiY29uc29sZSIsImVycm9yIiwiZXJyIiwiX2RlZmF1bHQiLCJvblBlcmZFbnRyeSIsImF0dHJpYnV0aW9ucyIsIl9fTkVYVF9XRUJfVklUQUxTX0FUVFJJQlVUSU9OIiwid2ViVml0YWwiLCJtb2QiLCJfX05FWFRfSEFTX1dFQl9WSVRBTFNfQVRUUklCVVRJT04iLCJpbmNsdWRlcyIsInJlcXVpcmUiLCJ3YXJuIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/performance-relayer.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/portal/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/portal/index.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Portal = void 0;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\");\nvar _reactDom = __webpack_require__(/*! react-dom */ \"./node_modules/next/dist/compiled/react-dom/index.js\");\nconst Portal = (param)=>{\n    let { children , type  } = param;\n    _s();\n    const [portalNode, setPortalNode] = (0, _react).useState(null);\n    (0, _react).useEffect(()=>{\n        const element = document.createElement(type);\n        document.body.appendChild(element);\n        setPortalNode(element);\n        return ()=>{\n            document.body.removeChild(element);\n        };\n    }, [\n        type\n    ]);\n    return portalNode ? /*#__PURE__*/ (0, _reactDom).createPortal(children, portalNode) : null;\n};\n_s(Portal, \"RFImm+EuWCdF9gTeRNMrIZMTdTE=\");\n_c = Portal;\nexports.Portal = Portal;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c;\n$RefreshReg$(_c, \"Portal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wb3J0YWwvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGNBQWMsR0FBRyxLQUFLO0FBQ3RCLElBQUlHLFNBQVNDLG1CQUFPQSxDQUFDLCtEQUFPO0FBQzVCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDLHVFQUFXO0FBQ25DLE1BQU1GLFNBQVMsU0FBd0I7UUFBdkIsRUFBRUksU0FBUSxFQUFHQyxLQUFJLEVBQUc7O0lBQ2hDLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHLENBQUMsR0FBR04sTUFBTSxFQUFFTyxRQUFRLENBQUMsSUFBSTtJQUM1RCxJQUFHUCxNQUFNLEVBQUVRLFNBQVMsQ0FBQyxJQUFJO1FBQ3RCLE1BQU1DLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQ1A7UUFDdkNNLFNBQVNFLElBQUksQ0FBQ0MsV0FBVyxDQUFDSjtRQUMxQkgsY0FBY0c7UUFDZCxPQUFPLElBQUk7WUFDUEMsU0FBU0UsSUFBSSxDQUFDRSxXQUFXLENBQUNMO1FBQzlCO0lBQ0osR0FBRztRQUNDTDtLQUNIO0lBQ0QsT0FBT0MsYUFBMkIsV0FBSCxHQUFJLElBQUdILFNBQVMsRUFBRWEsWUFBWSxDQUFDWixVQUFVRSxjQUFjLElBQUk7QUFDOUY7R0FiTU47S0FBQUE7QUFjTkYsY0FBYyxHQUFHRTtBQUVqQixJQUFJLENBQUMsT0FBT0YsUUFBUW1CLE9BQU8sS0FBSyxjQUFlLE9BQU9uQixRQUFRbUIsT0FBTyxLQUFLLFlBQVluQixRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbkIsUUFBUW1CLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDckt0QixPQUFPQyxjQUFjLENBQUNDLFFBQVFtQixPQUFPLEVBQUUsY0FBYztRQUFFbEIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU91QixNQUFNLENBQUNyQixRQUFRbUIsT0FBTyxFQUFFbkI7SUFDL0JzQixPQUFPdEIsT0FBTyxHQUFHQSxRQUFRbUIsT0FBTztBQUNsQyxDQUFDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3BvcnRhbC9pbmRleC5qcz8zMWEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Qb3J0YWwgPSB2b2lkIDA7XG52YXIgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5jb25zdCBQb3J0YWwgPSAoeyBjaGlsZHJlbiAsIHR5cGUgIH0pPT57XG4gICAgY29uc3QgW3BvcnRhbE5vZGUsIHNldFBvcnRhbE5vZGVdID0gKDAsIF9yZWFjdCkudXNlU3RhdGUobnVsbCk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICBzZXRQb3J0YWxOb2RlKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICB0eXBlXG4gICAgXSk7XG4gICAgcmV0dXJuIHBvcnRhbE5vZGUgPyAvKiNfX1BVUkVfXyovICgwLCBfcmVhY3REb20pLmNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsTm9kZSkgOiBudWxsO1xufTtcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJQb3J0YWwiLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlYWN0RG9tIiwiY2hpbGRyZW4iLCJ0eXBlIiwicG9ydGFsTm9kZSIsInNldFBvcnRhbE5vZGUiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImVsZW1lbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVBvcnRhbCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/portal/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-base-path.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-base-path.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeBasePath = removeBasePath;\nvar _hasBasePath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst basePath =  false || \"\";\nfunction removeBasePath(path) {\n    if (false) {}\n    path = path.slice(basePath.length);\n    if (!path.startsWith(\"/\")) path = \"/\".concat(path);\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-base-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHNCQUFzQixHQUFHRTtBQUN6QixJQUFJQyxlQUFlQyxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDNUMsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixlQUFlTyxJQUFJLEVBQUU7SUFDMUIsSUFBSUgsS0FBMEMsRUFBRSxFQUkvQztJQUNERyxPQUFPQSxLQUFLRyxLQUFLLENBQUNQLFNBQVNRLE1BQU07SUFDakMsSUFBSSxDQUFDSixLQUFLSyxVQUFVLENBQUMsTUFBTUwsT0FBTyxJQUFTLE9BQUxBO0lBQ3RDLE9BQU9BO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT1QsUUFBUWUsT0FBTyxLQUFLLGNBQWUsT0FBT2YsUUFBUWUsT0FBTyxLQUFLLFlBQVlmLFFBQVFlLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2YsUUFBUWUsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2xCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWUsT0FBTyxFQUFFLGNBQWM7UUFBRWQsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9tQixNQUFNLENBQUNqQixRQUFRZSxPQUFPLEVBQUVmO0lBQy9Ca0IsT0FBT2xCLE9BQU8sR0FBR0EsUUFBUWUsT0FBTztBQUNsQyxDQUFDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlbW92ZS1iYXNlLXBhdGguanM/YjRmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlQmFzZVBhdGggPSByZW1vdmVCYXNlUGF0aDtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi9oYXMtYmFzZS1wYXRoXCIpO1xuY29uc3QgYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuZnVuY3Rpb24gcmVtb3ZlQmFzZVBhdGgocGF0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfTUFOVUFMX0NMSUVOVF9CQVNFX1BBVEgpIHtcbiAgICAgICAgaWYgKCEoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKTtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YDtcbiAgICByZXR1cm4gcGF0aDtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLWJhc2UtcGF0aC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZW1vdmVCYXNlUGF0aCIsIl9oYXNCYXNlUGF0aCIsInJlcXVpcmUiLCJiYXNlUGF0aCIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwicGF0aCIsIl9fTkVYVF9NQU5VQUxfQ0xJRU5UX0JBU0VfUEFUSCIsImhhc0Jhc2VQYXRoIiwic2xpY2UiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-base-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/remove-locale.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/remove-locale.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeLocale = removeLocale;\nvar _parsePath = __webpack_require__(/*! ../shared/lib/router/utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction removeLocale(path, locale) {\n    if (false) {}\n    return path;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=remove-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZW1vdmUtbG9jYWxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELG9CQUFvQixHQUFHRTtBQUN2QixJQUFJQyxhQUFhQyxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDaEUsU0FBU0YsYUFBYUcsSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDaEMsSUFBSUMsS0FBK0IsRUFBRSxFQUtwQztJQUNELE9BQU9GO0FBQ1g7QUFFQSxJQUFJLENBQUMsT0FBT0wsUUFBUWtCLE9BQU8sS0FBSyxjQUFlLE9BQU9sQixRQUFRa0IsT0FBTyxLQUFLLFlBQVlsQixRQUFRa0IsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPbEIsUUFBUWtCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktyQixPQUFPQyxjQUFjLENBQUNDLFFBQVFrQixPQUFPLEVBQUUsY0FBYztRQUFFakIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zQixNQUFNLENBQUNwQixRQUFRa0IsT0FBTyxFQUFFbEI7SUFDL0JxQixPQUFPckIsT0FBTyxHQUFHQSxRQUFRa0IsT0FBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JlbW92ZS1sb2NhbGUuanM/NDc1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVtb3ZlTG9jYWxlID0gcmVtb3ZlTG9jYWxlO1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIHJlbW92ZUxvY2FsZShwYXRoLCBsb2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChwYXRoKTtcbiAgICAgICAgY29uc3QgcGF0aExvd2VyID0gcGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlTG93ZXIgPSBsb2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlICYmIChwYXRoTG93ZXIuc3RhcnRzV2l0aChgLyR7bG9jYWxlTG93ZXJ9L2ApIHx8IHBhdGhMb3dlciA9PT0gYC8ke2xvY2FsZUxvd2VyfWApID8gYCR7cGF0aG5hbWUubGVuZ3RoID09PSBsb2NhbGUubGVuZ3RoICsgMSA/IGAvYCA6IGBgfSR7cGF0aC5zbGljZShsb2NhbGUubGVuZ3RoICsgMSl9YCA6IHBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmUtbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlbW92ZUxvY2FsZSIsIl9wYXJzZVBhdGgiLCJyZXF1aXJlIiwicGF0aCIsImxvY2FsZSIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwicGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJwYXRoTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImxvY2FsZUxvd2VyIiwic3RhcnRzV2l0aCIsImxlbmd0aCIsInNsaWNlIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/remove-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.cancelIdleCallback = exports.requestIdleCallback = void 0;\nconst requestIdleCallback = typeof self !== \"undefined\" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {\n    let start = Date.now();\n    return setTimeout(function() {\n        cb({\n            didTimeout: false,\n            timeRemaining: function() {\n                return Math.max(0, 50 - (Date.now() - start));\n            }\n        });\n    }, 1);\n};\nexports.requestIdleCallback = requestIdleCallback;\nconst cancelIdleCallback = typeof self !== \"undefined\" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {\n    return clearTimeout(id);\n};\nexports.cancelIdleCallback = cancelIdleCallback;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=request-idle-callback.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDaEUsTUFBTUcsc0JBQXNCLE9BQU9DLFNBQVMsZUFBZUEsS0FBS0QsbUJBQW1CLElBQUlDLEtBQUtELG1CQUFtQixDQUFDRSxJQUFJLENBQUNDLFdBQVcsU0FBU0MsRUFBRSxFQUFFO0lBQ3pJLElBQUlDLFFBQVFDLEtBQUtDLEdBQUc7SUFDcEIsT0FBT0MsV0FBVyxXQUFXO1FBQ3pCSixHQUFHO1lBQ0NLLFlBQVksS0FBSztZQUNqQkMsZUFBZSxXQUFXO2dCQUN0QixPQUFPQyxLQUFLQyxHQUFHLENBQUMsR0FBRyxLQUFNTixDQUFBQSxLQUFLQyxHQUFHLEtBQUtGLEtBQUk7WUFDOUM7UUFDSjtJQUNKLEdBQUc7QUFDUDtBQUNBUiwyQkFBMkIsR0FBR0c7QUFDOUIsTUFBTUQscUJBQXFCLE9BQU9FLFNBQVMsZUFBZUEsS0FBS0Ysa0JBQWtCLElBQUlFLEtBQUtGLGtCQUFrQixDQUFDRyxJQUFJLENBQUNDLFdBQVcsU0FBU1UsRUFBRSxFQUFFO0lBQ3RJLE9BQU9DLGFBQWFEO0FBQ3hCO0FBQ0FoQiwwQkFBMEIsR0FBR0U7QUFFN0IsSUFBSSxDQUFDLE9BQU9GLFFBQVFrQixPQUFPLEtBQUssY0FBZSxPQUFPbEIsUUFBUWtCLE9BQU8sS0FBSyxZQUFZbEIsUUFBUWtCLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2xCLFFBQVFrQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLckIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRa0IsT0FBTyxFQUFFLGNBQWM7UUFBRWpCLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPc0IsTUFBTSxDQUFDcEIsUUFBUWtCLE9BQU8sRUFBRWxCO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUWtCLE9BQU87QUFDbEMsQ0FBQyxDQUVELGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanM/MWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FuY2VsSWRsZUNhbGxiYWNrID0gZXhwb3J0cy5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gdm9pZCAwO1xuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLnJlcXVlc3RJZGxlQ2FsbGJhY2sgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihjYikge1xuICAgIGxldCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNiKHtcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIDUwIC0gKERhdGUubm93KCkgLSBzdGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCAxKTtcbn07XG5leHBvcnRzLnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSByZXF1ZXN0SWRsZUNhbGxiYWNrO1xuY29uc3QgY2FuY2VsSWRsZUNhbGxiYWNrID0gdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrICYmIHNlbGYuY2FuY2VsSWRsZUNhbGxiYWNrLmJpbmQod2luZG93KSB8fCBmdW5jdGlvbihpZCkge1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQoaWQpO1xufTtcbmV4cG9ydHMuY2FuY2VsSWRsZUNhbGxiYWNrID0gY2FuY2VsSWRsZUNhbGxiYWNrO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LWlkbGUtY2FsbGJhY2suanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNlbGYiLCJiaW5kIiwid2luZG93IiwiY2IiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJzZXRUaW1lb3V0IiwiZGlkVGltZW91dCIsInRpbWVSZW1haW5pbmciLCJNYXRoIiwibWF4IiwiaWQiLCJjbGVhclRpbWVvdXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/request-idle-callback.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/route-announcer.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/route-announcer.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = exports.RouteAnnouncer = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nconst nextjsRouteAnnouncerStyles = {\n    border: 0,\n    clip: \"rect(0 0 0 0)\",\n    height: \"1px\",\n    margin: \"-1px\",\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"absolute\",\n    width: \"1px\",\n    // https://medium.com/@jessebeach/beware-smushed-off-screen-accessible-text-5952a4c2cbfe\n    whiteSpace: \"nowrap\",\n    wordWrap: \"normal\"\n};\nconst RouteAnnouncer = ()=>{\n    _s();\n    const { asPath  } = (0, _router).useRouter();\n    const [routeAnnouncement, setRouteAnnouncement] = _react.default.useState(\"\");\n    // Only announce the path change, but not for the first load because screen\n    // reader will do that automatically.\n    const previouslyLoadedPath = _react.default.useRef(asPath);\n    // Every time the path changes, announce the new page’s title following this\n    // priority: first the document title (from head), otherwise the first h1, or\n    // if none of these exist, then the pathname from the URL. This methodology is\n    // inspired by Marcy Sutton’s accessible client routing user testing. More\n    // information can be found here:\n    // https://www.gatsbyjs.com/blog/2019-07-11-user-testing-accessible-client-routing/\n    _react.default.useEffect(()=>{\n        // If the path hasn't change, we do nothing.\n        if (previouslyLoadedPath.current === asPath) return;\n        previouslyLoadedPath.current = asPath;\n        if (document.title) {\n            setRouteAnnouncement(document.title);\n        } else {\n            const pageHeader = document.querySelector(\"h1\");\n            var ref;\n            const content = (ref = pageHeader == null ? void 0 : pageHeader.innerText) != null ? ref : pageHeader == null ? void 0 : pageHeader.textContent;\n            setRouteAnnouncement(content || asPath);\n        }\n    }, [\n        asPath\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(\"p\", {\n        \"aria-live\": \"assertive\" // Make the announcement immediately.\n        ,\n        id: \"__next-route-announcer__\",\n        role: \"alert\",\n        style: nextjsRouteAnnouncerStyles\n    }, routeAnnouncement);\n};\n_s(RouteAnnouncer, \"XmDOMcfEgRlT21GulgLTmCStecg=\");\n_c = RouteAnnouncer;\nexports.RouteAnnouncer = RouteAnnouncer;\nvar _default = RouteAnnouncer;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-announcer.js.map\nvar _c;\n$RefreshReg$(_c, \"RouteAnnouncer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1hbm5vdW5jZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDaEQsSUFBSUksMkJBQTJCQyxtSkFBK0Q7QUFDOUYsSUFBSUMsU0FBU0YseUJBQXlCQyxtQkFBT0EsQ0FBQywrREFBTztBQUNyRCxJQUFJRSxVQUFVRixtQkFBT0EsQ0FBQywyREFBVTtBQUNoQyxNQUFNRyw2QkFBNkI7SUFDL0JDLFFBQVE7SUFDUkMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsT0FBTztJQUNQLHdGQUF3RjtJQUN4RkMsWUFBWTtJQUNaQyxVQUFVO0FBQ2Q7QUFDQSxNQUFNZixpQkFBaUIsSUFBSTs7SUFDdkIsTUFBTSxFQUFFZ0IsT0FBTSxFQUFHLEdBQUcsQ0FBQyxHQUFHWixPQUFPLEVBQUVhLFNBQVM7SUFDMUMsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHaEIsT0FBT0osT0FBTyxDQUFDcUIsUUFBUSxDQUFDO0lBQzFFLDJFQUEyRTtJQUMzRSxxQ0FBcUM7SUFDckMsTUFBTUMsdUJBQXVCbEIsT0FBT0osT0FBTyxDQUFDdUIsTUFBTSxDQUFDTjtJQUNuRCw0RUFBNEU7SUFDNUUsNkVBQTZFO0lBQzdFLDhFQUE4RTtJQUM5RSwwRUFBMEU7SUFDMUUsaUNBQWlDO0lBQ2pDLG1GQUFtRjtJQUNuRmIsT0FBT0osT0FBTyxDQUFDd0IsU0FBUyxDQUFDLElBQUk7UUFDekIsNENBQTRDO1FBQzVDLElBQUlGLHFCQUFxQkcsT0FBTyxLQUFLUixRQUFRO1FBQzdDSyxxQkFBcUJHLE9BQU8sR0FBR1I7UUFDL0IsSUFBSVMsU0FBU0MsS0FBSyxFQUFFO1lBQ2hCUCxxQkFBcUJNLFNBQVNDLEtBQUs7UUFDdkMsT0FBTztZQUNILE1BQU1DLGFBQWFGLFNBQVNHLGFBQWEsQ0FBQztZQUMxQyxJQUFJQztZQUNKLE1BQU1DLFVBQVUsQ0FBQ0QsTUFBTUYsY0FBYyxJQUFJLEdBQUcsS0FBSyxJQUFJQSxXQUFXSSxTQUFTLEtBQUssSUFBSSxHQUFHRixNQUFNRixjQUFjLElBQUksR0FBRyxLQUFLLElBQUlBLFdBQVdLLFdBQVc7WUFDL0liLHFCQUFxQlcsV0FBV2Q7UUFDcEMsQ0FBQztJQUNMLEdBQ0E7UUFDSUE7S0FDSDtJQUNELE9BQU8sV0FBVyxHQUFHYixPQUFPSixPQUFPLENBQUNrQyxhQUFhLENBQUMsS0FBSztRQUNuRCxhQUFhLFlBQVkscUNBQXFDOztRQUU5REMsSUFBSTtRQUNKQyxNQUFNO1FBQ05DLE9BQU8vQjtJQUNYLEdBQUdhO0FBQ1A7R0FuQ01sQjtLQUFBQTtBQW9DTkgsc0JBQXNCLEdBQUdHO0FBQ3pCLElBQUlxQyxXQUFXckM7QUFDZkgsa0JBQWUsR0FBR3dDO0FBRWxCLElBQUksQ0FBQyxPQUFPeEMsUUFBUUUsT0FBTyxLQUFLLGNBQWUsT0FBT0YsUUFBUUUsT0FBTyxLQUFLLFlBQVlGLFFBQVFFLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0YsUUFBUUUsT0FBTyxDQUFDdUMsVUFBVSxLQUFLLGFBQWE7SUFDckszQyxPQUFPQyxjQUFjLENBQUNDLFFBQVFFLE9BQU8sRUFBRSxjQUFjO1FBQUVELE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPNEMsTUFBTSxDQUFDMUMsUUFBUUUsT0FBTyxFQUFFRjtJQUMvQjJDLE9BQU8zQyxPQUFPLEdBQUdBLFFBQVFFLE9BQU87QUFDbEMsQ0FBQyxDQUVELDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1hbm5vdW5jZXIuanM/NTgyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuUm91dGVBbm5vdW5jZXIgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX3JvdXRlciA9IHJlcXVpcmUoXCIuL3JvdXRlclwiKTtcbmNvbnN0IG5leHRqc1JvdXRlQW5ub3VuY2VyU3R5bGVzID0ge1xuICAgIGJvcmRlcjogMCxcbiAgICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICAgaGVpZ2h0OiAnMXB4JyxcbiAgICBtYXJnaW46ICctMXB4JyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICB3aWR0aDogJzFweCcsXG4gICAgLy8gaHR0cHM6Ly9tZWRpdW0uY29tL0BqZXNzZWJlYWNoL2Jld2FyZS1zbXVzaGVkLW9mZi1zY3JlZW4tYWNjZXNzaWJsZS10ZXh0LTU5NTJhNGMyY2JmZVxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHdvcmRXcmFwOiAnbm9ybWFsJ1xufTtcbmNvbnN0IFJvdXRlQW5ub3VuY2VyID0gKCk9PntcbiAgICBjb25zdCB7IGFzUGF0aCAgfSA9ICgwLCBfcm91dGVyKS51c2VSb3V0ZXIoKTtcbiAgICBjb25zdCBbcm91dGVBbm5vdW5jZW1lbnQsIHNldFJvdXRlQW5ub3VuY2VtZW50XSA9IF9yZWFjdC5kZWZhdWx0LnVzZVN0YXRlKCcnKTtcbiAgICAvLyBPbmx5IGFubm91bmNlIHRoZSBwYXRoIGNoYW5nZSwgYnV0IG5vdCBmb3IgdGhlIGZpcnN0IGxvYWQgYmVjYXVzZSBzY3JlZW5cbiAgICAvLyByZWFkZXIgd2lsbCBkbyB0aGF0IGF1dG9tYXRpY2FsbHkuXG4gICAgY29uc3QgcHJldmlvdXNseUxvYWRlZFBhdGggPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXNQYXRoKTtcbiAgICAvLyBFdmVyeSB0aW1lIHRoZSBwYXRoIGNoYW5nZXMsIGFubm91bmNlIHRoZSBuZXcgcGFnZeKAmXMgdGl0bGUgZm9sbG93aW5nIHRoaXNcbiAgICAvLyBwcmlvcml0eTogZmlyc3QgdGhlIGRvY3VtZW50IHRpdGxlIChmcm9tIGhlYWQpLCBvdGhlcndpc2UgdGhlIGZpcnN0IGgxLCBvclxuICAgIC8vIGlmIG5vbmUgb2YgdGhlc2UgZXhpc3QsIHRoZW4gdGhlIHBhdGhuYW1lIGZyb20gdGhlIFVSTC4gVGhpcyBtZXRob2RvbG9neSBpc1xuICAgIC8vIGluc3BpcmVkIGJ5IE1hcmN5IFN1dHRvbuKAmXMgYWNjZXNzaWJsZSBjbGllbnQgcm91dGluZyB1c2VyIHRlc3RpbmcuIE1vcmVcbiAgICAvLyBpbmZvcm1hdGlvbiBjYW4gYmUgZm91bmQgaGVyZTpcbiAgICAvLyBodHRwczovL3d3dy5nYXRzYnlqcy5jb20vYmxvZy8yMDE5LTA3LTExLXVzZXItdGVzdGluZy1hY2Nlc3NpYmxlLWNsaWVudC1yb3V0aW5nL1xuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgcGF0aCBoYXNuJ3QgY2hhbmdlLCB3ZSBkbyBub3RoaW5nLlxuICAgICAgICBpZiAocHJldmlvdXNseUxvYWRlZFBhdGguY3VycmVudCA9PT0gYXNQYXRoKSByZXR1cm47XG4gICAgICAgIHByZXZpb3VzbHlMb2FkZWRQYXRoLmN1cnJlbnQgPSBhc1BhdGg7XG4gICAgICAgIGlmIChkb2N1bWVudC50aXRsZSkge1xuICAgICAgICAgICAgc2V0Um91dGVBbm5vdW5jZW1lbnQoZG9jdW1lbnQudGl0bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFnZUhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gxJyk7XG4gICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IChyZWYgPSBwYWdlSGVhZGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlSGVhZGVyLmlubmVyVGV4dCkgIT0gbnVsbCA/IHJlZiA6IHBhZ2VIZWFkZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VIZWFkZXIudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBzZXRSb3V0ZUFubm91bmNlbWVudChjb250ZW50IHx8IGFzUGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCAvLyBUT0RPOiBzd2l0Y2ggdG8gcGF0aG5hbWUgKyBxdWVyeSBvYmplY3Qgb2YgZHluYW1pYyByb3V0ZSByZXF1aXJlbWVudHNcbiAgICBbXG4gICAgICAgIGFzUGF0aFxuICAgIF0pO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICAgICAgXCJhcmlhLWxpdmVcIjogXCJhc3NlcnRpdmVcIiAvLyBNYWtlIHRoZSBhbm5vdW5jZW1lbnQgaW1tZWRpYXRlbHkuXG4gICAgICAgICxcbiAgICAgICAgaWQ6IFwiX19uZXh0LXJvdXRlLWFubm91bmNlcl9fXCIsXG4gICAgICAgIHJvbGU6IFwiYWxlcnRcIixcbiAgICAgICAgc3R5bGU6IG5leHRqc1JvdXRlQW5ub3VuY2VyU3R5bGVzXG4gICAgfSwgcm91dGVBbm5vdW5jZW1lbnQpO1xufTtcbmV4cG9ydHMuUm91dGVBbm5vdW5jZXIgPSBSb3V0ZUFubm91bmNlcjtcbnZhciBfZGVmYXVsdCA9IFJvdXRlQW5ub3VuY2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlLWFubm91bmNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiUm91dGVBbm5vdW5jZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiX3JvdXRlciIsIm5leHRqc1JvdXRlQW5ub3VuY2VyU3R5bGVzIiwiYm9yZGVyIiwiY2xpcCIsImhlaWdodCIsIm1hcmdpbiIsIm92ZXJmbG93IiwicGFkZGluZyIsInBvc2l0aW9uIiwid2lkdGgiLCJ3aGl0ZVNwYWNlIiwid29yZFdyYXAiLCJhc1BhdGgiLCJ1c2VSb3V0ZXIiLCJyb3V0ZUFubm91bmNlbWVudCIsInNldFJvdXRlQW5ub3VuY2VtZW50IiwidXNlU3RhdGUiLCJwcmV2aW91c2x5TG9hZGVkUGF0aCIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJkb2N1bWVudCIsInRpdGxlIiwicGFnZUhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWYiLCJjb250ZW50IiwiaW5uZXJUZXh0IiwidGV4dENvbnRlbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJyb2xlIiwic3R5bGUiLCJfZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-announcer.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _getAssetPathFromRoute = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nvar _trustedTypes = __webpack_require__(/*! ./trusted-types */ \"./node_modules/next/dist/client/trusted-types.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if (\"future\" in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator() // eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nconst ASSET_LOAD_ERROR = Symbol(\"ASSET_LOAD_ERROR\");\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement(\"link\");\n        return(// with relList.support\n        !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports(\"prefetch\"));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((resolve, reject)=>{\n        const selector = '\\n      link[rel=\"prefetch\"][href^=\"'.concat(href, '\"],\\n      link[rel=\"preload\"][href^=\"').concat(href, '\"],\\n      script[src^=\"').concat(href, '\"]');\n        if (document.querySelector(selector)) {\n            return resolve();\n        }\n        link = document.createElement(\"link\");\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = resolve;\n        link.onerror = ()=>reject(markAssetError(new Error(\"Failed to prefetch: \".concat(href))));\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement(\"script\");\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(\"Failed to load script: \".concat(src))));\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms));\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Failed to load client build manifest\")));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        const scriptUrl = assetPrefix + \"/_next/static/chunks/pages\" + encodeURI((0, _getAssetPathFromRoute).default(route, \".js\"));\n        return Promise.resolve({\n            scripts: [\n                (0, _trustedTypes).__unsafeCreateTrustedScriptURL(scriptUrl)\n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \".concat(route)));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + \"/_next/\" + encodeURI(entry));\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith(\".js\")).map((v)=>(0, _trustedTypes).__unsafeCreateTrustedScriptURL(v)),\n            css: allFiles.filter((v)=>v.endsWith(\".css\"))\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) {} else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \".concat(href));\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                }));\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()).then((exports1)=>({\n                    component: exports1 && exports1.default || exports1,\n                    exports: exports1\n                }), (err)=>({\n                    error: err\n                })) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && \"resolve\" in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then((param)=>{\n                    let { scripts , css  } = param;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet))\n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        }));\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \".concat(route)))).then((param)=>{\n                    let { entrypoint , styles  } = param;\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return \"error\" in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script.toString(), \"script\")) : [])).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{}));\n            }).catch(()=>{});\n        }\n    };\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCRixvQkFBb0IsR0FBR0c7QUFDdkJILDhCQUE4QixHQUFHSTtBQUNqQ0oseUJBQXlCLEdBQUdLO0FBQzVCLElBQUlDLDJCQUEyQkMsbUpBQStEO0FBQzlGLElBQUlFLHlCQUF5QkgseUJBQXlCQyxtQkFBT0EsQ0FBQywySUFBc0Q7QUFDcEgsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQyx5RUFBaUI7QUFDN0MsSUFBSUksdUJBQXVCSixtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDNUQsdUVBQXVFO0FBQ3ZFLHlFQUF5RTtBQUN6RSwyRUFBMkU7QUFDM0Usb0NBQW9DO0FBQ3BDLE1BQU1LLG9CQUFvQjtBQUMxQixTQUFTQyxXQUFXQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsU0FBUyxFQUFFO0lBQ3JDLElBQUlDLFFBQVFGLElBQUlHLEdBQUcsQ0FBQ0o7SUFDcEIsSUFBSUcsT0FBTztRQUNQLElBQUksWUFBWUEsT0FBTztZQUNuQixPQUFPQSxNQUFNRSxNQUFNO1FBQ3ZCLENBQUM7UUFDRCxPQUFPQyxRQUFRQyxPQUFPLENBQUNKO0lBQzNCLENBQUM7SUFDRCxJQUFJSztJQUNKLE1BQU1DLE9BQU8sSUFBSUgsUUFBUSxDQUFDQyxVQUFVO1FBQ2hDQyxXQUFXRDtJQUNmO0lBQ0FOLElBQUlTLEdBQUcsQ0FBQ1YsS0FBS0csUUFBUTtRQUNqQkksU0FBU0M7UUFDVEgsUUFBUUk7SUFDWjtJQUNBLE9BQU9QLFlBQVlBLFlBQVcsd0NBQXdDO0tBQ3JFUyxJQUFJLENBQUMsQ0FBQ3hCLFFBQVNxQixDQUFBQSxTQUFTckIsUUFBUUEsS0FBSyxHQUFHeUIsS0FBSyxDQUFDLENBQUNDLE1BQU07UUFDbERaLElBQUlhLE1BQU0sQ0FBQ2Q7UUFDWCxNQUFNYSxJQUFJO0lBQ2QsS0FBS0osSUFBSTtBQUNiO0FBQ0EsTUFBTU0sbUJBQW1CQyxPQUFPO0FBQ2hDLFNBQVM1QixlQUFleUIsR0FBRyxFQUFFO0lBQ3pCLE9BQU83QixPQUFPQyxjQUFjLENBQUM0QixLQUFLRSxrQkFBa0IsQ0FBQztBQUN6RDtBQUNBLFNBQVMxQixhQUFhd0IsR0FBRyxFQUFFO0lBQ3ZCLE9BQU9BLE9BQU9FLG9CQUFvQkY7QUFDdEM7QUFDQSxTQUFTSSxZQUFZQyxJQUFJLEVBQUU7SUFDdkIsSUFBSTtRQUNBQSxPQUFPQyxTQUFTQyxhQUFhLENBQUM7UUFDOUIsT0FFQSx1QkFEdUI7UUFDdEIsQ0FBQyxDQUFDQyxPQUFPQyxvQkFBb0IsSUFBSSxDQUFDLENBQUNILFNBQVNJLFlBQVksSUFBS0wsS0FBS00sT0FBTyxDQUFDQyxRQUFRLENBQUM7SUFDeEYsRUFBRSxPQUFPQyxHQUFHO1FBQ1IsT0FBTyxLQUFLO0lBQ2hCO0FBQ0o7QUFDQSxNQUFNQyxjQUFjVjtBQUNwQixTQUFTVyxlQUFlQyxJQUFJLEVBQUVDLEVBQUUsRUFBRVosSUFBSSxFQUFFO0lBQ3BDLE9BQU8sSUFBSVosUUFBUSxDQUFDQyxTQUFTd0IsU0FBUztRQUNsQyxNQUFNQyxXQUFXLHVDQUVVSCxPQURDQSxNQUFLLDBDQUVwQkEsT0FEY0EsTUFBSyw0QkFDZCxPQUFMQSxNQUFLO1FBQ2xCLElBQUlWLFNBQVNjLGFBQWEsQ0FBQ0QsV0FBVztZQUNsQyxPQUFPekI7UUFDWCxDQUFDO1FBQ0RXLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztRQUM5Qix3REFBd0Q7UUFDeEQsSUFBSVUsSUFBSVosS0FBS1ksRUFBRSxHQUFHQTtRQUNsQlosS0FBS2dCLEdBQUcsR0FBSTtRQUNaaEIsS0FBS2lCLFdBQVcsR0FBR0MsU0FBK0I7UUFDbERsQixLQUFLcUIsTUFBTSxHQUFHaEM7UUFDZFcsS0FBS3NCLE9BQU8sR0FBRyxJQUFJVCxPQUFPM0MsZUFBZSxJQUFJcUQsTUFBTSx1QkFBNEIsT0FBTFo7UUFDMUUsZ0NBQWdDO1FBQ2hDWCxLQUFLVyxJQUFJLEdBQUdBO1FBQ1pWLFNBQVN1QixJQUFJLENBQUNDLFdBQVcsQ0FBQ3pCO0lBQzlCO0FBQ0o7QUFDQSxTQUFTMEIsYUFBYUMsR0FBRyxFQUFFQyxNQUFNLEVBQUU7SUFDL0IsT0FBTyxJQUFJeEMsUUFBUSxDQUFDQyxTQUFTd0IsU0FBUztRQUNsQ2UsU0FBUzNCLFNBQVNDLGFBQWEsQ0FBQztRQUNoQyx3REFBd0Q7UUFDeEQsbUVBQW1FO1FBQ25FLGlDQUFpQztRQUNqQzBCLE9BQU9QLE1BQU0sR0FBR2hDO1FBQ2hCdUMsT0FBT04sT0FBTyxHQUFHLElBQUlULE9BQU8zQyxlQUFlLElBQUlxRCxNQUFNLDBCQUE4QixPQUFKSTtRQUMvRSwyRUFBMkU7UUFDM0UsOEJBQThCO1FBQzlCQyxPQUFPWCxXQUFXLEdBQUdDLFNBQStCO1FBQ3BELHVFQUF1RTtRQUN2RSw2Q0FBNkM7UUFDN0NVLE9BQU9ELEdBQUcsR0FBR0E7UUFDYjFCLFNBQVM0QixJQUFJLENBQUNKLFdBQVcsQ0FBQ0c7SUFDOUI7QUFDSjtBQUNBLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsSUFBSUU7QUFDSix1RUFBdUU7QUFDdkUsU0FBU0MsMEJBQTBCQyxDQUFDLEVBQUVDLEVBQUUsRUFBRXRDLEdBQUcsRUFBRTtJQUMzQyxPQUFPLElBQUlQLFFBQVEsQ0FBQ0MsU0FBU3dCLFNBQVM7UUFDbEMsSUFBSXFCLFlBQVksS0FBSztRQUNyQkYsRUFBRXZDLElBQUksQ0FBQyxDQUFDMEMsSUFBSTtZQUNSLCtCQUErQjtZQUMvQkQsWUFBWSxJQUFJO1lBQ2hCN0MsUUFBUThDO1FBQ1osR0FBR3pDLEtBQUssQ0FBQ21CO1FBQ1Qsc0VBQXNFO1FBQ3RFLHNCQUFzQjtRQUN0QixJQUFJSyxJQUF5QixFQUFlO1lBQ3ZDWSxDQUFBQSxtQkFBbUIxQyxRQUFRQyxPQUFPLEVBQUMsRUFBR0ksSUFBSSxDQUFDLElBQUk7Z0JBQzNDLElBQUdkLG9CQUFvQixFQUFFeUQsbUJBQW1CLENBQUMsSUFBSUMsV0FBVyxJQUFJO3dCQUN6RCxJQUFJLENBQUNILFdBQVc7NEJBQ1pyQixPQUFPbEI7d0JBQ1gsQ0FBQztvQkFDTCxHQUFHc0M7WUFDWDtRQUNKLENBQUM7UUFDRCxJQUFJZixLQUF5QixFQUFlLEVBTTNDO0lBQ0w7QUFDSjtBQUNBLFNBQVM5Qyx5QkFBeUI7SUFDOUIsSUFBSWtFLEtBQUtDLGdCQUFnQixFQUFFO1FBQ3ZCLE9BQU9uRCxRQUFRQyxPQUFPLENBQUNpRCxLQUFLQyxnQkFBZ0I7SUFDaEQsQ0FBQztJQUNELE1BQU1DLGtCQUFrQixJQUFJcEQsUUFBUSxDQUFDQyxVQUFVO1FBQzNDLGlEQUFpRDtRQUNqRCxNQUFNb0QsS0FBS0gsS0FBS0ksbUJBQW1CO1FBQ25DSixLQUFLSSxtQkFBbUIsR0FBRyxJQUFJO1lBQzNCckQsUUFBUWlELEtBQUtDLGdCQUFnQjtZQUM3QkUsTUFBTUE7UUFDVjtJQUNKO0lBQ0EsT0FBT1YsMEJBQTBCUyxpQkFBaUI1RCxtQkFBbUJWLGVBQWUsSUFBSXFELE1BQU07QUFDbEc7QUFDQSxTQUFTb0IsaUJBQWlCQyxXQUFXLEVBQUVDLEtBQUssRUFBRTtJQUMxQyxJQUFJM0IsSUFBeUIsRUFBZTtRQUN4QyxNQUFNNEIsWUFBWUYsY0FBYywrQkFBK0JHLFVBQVUsQ0FBQyxHQUFHdEUsc0JBQXNCLEVBQUVELE9BQU8sQ0FBQ3FFLE9BQU87UUFDcEgsT0FBT3pELFFBQVFDLE9BQU8sQ0FBQztZQUNuQjJELFNBQVM7Z0JBQ0osSUFBR3RFLGFBQWEsRUFBRXVFLDhCQUE4QixDQUFDSDthQUNyRDtZQUNELHVEQUF1RDtZQUN2REksS0FBSyxFQUFFO1FBQ1g7SUFDSixDQUFDO0lBQ0QsT0FBTzlFLHlCQUF5QnFCLElBQUksQ0FBQyxDQUFDMEQsV0FBVztRQUM3QyxJQUFJLENBQUVOLENBQUFBLFNBQVNNLFFBQU8sR0FBSTtZQUN0QixNQUFNakYsZUFBZSxJQUFJcUQsTUFBTSwyQkFBaUMsT0FBTnNCLFNBQVU7UUFDeEUsQ0FBQztRQUNELE1BQU1PLFdBQVdELFFBQVEsQ0FBQ04sTUFBTSxDQUFDOUQsR0FBRyxDQUFDLENBQUNFLFFBQVEyRCxjQUFjLFlBQVlHLFVBQVU5RDtRQUNsRixPQUFPO1lBQ0grRCxTQUFTSSxTQUFTQyxNQUFNLENBQUMsQ0FBQ0MsSUFBSUEsRUFBRUMsUUFBUSxDQUFDLFFBQVF4RSxHQUFHLENBQUMsQ0FBQ3VFLElBQUksQ0FBQyxHQUFHNUUsYUFBYSxFQUFFdUUsOEJBQThCLENBQUNLO1lBQzVHSixLQUFLRSxTQUFTQyxNQUFNLENBQUMsQ0FBQ0MsSUFBSUEsRUFBRUMsUUFBUSxDQUFDO1FBQ3pDO0lBQ0o7QUFDSjtBQUNBLFNBQVNsRixrQkFBa0J1RSxXQUFXLEVBQUU7SUFDcEMsTUFBTVksY0FBYyxJQUFJQztJQUN4QixNQUFNQyxnQkFBZ0IsSUFBSUQ7SUFDMUIsTUFBTUUsY0FBYyxJQUFJRjtJQUN4QixNQUFNRyxTQUFTLElBQUlIO0lBQ25CLFNBQVNJLG1CQUFtQmxDLEdBQUcsRUFBRTtRQUM3QiwyREFBMkQ7UUFDM0Qsa0VBQWtFO1FBQ2xFLGNBQWM7UUFDZCxJQUFJVCxLQUF5QixFQUFlLEVBVzNDLE1BQU07WUFDSCxPQUFPUSxhQUFhQztRQUN4QixDQUFDO0lBQ0w7SUFDQSxTQUFTb0MsZ0JBQWdCcEQsSUFBSSxFQUFFO1FBQzNCLElBQUlwQixPQUFPb0UsWUFBWXpFLEdBQUcsQ0FBQ3lCO1FBQzNCLElBQUlwQixNQUFNO1lBQ04sT0FBT0E7UUFDWCxDQUFDO1FBQ0RvRSxZQUFZbkUsR0FBRyxDQUFDbUIsTUFBTXBCLE9BQU95RSxNQUFNckQsTUFBTWxCLElBQUksQ0FBQyxDQUFDd0UsTUFBTTtZQUNqRCxJQUFJLENBQUNBLElBQUlDLEVBQUUsRUFBRTtnQkFDVCxNQUFNLElBQUkzQyxNQUFNLDhCQUFtQyxPQUFMWixPQUFRO1lBQzFELENBQUM7WUFDRCxPQUFPc0QsSUFBSUUsSUFBSSxHQUFHMUUsSUFBSSxDQUFDLENBQUMwRSxPQUFRO29CQUN4QnhELE1BQU1BO29CQUNOeUQsU0FBU0Q7Z0JBQ2I7UUFDUixHQUFHekUsS0FBSyxDQUFDLENBQUNDLE1BQU07WUFDWixNQUFNekIsZUFBZXlCLEtBQUs7UUFDOUI7UUFDQSxPQUFPSjtJQUNYO0lBQ0EsT0FBTztRQUNIOEUsZ0JBQWdCeEIsS0FBSyxFQUFFO1lBQ25CLE9BQU9oRSxXQUFXZ0UsT0FBT1c7UUFDN0I7UUFDQWMsY0FBY3pCLEtBQUssRUFBRTBCLE9BQU8sRUFBRTtZQUN6QkEsQ0FBQUEsVUFBVW5GLFFBQVFDLE9BQU8sR0FBR0ksSUFBSSxDQUFDLElBQUk4RSxXQUFXOUUsSUFBSSxDQUFDLENBQUN6QixXQUFXO29CQUMxRHdHLFdBQVd4RyxZQUFXQSxTQUFRUSxPQUFPLElBQUlSO29CQUN6Q0EsU0FBU0E7Z0JBQ2IsSUFBSSxDQUFDMkIsTUFBTztvQkFDUjhFLE9BQU85RTtnQkFDWCxNQUFNUCxRQUFRQyxPQUFPLENBQUNxRixVQUFVLEVBQUVqRixJQUFJLENBQUMsQ0FBQ2tGLFFBQVE7Z0JBQ2hELE1BQU1DLE1BQU1wQixZQUFZdEUsR0FBRyxDQUFDMkQ7Z0JBQzVCLElBQUkrQixPQUFPLGFBQWFBLEtBQUs7b0JBQ3pCLElBQUlELE9BQU87d0JBQ1BuQixZQUFZaEUsR0FBRyxDQUFDcUQsT0FBTzhCO3dCQUN2QkMsSUFBSXZGLE9BQU8sQ0FBQ3NGO29CQUNoQixDQUFDO2dCQUNMLE9BQU87b0JBQ0gsSUFBSUEsT0FBTzt3QkFDUG5CLFlBQVloRSxHQUFHLENBQUNxRCxPQUFPOEI7b0JBQzNCLE9BQU87d0JBQ0huQixZQUFZNUQsTUFBTSxDQUFDaUQ7b0JBQ3ZCLENBQUM7b0JBQ0QsZ0RBQWdEO29CQUNoRCxrREFBa0Q7b0JBQ2xELG1CQUFtQjtvQkFDbkJlLE9BQU9oRSxNQUFNLENBQUNpRDtnQkFDbEIsQ0FBQztZQUNMO1FBQ0o7UUFDQWdDLFdBQVdoQyxLQUFLLEVBQUVpQyxRQUFRLEVBQUU7WUFDeEIsT0FBT2pHLFdBQVdnRSxPQUFPZSxRQUFRLElBQUk7Z0JBQ2pDLElBQUltQjtnQkFDSixJQUFJN0QsSUFBeUIsRUFBZTtvQkFDeENZLGtCQUFrQixJQUFJMUMsUUFBUSxDQUFDQyxVQUFVO3dCQUNyQzBGLHlCQUF5QjFGO29CQUM3QjtnQkFDSixDQUFDO2dCQUNELE9BQU8wQywwQkFBMEJZLGlCQUFpQkMsYUFBYUMsT0FBT3BELElBQUksQ0FBQyxTQUFzQjt3QkFBckIsRUFBRXVELFFBQU8sRUFBR0UsSUFBRyxFQUFHO29CQUMxRixPQUFPOUQsUUFBUTRGLEdBQUcsQ0FBQzt3QkFDZnhCLFlBQVl5QixHQUFHLENBQUNwQyxTQUFTLEVBQUUsR0FBR3pELFFBQVE0RixHQUFHLENBQUNoQyxRQUFRakUsR0FBRyxDQUFDOEUsb0JBQW9CO3dCQUMxRXpFLFFBQVE0RixHQUFHLENBQUM5QixJQUFJbkUsR0FBRyxDQUFDZ0Y7cUJBQ3ZCO2dCQUNMLEdBQUd0RSxJQUFJLENBQUMsQ0FBQ3dFLE1BQU07b0JBQ1gsT0FBTyxJQUFJLENBQUNJLGNBQWMsQ0FBQ3hCLE9BQU9wRCxJQUFJLENBQUMsQ0FBQ3lGLGFBQWM7NEJBQzlDQTs0QkFDQUMsUUFBUWxCLEdBQUcsQ0FBQyxFQUFFO3dCQUNsQjtnQkFDUixJQUFJckYsbUJBQW1CVixlQUFlLElBQUlxRCxNQUFNLG1DQUF5QyxPQUFOc0IsVUFBV3BELElBQUksQ0FBQyxTQUE0Qjt3QkFBM0IsRUFBRXlGLFdBQVUsRUFBR0MsT0FBTSxFQUFHO29CQUN4SCxNQUFNbEIsTUFBTW5HLE9BQU9zSCxNQUFNLENBQUM7d0JBQ3RCRCxRQUFRQTtvQkFDWixHQUFHRDtvQkFDSCxPQUFPLFdBQVdBLGFBQWFBLGFBQWFqQixHQUFHO2dCQUNuRCxHQUFHdkUsS0FBSyxDQUFDLENBQUNDLE1BQU07b0JBQ1osSUFBSW1GLFVBQVU7d0JBQ1YsZ0RBQWdEO3dCQUNoRCxNQUFNbkYsSUFBSTtvQkFDZCxDQUFDO29CQUNELE9BQU87d0JBQ0g4RSxPQUFPOUU7b0JBQ1g7Z0JBQ0osR0FBRzBGLE9BQU8sQ0FBQyxJQUFJO29CQUNYLE9BQU9OLDBCQUEwQixJQUFJLEdBQUcsS0FBSyxJQUFJQSx3QkFBd0I7Z0JBQzdFO1lBQ0o7UUFDSjtRQUNBRCxVQUFVakMsS0FBSyxFQUFFO1lBQ2Isc0hBQXNIO1lBQ3RILHNCQUFzQjtZQUN0QixJQUFJeUM7WUFDSixJQUFJQSxLQUFLQyxVQUFVQyxVQUFVLEVBQUU7Z0JBQzNCLHlEQUF5RDtnQkFDekQsSUFBSUYsR0FBR0csUUFBUSxJQUFJLEtBQUtDLElBQUksQ0FBQ0osR0FBR0ssYUFBYSxHQUFHLE9BQU92RyxRQUFRQyxPQUFPO1lBQzFFLENBQUM7WUFDRCxPQUFPc0QsaUJBQWlCQyxhQUFhQyxPQUFPcEQsSUFBSSxDQUFDLENBQUNtRyxTQUFTeEcsUUFBUTRGLEdBQUcsQ0FBQ3ZFLGNBQWNtRixPQUFPNUMsT0FBTyxDQUFDakUsR0FBRyxDQUFDLENBQUM2QyxTQUFTbEIsZUFBZWtCLE9BQU9rQyxRQUFRLElBQUksYUFBYSxFQUFFLEdBQUdyRSxJQUFJLENBQUMsSUFBSTtnQkFDMUssSUFBR2Qsb0JBQW9CLEVBQUV5RCxtQkFBbUIsQ0FBQyxJQUFJLElBQUksQ0FBQ3lDLFNBQVMsQ0FBQ2hDLE9BQU8sSUFBSSxFQUFFbkQsS0FBSyxDQUFDLElBQUksQ0FBQztZQUM3RixHQUFHQSxLQUFLLENBQ1IsSUFBSSxDQUFDO1FBQ1Q7SUFDSjtBQUNKO0FBRUEsSUFBSSxDQUFDLE9BQU8xQixRQUFRUSxPQUFPLEtBQUssY0FBZSxPQUFPUixRQUFRUSxPQUFPLEtBQUssWUFBWVIsUUFBUVEsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPUixRQUFRUSxPQUFPLENBQUNxSCxVQUFVLEtBQUssYUFBYTtJQUNySy9ILE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUVEsT0FBTyxFQUFFLGNBQWM7UUFBRVAsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9zSCxNQUFNLENBQUNwSCxRQUFRUSxPQUFPLEVBQUVSO0lBQy9COEgsT0FBTzlILE9BQU8sR0FBR0EsUUFBUVEsT0FBTztBQUNsQyxDQUFDLENBRUQsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlLWxvYWRlci5qcz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5tYXJrQXNzZXRFcnJvciA9IG1hcmtBc3NldEVycm9yO1xuZXhwb3J0cy5pc0Fzc2V0RXJyb3IgPSBpc0Fzc2V0RXJyb3I7XG5leHBvcnRzLmdldENsaWVudEJ1aWxkTWFuaWZlc3QgPSBnZXRDbGllbnRCdWlsZE1hbmlmZXN0O1xuZXhwb3J0cy5jcmVhdGVSb3V0ZUxvYWRlciA9IGNyZWF0ZVJvdXRlTG9hZGVyO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9nZXRBc3NldFBhdGhGcm9tUm91dGUgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGVcIikpO1xudmFyIF90cnVzdGVkVHlwZXMgPSByZXF1aXJlKFwiLi90cnVzdGVkLXR5cGVzXCIpO1xudmFyIF9yZXF1ZXN0SWRsZUNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMDtcbmZ1bmN0aW9uIHdpdGhGdXR1cmUoa2V5LCBtYXAsIGdlbmVyYXRvcikge1xuICAgIGxldCBlbnRyeSA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKCdmdXR1cmUnIGluIGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZnV0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW50cnkpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZXI7XG4gICAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+e1xuICAgICAgICByZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgbWFwLnNldChrZXksIGVudHJ5ID0ge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlcixcbiAgICAgICAgZnV0dXJlOiBwcm9tXG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvciA/IGdlbmVyYXRvcigpLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgIC50aGVuKCh2YWx1ZSk9PihyZXNvbHZlcih2YWx1ZSksIHZhbHVlKSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfSkgOiBwcm9tO1xufVxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpO1xuZnVuY3Rpb24gbWFya0Fzc2V0RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIEFTU0VUX0xPQURfRVJST1IsIHt9KTtcbn1cbmZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyO1xufVxuZnVuY3Rpb24gaGFzUHJlZmV0Y2gobGluaykge1xuICAgIHRyeSB7XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIHJldHVybigvLyBkZXRlY3QgSUUxMSBzaW5jZSBpdCBzdXBwb3J0cyBwcmVmZXRjaCBidXQgaXNuJ3QgZGV0ZWN0ZWRcbiAgICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICAgKCEhd2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB8fCBsaW5rLnJlbExpc3Quc3VwcG9ydHMoJ3ByZWZldGNoJykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNvbnN0IGNhblByZWZldGNoID0gaGFzUHJlZmV0Y2goKTtcbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKGhyZWYsIGFzLCBsaW5rKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gYFxuICAgICAgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBsaW5rW3JlbD1cInByZWxvYWRcIl1baHJlZl49XCIke2hyZWZ9XCJdLFxuICAgICAgc2NyaXB0W3NyY149XCIke2hyZWZ9XCJdYDtcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7XG4gICAgICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgICAgIGlmIChhcykgbGluay5hcyA9IGFzO1xuICAgICAgICBsaW5rLnJlbCA9IGBwcmVmZXRjaGA7XG4gICAgICAgIGxpbmsuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOO1xuICAgICAgICBsaW5rLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGxpbmsub25lcnJvciA9ICgpPT5yZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gcHJlZmV0Y2g6ICR7aHJlZn1gKSkpO1xuICAgICAgICAvLyBgaHJlZmAgc2hvdWxkIGFsd2F5cyBiZSBsYXN0OlxuICAgICAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXBwZW5kU2NyaXB0KHNyYywgc2NyaXB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgICAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vICAgIGV4ZWN1dGVzIHdoZW4gYHNyY2AgaXMgc2V0LlxuICAgICAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSAoKT0+cmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc2NyaXB0OiAke3NyY31gKSkpO1xuICAgICAgICAvLyAyLiBDb25maWd1cmUgdGhlIGNyb3NzLW9yaWdpbiBhdHRyaWJ1dGUgYmVmb3JlIHNldHRpbmcgYHNyY2AgaW4gY2FzZSB0aGVcbiAgICAgICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXG4gICAgICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU47XG4gICAgICAgIC8vIDMuIEZpbmFsbHksIHNldCB0aGUgc291cmNlIGFuZCBpbmplY3QgaW50byB0aGUgRE9NIGluIGNhc2UgdGhlIGNoaWxkXG4gICAgICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxuICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgfSk7XG59XG4vLyBXZSB3YWl0IGZvciBwYWdlcyB0byBiZSBidWlsdCBpbiBkZXYgYmVmb3JlIHdlIHN0YXJ0IHRoZSByb3V0ZSB0cmFuc2l0aW9uXG4vLyB0aW1lb3V0IHRvIHByZXZlbnQgYW4gdW4tbmVjZXNzYXJ5IGhhcmQgbmF2aWdhdGlvbiBpbiBkZXZlbG9wbWVudC5cbmxldCBkZXZCdWlsZFByb21pc2U7XG4vLyBSZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHRpbWVzIG91dCBhZnRlciBnaXZlbiBhbW91bnQgb2YgbWlsbGlzZWNvbmRzLlxuZnVuY3Rpb24gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChwLCBtcywgZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcC50aGVuKChyKT0+e1xuICAgICAgICAgICAgLy8gUmVzb2x2ZWQsIGNhbmNlbCB0aGUgdGltZW91dFxuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUocik7XG4gICAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIC8vIFdlIHdyYXAgdGhlc2UgY2hlY2tzIHNlcGFyYXRlbHkgZm9yIGJldHRlciBkZWFkLWNvZGUgZWxpbWluYXRpb24gaW5cbiAgICAgICAgLy8gcHJvZHVjdGlvbiBidW5kbGVzLlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIChkZXZCdWlsZFByb21pc2UgfHwgUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIG1zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+c2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBtcykpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkge1xuICAgIGlmIChzZWxmLl9fQlVJTERfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpO1xuICAgIH1cbiAgICBjb25zdCBvbkJ1aWxkTWFuaWZlc3QgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgICAgICBjb25zdCBjYiA9IHNlbGYuX19CVUlMRF9NQU5JRkVTVF9DQjtcbiAgICAgICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCk9PntcbiAgICAgICAgICAgIHJlc29sdmUoc2VsZi5fX0JVSUxEX01BTklGRVNUKTtcbiAgICAgICAgICAgIGNiICYmIGNiKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQob25CdWlsZE1hbmlmZXN0LCBNU19NQVhfSURMRV9ERUxBWSwgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSkpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0VXJsID0gYXNzZXRQcmVmaXggKyAnL19uZXh0L3N0YXRpYy9jaHVua3MvcGFnZXMnICsgZW5jb2RlVVJJKCgwLCBfZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKS5kZWZhdWx0KHJvdXRlLCAnLmpzJykpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgICAgICAgICAoMCwgX3RydXN0ZWRUeXBlcykuX191bnNhZmVDcmVhdGVUcnVzdGVkU2NyaXB0VVJMKHNjcmlwdFVybClcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICAgICAgICBjc3M6IFtdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KT0+e1xuICAgICAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgICAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKChlbnRyeSk9PmFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJKGVudHJ5KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY3JpcHRzOiBhbGxGaWxlcy5maWx0ZXIoKHYpPT52LmVuZHNXaXRoKCcuanMnKSkubWFwKCh2KT0+KDAsIF90cnVzdGVkVHlwZXMpLl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCh2KSksXG4gICAgICAgICAgICBjc3M6IGFsbEZpbGVzLmZpbHRlcigodik9PnYuZW5kc1dpdGgoJy5jc3MnKSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4KSB7XG4gICAgY29uc3QgZW50cnlwb2ludHMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbG9hZGVkU2NyaXB0cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzdHlsZVNoZWV0cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCByb3V0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gbWF5YmVFeGVjdXRlU2NyaXB0KHNyYykge1xuICAgICAgICAvLyBXaXRoIEhNUiB3ZSBtaWdodCBuZWVkIHRvIFwicmVsb2FkXCIgc2NyaXB0cyB3aGVuIHRoZXkgYXJlXG4gICAgICAgIC8vIGRpc3Bvc2VkIGFuZCByZWFkZGVkLiBFeGVjdXRpbmcgc2NyaXB0cyB0d2ljZSBoYXMgbm8gZnVuY3Rpb25hbFxuICAgICAgICAvLyBkaWZmZXJlbmNlc1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGxldCBwcm9tID0gbG9hZGVkU2NyaXB0cy5nZXQoc3JjLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9hZGVkU2NyaXB0cy5zZXQoc3JjLnRvU3RyaW5nKCksIHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBlbmRTY3JpcHQoc3JjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmZXRjaFN0eWxlU2hlZXQoaHJlZikge1xuICAgICAgICBsZXQgcHJvbSA9IHN0eWxlU2hlZXRzLmdldChocmVmKTtcbiAgICAgICAgaWYgKHByb20pIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlU2hlZXRzLnNldChocmVmLCBwcm9tID0gZmV0Y2goaHJlZikudGhlbigocmVzKT0+e1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0eWxlc2hlZXQ6ICR7aHJlZn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpPT4oe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB0ZXh0XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcHJvbTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2hlbkVudHJ5cG9pbnQgKHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgZW50cnlwb2ludHMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVudHJ5cG9pbnQgKHJvdXRlLCBleGVjdXRlKSB7XG4gICAgICAgICAgICAoZXhlY3V0ZSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmV4ZWN1dGUoKSkudGhlbigoZXhwb3J0cyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogZXhwb3J0cyAmJiBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogZXhwb3J0c1xuICAgICAgICAgICAgICAgIH0pLCAoZXJyKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgICAgIH0pKSA6IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpKS50aGVuKChpbnB1dCk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2xkLnJlc29sdmUoaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeXBvaW50cy5zZXQocm91dGUsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByb3V0ZSBpcyBvdXRkYXRlZCBhbmQgd2Ugd2FudCB0byBpbnZhbGlkYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FjaGUgZW50cnlcbiAgICAgICAgICAgICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvYWRSb3V0ZSAocm91dGUsIHByZWZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZ1dHVyZShyb3V0ZSwgcm91dGVzLCAoKT0+e1xuICAgICAgICAgICAgICAgIGxldCBkZXZCdWlsZFByb21pc2VSZXNvbHZlO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldkJ1aWxkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKHsgc2NyaXB0cyAsIGNzcyAgfSk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSkgPyBbXSA6IFByb21pc2UuYWxsKHNjcmlwdHMubWFwKG1heWJlRXhlY3V0ZVNjcmlwdCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSwgXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHJlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2hlbkVudHJ5cG9pbnQocm91dGUpLnRoZW4oKGVudHJ5cG9pbnQpPT4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSwgTVNfTUFYX0lETEVfREVMQVksIG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgUm91dGUgZGlkIG5vdCBjb21wbGV0ZSBsb2FkaW5nOiAke3JvdXRlfWApKSkudGhlbigoeyBlbnRyeXBvaW50ICwgc3R5bGVzICB9KT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczogc3R5bGVzXG4gICAgICAgICAgICAgICAgICAgIH0sIGVudHJ5cG9pbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiBlbnRyeXBvaW50ID8gZW50cnlwb2ludCA6IHJlcztcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgZXJyb3JzIGR1cmluZyBwcmVmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkuZmluYWxseSgoKT0+e1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9PSBudWxsID8gdm9pZCAwIDogZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChyb3V0ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuICAgICAgICAgICAgLy8gTGljZW5zZTogQXBhY2hlIDIuMFxuICAgICAgICAgICAgbGV0IGNuO1xuICAgICAgICAgICAgaWYgKGNuID0gbmF2aWdhdG9yLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAoY24uc2F2ZURhdGEgfHwgLzJnLy50ZXN0KGNuLmVmZmVjdGl2ZVR5cGUpKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpLnRoZW4oKG91dHB1dCk9PlByb21pc2UuYWxsKGNhblByZWZldGNoID8gb3V0cHV0LnNjcmlwdHMubWFwKChzY3JpcHQpPT5wcmVmZXRjaFZpYURvbShzY3JpcHQudG9TdHJpbmcoKSwgJ3NjcmlwdCcpKSA6IFtdKSkudGhlbigoKT0+e1xuICAgICAgICAgICAgICAgICgwLCBfcmVxdWVzdElkbGVDYWxsYmFjaykucmVxdWVzdElkbGVDYWxsYmFjaygoKT0+dGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpPT57fSkpO1xuICAgICAgICAgICAgfSkuY2F0Y2goLy8gc3dhbGxvdyBwcmVmZXRjaCBlcnJvcnNcbiAgICAgICAgICAgICgpPT57fSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZS1sb2FkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFya0Fzc2V0RXJyb3IiLCJpc0Fzc2V0RXJyb3IiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiY3JlYXRlUm91dGVMb2FkZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9nZXRBc3NldFBhdGhGcm9tUm91dGUiLCJfdHJ1c3RlZFR5cGVzIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJNU19NQVhfSURMRV9ERUxBWSIsIndpdGhGdXR1cmUiLCJrZXkiLCJtYXAiLCJnZW5lcmF0b3IiLCJlbnRyeSIsImdldCIsImZ1dHVyZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzb2x2ZXIiLCJwcm9tIiwic2V0IiwidGhlbiIsImNhdGNoIiwiZXJyIiwiZGVsZXRlIiwiQVNTRVRfTE9BRF9FUlJPUiIsIlN5bWJvbCIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiZSIsImNhblByZWZldGNoIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZWplY3QiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiYXBwZW5kU2NyaXB0Iiwic3JjIiwic2NyaXB0IiwiYm9keSIsImRldkJ1aWxkUHJvbWlzZSIsInJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQiLCJwIiwibXMiLCJjYW5jZWxsZWQiLCJyIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInNldFRpbWVvdXQiLCJzZWxmIiwiX19CVUlMRF9NQU5JRkVTVCIsIm9uQnVpbGRNYW5pZmVzdCIsImNiIiwiX19CVUlMRF9NQU5JRkVTVF9DQiIsImdldEZpbGVzRm9yUm91dGUiLCJhc3NldFByZWZpeCIsInJvdXRlIiwic2NyaXB0VXJsIiwiZW5jb2RlVVJJIiwic2NyaXB0cyIsIl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJlbnRyeXBvaW50cyIsIk1hcCIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsIm1heWJlRXhlY3V0ZVNjcmlwdCIsInRvU3RyaW5nIiwiZmV0Y2hTdHlsZVNoZWV0IiwiZmV0Y2giLCJyZXMiLCJvayIsInRleHQiLCJjb250ZW50Iiwid2hlbkVudHJ5cG9pbnQiLCJvbkVudHJ5cG9pbnQiLCJleGVjdXRlIiwiY29tcG9uZW50IiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJpbnB1dCIsIm9sZCIsImxvYWRSb3V0ZSIsInByZWZldGNoIiwiZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSIsImFsbCIsImhhcyIsImVudHJ5cG9pbnQiLCJzdHlsZXMiLCJhc3NpZ24iLCJmaW5hbGx5IiwiY24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2F2ZURhdGEiLCJ0ZXN0IiwiZWZmZWN0aXZlVHlwZSIsIm91dHB1dCIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Router\", ({\n    enumerable: true,\n    get: function() {\n        return _router.default;\n    }\n}));\nObject.defineProperty(exports, \"withRouter\", ({\n    enumerable: true,\n    get: function() {\n        return _withRouter.default;\n    }\n}));\nexports.useRouter = useRouter;\nexports.createRouter = createRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _router = _interop_require_default(__webpack_require__(/*! ../shared/lib/router/router */ \"./node_modules/next/dist/shared/lib/router/router.js\"));\nvar _routerContext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nvar _isError = _interop_require_default(__webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _withRouter = _interop_require_default(__webpack_require__(/*! ./with-router */ \"./node_modules/next/dist/client/with-router.js\"));\nconst singletonRouter = {\n    router: null,\n    readyCallbacks: [],\n    ready (cb) {\n        if (this.router) return cb();\n        if (true) {\n            this.readyCallbacks.push(cb);\n        }\n    }\n};\n// Create public properties and methods of the router in the singletonRouter\nconst urlPropertyFields = [\n    \"pathname\",\n    \"route\",\n    \"query\",\n    \"asPath\",\n    \"components\",\n    \"isFallback\",\n    \"basePath\",\n    \"locale\",\n    \"locales\",\n    \"defaultLocale\",\n    \"isReady\",\n    \"isPreview\",\n    \"isLocaleDomain\",\n    \"domainLocales\"\n];\nconst routerEvents = [\n    \"routeChangeStart\",\n    \"beforeHistoryChange\",\n    \"routeChangeComplete\",\n    \"routeChangeError\",\n    \"hashChangeStart\",\n    \"hashChangeComplete\"\n];\nconst coreMethodFields = [\n    \"push\",\n    \"replace\",\n    \"reload\",\n    \"back\",\n    \"prefetch\",\n    \"beforePopState\"\n];\n// Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, \"events\", {\n    get () {\n        return _router.default.events;\n    }\n});\nfunction getRouter() {\n    if (!singletonRouter.router) {\n        const message = \"No router instance found.\\n\" + 'You should only use \"next/router\" on the client side of your app.\\n';\n        throw new Error(message);\n    }\n    return singletonRouter.router;\n}\nurlPropertyFields.forEach((field)=>{\n    // Here we need to use Object.defineProperty because we need to return\n    // the property assigned to the actual router\n    // The value might get changed as we change routes and this is the\n    // proper way to access it\n    Object.defineProperty(singletonRouter, field, {\n        get () {\n            const router = getRouter();\n            return router[field];\n        }\n    });\n});\ncoreMethodFields.forEach((field)=>{\n    singletonRouter[field] = function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const router = getRouter();\n        return router[field](...args);\n    };\n});\nrouterEvents.forEach((event)=>{\n    singletonRouter.ready(()=>{\n        _router.default.events.on(event, function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const eventField = \"on\".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));\n            const _singletonRouter = singletonRouter;\n            if (_singletonRouter[eventField]) {\n                try {\n                    _singletonRouter[eventField](...args);\n                } catch (err) {\n                    console.error(\"Error when running the Router event: \".concat(eventField));\n                    console.error((0, _isError).default(err) ? \"\".concat(err.message, \"\\n\").concat(err.stack) : err + \"\");\n                }\n            }\n        });\n    });\n});\nvar _default = singletonRouter;\nexports[\"default\"] = _default;\nfunction useRouter() {\n    _s();\n    const router = _react.default.useContext(_routerContext.RouterContext);\n    if (!router) {\n        throw new Error(\"Error: NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted\");\n    }\n    return router;\n}\n_s(useRouter, \"rbAhEc3dLGnVlsHWaSDsgP4MZS0=\");\nfunction createRouter() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    singletonRouter.router = new _router.default(...args);\n    singletonRouter.readyCallbacks.forEach((cb)=>cb());\n    singletonRouter.readyCallbacks = [];\n    return singletonRouter.router;\n}\nfunction makePublicRouterInstance(router) {\n    const scopedRouter = router;\n    const instance = {};\n    for (const property of urlPropertyFields){\n        if (typeof scopedRouter[property] === \"object\") {\n            instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]) // makes sure query is not stateful\n            ;\n            continue;\n        }\n        instance[property] = scopedRouter[property];\n    }\n    // Events is a static property on the router, the router doesn't have to be initialized to use it\n    instance.events = _router.default.events;\n    coreMethodFields.forEach((field)=>{\n        instance[field] = function() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            return scopedRouter[field](...args);\n        };\n    });\n    return instance;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILDBDQUF5QztJQUNyQ0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyxRQUFRQyxPQUFPO0lBQzFCO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZQLDhDQUE2QztJQUN6Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPRyxZQUFZRCxPQUFPO0lBQzlCO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZMLGlCQUFpQixHQUFHTztBQUNwQlAsb0JBQW9CLEdBQUdRO0FBQ3ZCUixnQ0FBZ0MsR0FBR1M7QUFDbkNULGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJVSwyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxTQUFTRix5QkFBeUJDLG1CQUFPQSxDQUFDLCtEQUFPO0FBQ3JELElBQUlQLFVBQVVNLHlCQUF5QkMsbUJBQU9BLENBQUMseUZBQTZCO0FBQzVFLElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUMsMkZBQThCO0FBQzNELElBQUlHLFdBQVdKLHlCQUF5QkMsbUJBQU9BLENBQUMsaUVBQWlCO0FBQ2pFLElBQUlMLGNBQWNJLHlCQUF5QkMsbUJBQU9BLENBQUMscUVBQWU7QUFDbEUsTUFBTUksa0JBQWtCO0lBQ3BCQyxRQUFRLElBQUk7SUFDWkMsZ0JBQWdCLEVBQUU7SUFDbEJDLE9BQU9DLEVBQUUsRUFBRTtRQUNQLElBQUksSUFBSSxDQUFDSCxNQUFNLEVBQUUsT0FBT0c7UUFDeEIsSUFBSSxJQUFrQixFQUFhO1lBQy9CLElBQUksQ0FBQ0YsY0FBYyxDQUFDRyxJQUFJLENBQUNEO1FBQzdCLENBQUM7SUFDTDtBQUNKO0FBQ0EsNEVBQTRFO0FBQzVFLE1BQU1FLG9CQUFvQjtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxlQUFlO0lBQ2pCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsbUJBQW1CO0lBQ3JCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsaUdBQWlHO0FBQ2pHekIsT0FBT0MsY0FBYyxDQUFDZ0IsaUJBQWlCLFVBQVU7SUFDN0NaLE9BQU87UUFDSCxPQUFPQyxRQUFRQyxPQUFPLENBQUNtQixNQUFNO0lBQ2pDO0FBQ0o7QUFDQSxTQUFTQyxZQUFZO0lBQ2pCLElBQUksQ0FBQ1YsZ0JBQWdCQyxNQUFNLEVBQUU7UUFDekIsTUFBTVUsVUFBVSxnQ0FBZ0M7UUFDaEQsTUFBTSxJQUFJQyxNQUFNRCxTQUFTO0lBQzdCLENBQUM7SUFDRCxPQUFPWCxnQkFBZ0JDLE1BQU07QUFDakM7QUFDQUssa0JBQWtCTyxPQUFPLENBQUMsQ0FBQ0MsUUFBUTtJQUMvQixzRUFBc0U7SUFDdEUsNkNBQTZDO0lBQzdDLGtFQUFrRTtJQUNsRSwwQkFBMEI7SUFDMUIvQixPQUFPQyxjQUFjLENBQUNnQixpQkFBaUJjLE9BQU87UUFDMUMxQixPQUFPO1lBQ0gsTUFBTWEsU0FBU1M7WUFDZixPQUFPVCxNQUFNLENBQUNhLE1BQU07UUFDeEI7SUFDSjtBQUNKO0FBQ0FOLGlCQUFpQkssT0FBTyxDQUFDLENBQUNDLFFBQVE7SUFDOUJkLGVBQWUsQ0FBQ2MsTUFBTSxHQUFHLFdBQVc7eUNBQVBDO1lBQUFBOztRQUN6QixNQUFNZCxTQUFTUztRQUNmLE9BQU9ULE1BQU0sQ0FBQ2EsTUFBTSxJQUFJQztJQUM1QjtBQUNKO0FBQ0FSLGFBQWFNLE9BQU8sQ0FBQyxDQUFDRyxRQUFRO0lBQzFCaEIsZ0JBQWdCRyxLQUFLLENBQUMsSUFBSTtRQUN0QmQsUUFBUUMsT0FBTyxDQUFDbUIsTUFBTSxDQUFDUSxFQUFFLENBQUNELE9BQU8sV0FBVzs2Q0FBUEQ7Z0JBQUFBOztZQUNqQyxNQUFNRyxhQUFhLEtBQXFDRixPQUFoQ0EsTUFBTUcsTUFBTSxDQUFDLEdBQUdDLFdBQVcsSUFBd0IsT0FBbkJKLE1BQU1LLFNBQVMsQ0FBQztZQUN4RSxNQUFNQyxtQkFBbUJ0QjtZQUN6QixJQUFJc0IsZ0JBQWdCLENBQUNKLFdBQVcsRUFBRTtnQkFDOUIsSUFBSTtvQkFDQUksZ0JBQWdCLENBQUNKLFdBQVcsSUFBSUg7Z0JBQ3BDLEVBQUUsT0FBT1EsS0FBSztvQkFDVkMsUUFBUUMsS0FBSyxDQUFDLHdDQUFtRCxPQUFYUDtvQkFDdERNLFFBQVFDLEtBQUssQ0FBQyxDQUFDLEdBQUcxQixRQUFRLEVBQUVULE9BQU8sQ0FBQ2lDLE9BQU8sR0FBbUJBLE9BQWhCQSxJQUFJWixPQUFPLEVBQUMsTUFBYyxPQUFWWSxJQUFJRyxLQUFLLElBQUtILE1BQU0sRUFBRTtnQkFDeEY7WUFDSixDQUFDO1FBQ0w7SUFDSjtBQUNKO0FBQ0EsSUFBSUksV0FBVzNCO0FBQ2ZmLGtCQUFlLEdBQUcwQztBQUNsQixTQUFTbkMsWUFBWTs7SUFDakIsTUFBTVMsU0FBU0osT0FBT1AsT0FBTyxDQUFDc0MsVUFBVSxDQUFDOUIsZUFBZStCLGFBQWE7SUFDckUsSUFBSSxDQUFDNUIsUUFBUTtRQUNULE1BQU0sSUFBSVcsTUFBTSwrRkFBK0Y7SUFDbkgsQ0FBQztJQUNELE9BQU9YO0FBQ1g7R0FOU1Q7QUFPVCxTQUFTQyxlQUFzQjtJQUFUO1FBQUdzQixLQUFILHVCQUFPO0lBQUQ7SUFDeEJmLGdCQUFnQkMsTUFBTSxHQUFHLElBQUlaLFFBQVFDLE9BQU8sSUFBSXlCO0lBQ2hEZixnQkFBZ0JFLGNBQWMsQ0FBQ1csT0FBTyxDQUFDLENBQUNULEtBQUtBO0lBQzdDSixnQkFBZ0JFLGNBQWMsR0FBRyxFQUFFO0lBQ25DLE9BQU9GLGdCQUFnQkMsTUFBTTtBQUNqQztBQUNBLFNBQVNQLHlCQUF5Qk8sTUFBTSxFQUFFO0lBQ3RDLE1BQU02QixlQUFlN0I7SUFDckIsTUFBTThCLFdBQVcsQ0FBQztJQUNsQixLQUFLLE1BQU1DLFlBQVkxQixrQkFBa0I7UUFDckMsSUFBSSxPQUFPd0IsWUFBWSxDQUFDRSxTQUFTLEtBQUssVUFBVTtZQUM1Q0QsUUFBUSxDQUFDQyxTQUFTLEdBQUdqRCxPQUFPa0QsTUFBTSxDQUFDQyxNQUFNQyxPQUFPLENBQUNMLFlBQVksQ0FBQ0UsU0FBUyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRUYsWUFBWSxDQUFDRSxTQUFTLEVBQUUsbUNBQW1DOztZQUUvSSxRQUFTO1FBQ2IsQ0FBQztRQUNERCxRQUFRLENBQUNDLFNBQVMsR0FBR0YsWUFBWSxDQUFDRSxTQUFTO0lBQy9DO0lBQ0EsaUdBQWlHO0lBQ2pHRCxTQUFTdEIsTUFBTSxHQUFHcEIsUUFBUUMsT0FBTyxDQUFDbUIsTUFBTTtJQUN4Q0QsaUJBQWlCSyxPQUFPLENBQUMsQ0FBQ0MsUUFBUTtRQUM5QmlCLFFBQVEsQ0FBQ2pCLE1BQU0sR0FBRyxXQUFXOzZDQUFQQztnQkFBQUE7O1lBQ2xCLE9BQU9lLFlBQVksQ0FBQ2hCLE1BQU0sSUFBSUM7UUFDbEM7SUFDSjtJQUNBLE9BQU9nQjtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU85QyxRQUFRSyxPQUFPLEtBQUssY0FBZSxPQUFPTCxRQUFRSyxPQUFPLEtBQUssWUFBWUwsUUFBUUssT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPTCxRQUFRSyxPQUFPLENBQUM4QyxVQUFVLEtBQUssYUFBYTtJQUNyS3JELE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUUssT0FBTyxFQUFFLGNBQWM7UUFBRUosT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9rRCxNQUFNLENBQUNoRCxRQUFRSyxPQUFPLEVBQUVMO0lBQy9Cb0QsT0FBT3BELE9BQU8sR0FBR0EsUUFBUUssT0FBTztBQUNsQyxDQUFDLENBRUQsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3JvdXRlci5qcz8zMWZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUm91dGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcm91dGVyLmRlZmF1bHQ7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ3aXRoUm91dGVyXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfd2l0aFJvdXRlci5kZWZhdWx0O1xuICAgIH1cbn0pO1xuZXhwb3J0cy51c2VSb3V0ZXIgPSB1c2VSb3V0ZXI7XG5leHBvcnRzLmNyZWF0ZVJvdXRlciA9IGNyZWF0ZVJvdXRlcjtcbmV4cG9ydHMubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlID0gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlclwiKSk7XG52YXIgX3JvdXRlckNvbnRleHQgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dFwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vbGliL2lzLWVycm9yXCIpKTtcbnZhciBfd2l0aFJvdXRlciA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi93aXRoLXJvdXRlclwiKSk7XG5jb25zdCBzaW5nbGV0b25Sb3V0ZXIgPSB7XG4gICAgcm91dGVyOiBudWxsLFxuICAgIHJlYWR5Q2FsbGJhY2tzOiBbXSxcbiAgICByZWFkeSAoY2IpIHtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5Q2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbmNvbnN0IHVybFByb3BlcnR5RmllbGRzID0gW1xuICAgICdwYXRobmFtZScsXG4gICAgJ3JvdXRlJyxcbiAgICAncXVlcnknLFxuICAgICdhc1BhdGgnLFxuICAgICdjb21wb25lbnRzJyxcbiAgICAnaXNGYWxsYmFjaycsXG4gICAgJ2Jhc2VQYXRoJyxcbiAgICAnbG9jYWxlJyxcbiAgICAnbG9jYWxlcycsXG4gICAgJ2RlZmF1bHRMb2NhbGUnLFxuICAgICdpc1JlYWR5JyxcbiAgICAnaXNQcmV2aWV3JyxcbiAgICAnaXNMb2NhbGVEb21haW4nLFxuICAgICdkb21haW5Mb2NhbGVzJywgXG5dO1xuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAgICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgICAnaGFzaENoYW5nZUNvbXBsZXRlJywgXG5dO1xuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgICAncHVzaCcsXG4gICAgJ3JlcGxhY2UnLFxuICAgICdyZWxvYWQnLFxuICAgICdiYWNrJyxcbiAgICAncHJlZmV0Y2gnLFxuICAgICdiZWZvcmVQb3BTdGF0ZScsIFxuXTtcbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gICAgZ2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIF9yb3V0ZXIuZGVmYXVsdC5ldmVudHM7XG4gICAgfVxufSk7XG5mdW5jdGlvbiBnZXRSb3V0ZXIoKSB7XG4gICAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgKyAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgb24gdGhlIGNsaWVudCBzaWRlIG9mIHlvdXIgYXBwLlxcbic7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XG59XG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCk9PntcbiAgICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlIHdlIG5lZWQgdG8gcmV0dXJuXG4gICAgLy8gdGhlIHByb3BlcnR5IGFzc2lnbmVkIHRvIHRoZSBhY3R1YWwgcm91dGVyXG4gICAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gICAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCBmaWVsZCwge1xuICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCk7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xuICAgIHNpbmdsZXRvblJvdXRlcltmaWVsZF0gPSAoLi4uYXJncyk9PntcbiAgICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCk7XG4gICAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpO1xuICAgIH07XG59KTtcbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCk9PntcbiAgICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCk9PntcbiAgICAgICAgX3JvdXRlci5kZWZhdWx0LmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpPT57XG4gICAgICAgICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZygxKX1gO1xuICAgICAgICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlcjtcbiAgICAgICAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigoMCwgX2lzRXJyb3IpLmRlZmF1bHQoZXJyKSA/IGAke2Vyci5tZXNzYWdlfVxcbiR7ZXJyLnN0YWNrfWAgOiBlcnIgKyAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn0pO1xudmFyIF9kZWZhdWx0ID0gc2luZ2xldG9uUm91dGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5mdW5jdGlvbiB1c2VSb3V0ZXIoKSB7XG4gICAgY29uc3Qgcm91dGVyID0gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yOiBOZXh0Um91dGVyIHdhcyBub3QgbW91bnRlZC4gaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1yb3V0ZXItbm90LW1vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlciguLi5hcmdzKSB7XG4gICAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBfcm91dGVyLmRlZmF1bHQoLi4uYXJncyk7XG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKT0+Y2IoKSk7XG4gICAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzID0gW107XG4gICAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7XG59XG5mdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKSB7XG4gICAgY29uc3Qgc2NvcGVkUm91dGVyID0gcm91dGVyO1xuICAgIGNvbnN0IGluc3RhbmNlID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB1cmxQcm9wZXJ0eUZpZWxkcyl7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NvcGVkUm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IE9iamVjdC5hc3NpZ24oQXJyYXkuaXNBcnJheShzY29wZWRSb3V0ZXJbcHJvcGVydHldKSA/IFtdIDoge30sIHNjb3BlZFJvdXRlcltwcm9wZXJ0eV0pIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBzY29wZWRSb3V0ZXJbcHJvcGVydHldO1xuICAgIH1cbiAgICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gICAgaW5zdGFuY2UuZXZlbnRzID0gX3JvdXRlci5kZWZhdWx0LmV2ZW50cztcbiAgICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKT0+e1xuICAgICAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJncyk9PntcbiAgICAgICAgICAgIHJldHVybiBzY29wZWRSb3V0ZXJbZmllbGRdKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJfcm91dGVyIiwiZGVmYXVsdCIsIl93aXRoUm91dGVyIiwidXNlUm91dGVyIiwiY3JlYXRlUm91dGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl9yb3V0ZXJDb250ZXh0IiwiX2lzRXJyb3IiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInJlYWR5IiwiY2IiLCJwdXNoIiwidXJsUHJvcGVydHlGaWVsZHMiLCJyb3V0ZXJFdmVudHMiLCJjb3JlTWV0aG9kRmllbGRzIiwiZXZlbnRzIiwiZ2V0Um91dGVyIiwibWVzc2FnZSIsIkVycm9yIiwiZm9yRWFjaCIsImZpZWxkIiwiYXJncyIsImV2ZW50Iiwib24iLCJldmVudEZpZWxkIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHJpbmciLCJfc2luZ2xldG9uUm91dGVyIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwic3RhY2siLCJfZGVmYXVsdCIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0Iiwic2NvcGVkUm91dGVyIiwiaW5zdGFuY2UiLCJwcm9wZXJ0eSIsImFzc2lnbiIsIkFycmF5IiwiaXNBcnJheSIsIl9fZXNNb2R1bGUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/script.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/script.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.handleClientScriptLoad = handleClientScriptLoad;\nexports.initScriptLoader = initScriptLoader;\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _reactDom = _interop_require_default(__webpack_require__(/*! react-dom */ \"./node_modules/next/dist/compiled/react-dom/index.js\"));\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _headManagerContext = __webpack_require__(/*! ../shared/lib/head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _headManager = __webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\n\"use client\";\nconst ScriptCache = new Map();\nconst LoadCache = new Set();\nconst ignoreProps = [\n    \"onLoad\",\n    \"onReady\",\n    \"dangerouslySetInnerHTML\",\n    \"children\",\n    \"onError\",\n    \"strategy\"\n];\nconst loadScript = (props)=>{\n    const { src , id , onLoad =()=>{} , onReady =null , dangerouslySetInnerHTML , children =\"\" , strategy =\"afterInteractive\" , onError  } = props;\n    const cacheKey = id || src;\n    // Script has already loaded\n    if (cacheKey && LoadCache.has(cacheKey)) {\n        return;\n    }\n    // Contents of this script are already loading/loaded\n    if (ScriptCache.has(src)) {\n        LoadCache.add(cacheKey);\n        // It is possible that multiple `next/script` components all have same \"src\", but has different \"onLoad\"\n        // This is to make sure the same remote script will only load once, but \"onLoad\" are executed in order\n        ScriptCache.get(src).then(onLoad, onError);\n        return;\n    }\n    /** Execute after the script first loaded */ const afterLoad = ()=>{\n        // Run onReady for the first time after load event\n        if (onReady) {\n            onReady();\n        }\n        // add cacheKey to LoadCache when load successfully\n        LoadCache.add(cacheKey);\n    };\n    const el = document.createElement(\"script\");\n    const loadPromise = new Promise((resolve, reject)=>{\n        el.addEventListener(\"load\", function(e) {\n            resolve();\n            if (onLoad) {\n                onLoad.call(this, e);\n            }\n            afterLoad();\n        });\n        el.addEventListener(\"error\", function(e) {\n            reject(e);\n        });\n    }).catch(function(e) {\n        if (onError) {\n            onError(e);\n        }\n    });\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || \"\";\n        afterLoad();\n    } else if (children) {\n        el.textContent = typeof children === \"string\" ? children : Array.isArray(children) ? children.join(\"\") : \"\";\n        afterLoad();\n    } else if (src) {\n        el.src = src;\n        // do not add cacheKey into LoadCache for remote script here\n        // cacheKey will be added to LoadCache when it is actually loaded (see loadPromise above)\n        ScriptCache.set(src, loadPromise);\n    }\n    for (const [k, value] of Object.entries(props)){\n        if (value === undefined || ignoreProps.includes(k)) {\n            continue;\n        }\n        const attr = _headManager.DOMAttributeNames[k] || k.toLowerCase();\n        el.setAttribute(attr, value);\n    }\n    if (strategy === \"worker\") {\n        el.setAttribute(\"type\", \"text/partytown\");\n    }\n    el.setAttribute(\"data-nscript\", strategy);\n    document.body.appendChild(el);\n};\nfunction handleClientScriptLoad(props) {\n    const { strategy =\"afterInteractive\"  } = props;\n    if (strategy === \"lazyOnload\") {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    } else {\n        loadScript(props);\n    }\n}\nfunction loadLazyScript(props) {\n    if (document.readyState === \"complete\") {\n        (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n    } else {\n        window.addEventListener(\"load\", ()=>{\n            (0, _requestIdleCallback).requestIdleCallback(()=>loadScript(props));\n        });\n    }\n}\nfunction addBeforeInteractiveToCache() {\n    const scripts = [\n        ...document.querySelectorAll('[data-nscript=\"beforeInteractive\"]'),\n        ...document.querySelectorAll('[data-nscript=\"beforePageRender\"]')\n    ];\n    scripts.forEach((script)=>{\n        const cacheKey = script.id || script.getAttribute(\"src\");\n        LoadCache.add(cacheKey);\n    });\n}\nfunction initScriptLoader(scriptLoaderItems) {\n    scriptLoaderItems.forEach(handleClientScriptLoad);\n    addBeforeInteractiveToCache();\n}\nfunction Script(props) {\n    _s();\n    const { id , src =\"\" , onLoad =()=>{} , onReady =null , strategy =\"afterInteractive\" , onError  } = props, restProps = _object_without_properties_loose(props, [\n        \"id\",\n        \"src\",\n        \"onLoad\",\n        \"onReady\",\n        \"strategy\",\n        \"onError\"\n    ]);\n    // Context is available only during SSR\n    const { updateScripts , scripts , getIsSsr , appDir , nonce  } = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n    /**\n   * - First mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script hasn't loaded yet (not in LoadCache)\n   *      onReady is skipped, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. hasLoadScriptEffectCalled.current is false, loadScript executes\n   *      Once the script is loaded, the onLoad and onReady will be called by then\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   *\n   * - Second mount:\n   *   1. The useEffect for onReady executes\n   *   2. hasOnReadyEffectCalled.current is false, but the script has already loaded (found in LoadCache)\n   *      onReady is called, set hasOnReadyEffectCalled.current to true\n   *   3. The useEffect for loadScript executes\n   *   4. The script is already loaded, loadScript bails out\n   *   [If strict mode is enabled / is wrapped in <OffScreen /> component]\n   *   5. The useEffect for onReady executes again\n   *   6. hasOnReadyEffectCalled.current is true, so entire effect is skipped\n   *   7. The useEffect for loadScript executes again\n   *   8. hasLoadScriptEffectCalled.current is true, so entire effect is skipped\n   */ const hasOnReadyEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        const cacheKey = id || src;\n        if (!hasOnReadyEffectCalled.current) {\n            // Run onReady if script has loaded before but component is re-mounted\n            if (onReady && cacheKey && LoadCache.has(cacheKey)) {\n                onReady();\n            }\n            hasOnReadyEffectCalled.current = true;\n        }\n    }, [\n        onReady,\n        id,\n        src\n    ]);\n    const hasLoadScriptEffectCalled = (0, _react).useRef(false);\n    (0, _react).useEffect(()=>{\n        if (!hasLoadScriptEffectCalled.current) {\n            if (strategy === \"afterInteractive\") {\n                loadScript(props);\n            } else if (strategy === \"lazyOnload\") {\n                loadLazyScript(props);\n            }\n            hasLoadScriptEffectCalled.current = true;\n        }\n    }, [\n        props,\n        strategy\n    ]);\n    if (strategy === \"beforeInteractive\" || strategy === \"worker\") {\n        if (updateScripts) {\n            scripts[strategy] = (scripts[strategy] || []).concat([\n                _extends({\n                    id,\n                    src,\n                    onLoad,\n                    onReady,\n                    onError\n                }, restProps)\n            ]);\n            updateScripts(scripts);\n        } else if (getIsSsr && getIsSsr()) {\n            // Script has already loaded during SSR\n            LoadCache.add(id || src);\n        } else if (getIsSsr && !getIsSsr()) {\n            loadScript(props);\n        }\n    }\n    // For the app directory, we need React Float to preload these scripts.\n    if (appDir) {\n        // Before interactive scripts need to be loaded by Next.js' runtime instead\n        // of native <script> tags, because they no longer have `defer`.\n        if (strategy === \"beforeInteractive\") {\n            if (!src) {\n                // For inlined scripts, we put the content in `children`.\n                if (restProps.dangerouslySetInnerHTML) {\n                    restProps.children = restProps.dangerouslySetInnerHTML.__html;\n                    delete restProps.dangerouslySetInnerHTML;\n                }\n                return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                    nonce: nonce,\n                    dangerouslySetInnerHTML: {\n                        __html: \"(self.__next_s=self.__next_s||[]).push(\".concat(JSON.stringify([\n                            0,\n                            _extends({}, restProps)\n                        ]), \")\")\n                    }\n                });\n            }\n            // @ts-ignore\n            _reactDom.default.preload(src, restProps.integrity ? {\n                as: \"script\",\n                integrity: restProps.integrity\n            } : {\n                as: \"script\"\n            });\n            return /*#__PURE__*/ _react.default.createElement(\"script\", {\n                nonce: nonce,\n                dangerouslySetInnerHTML: {\n                    __html: \"(self.__next_s=self.__next_s||[]).push(\".concat(JSON.stringify([\n                        src\n                    ]), \")\")\n                }\n            });\n        } else if (strategy === \"afterInteractive\") {\n            if (src) {\n                // @ts-ignore\n                _reactDom.default.preload(src, restProps.integrity ? {\n                    as: \"script\",\n                    integrity: restProps.integrity\n                } : {\n                    as: \"script\"\n                });\n            }\n        }\n    }\n    return null;\n}\n_s(Script, \"DhDg2Zc8aDaIY/opmpZUJ4ZZRaA=\");\n_c = Script;\nObject.defineProperty(Script, \"__nextScript\", {\n    value: true\n});\nvar _default = Script;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=script.js.map\nvar _c;\n$RefreshReg$(_c, \"Script\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQ2E7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDhCQUE4QixHQUFHRTtBQUNqQ0Ysd0JBQXdCLEdBQUdHO0FBQzNCSCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUssV0FBV0MsbUhBQStDO0FBQzlELElBQUlDLDJCQUEyQkQsbUpBQStEO0FBQzlGLElBQUlFLDRCQUE0QkYscUpBQWdFO0FBQ2hHLElBQUlHLG1DQUFtQ0gsbUtBQXVFO0FBQzlHLElBQUlJLFlBQVlILHlCQUF5QkQsbUJBQU9BLENBQUMsdUVBQVc7QUFDNUQsSUFBSUssU0FBU0gsMEJBQTBCRixtQkFBT0EsQ0FBQywrREFBTztBQUN0RCxJQUFJTSxzQkFBc0JOLG1CQUFPQSxDQUFDLHVHQUFvQztBQUN0RSxJQUFJTyxlQUFlUCxtQkFBT0EsQ0FBQyx1RUFBZ0I7QUFDM0MsSUFBSVEsdUJBQXVCUixtQkFBT0EsQ0FBQyx5RkFBeUI7QUFDNUQ7QUFDQSxNQUFNUyxjQUFjLElBQUlDO0FBQ3hCLE1BQU1DLFlBQVksSUFBSUM7QUFDdEIsTUFBTUMsY0FBYztJQUNoQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNELE1BQU1DLGFBQWEsQ0FBQ0MsUUFBUTtJQUN4QixNQUFNLEVBQUVDLElBQUcsRUFBR0MsR0FBRSxFQUFHQyxRQUFRLElBQUksQ0FBQyxFQUFDLEVBQUdDLFNBQVMsSUFBSSxHQUFHQyx3QkFBdUIsRUFBR0MsVUFBVSxHQUFFLEVBQUdDLFVBQVUsbUJBQWtCLEVBQUdDLFFBQU8sRUFBSyxHQUFHUjtJQUMzSSxNQUFNUyxXQUFXUCxNQUFNRDtJQUN2Qiw0QkFBNEI7SUFDNUIsSUFBSVEsWUFBWWIsVUFBVWMsR0FBRyxDQUFDRCxXQUFXO1FBQ3JDO0lBQ0osQ0FBQztJQUNELHFEQUFxRDtJQUNyRCxJQUFJZixZQUFZZ0Is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UUksT0FBTyxLQUFLLGNBQWUsT0FBT0osUUFBUUksT0FBTyxLQUFLLFlBQVlKLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0osUUFBUUksT0FBTyxDQUFDMkYsVUFBVSxLQUFLLGFBQWE7SUFDcktqRyxPQUFPQyxjQUFjLENBQUNDLFFBQVFJLE9BQU8sRUFBRSxjQUFjO1FBQUVILE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPa0csTUFBTSxDQUFDaEcsUUFBUUksT0FBTyxFQUFFSjtJQUMvQmlHLE9BQU9qRyxPQUFPLEdBQUdBLFFBQVFJLE9BQU87QUFDbEMsQ0FBQyxDQUVELGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9zY3JpcHQuanM/YmQ2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5oYW5kbGVDbGllbnRTY3JpcHRMb2FkID0gaGFuZGxlQ2xpZW50U2NyaXB0TG9hZDtcbmV4cG9ydHMuaW5pdFNjcmlwdExvYWRlciA9IGluaXRTY3JpcHRMb2FkZXI7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdERvbSA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2hlYWRNYW5hZ2VyQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0XCIpO1xudmFyIF9oZWFkTWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlYWQtbWFuYWdlclwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbid1c2UgY2xpZW50JztcbmNvbnN0IFNjcmlwdENhY2hlID0gbmV3IE1hcCgpO1xuY29uc3QgTG9hZENhY2hlID0gbmV3IFNldCgpO1xuY29uc3QgaWdub3JlUHJvcHMgPSBbXG4gICAgJ29uTG9hZCcsXG4gICAgJ29uUmVhZHknLFxuICAgICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gICAgJ2NoaWxkcmVuJyxcbiAgICAnb25FcnJvcicsXG4gICAgJ3N0cmF0ZWd5JywgXG5dO1xuY29uc3QgbG9hZFNjcmlwdCA9IChwcm9wcyk9PntcbiAgICBjb25zdCB7IHNyYyAsIGlkICwgb25Mb2FkID0oKT0+e30gLCBvblJlYWR5ID1udWxsICwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgLCBjaGlsZHJlbiA9JycgLCBzdHJhdGVneSA9J2FmdGVySW50ZXJhY3RpdmUnICwgb25FcnJvciAsICB9ID0gcHJvcHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBpZCB8fCBzcmM7XG4gICAgLy8gU2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZFxuICAgIGlmIChjYWNoZUtleSAmJiBMb2FkQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENvbnRlbnRzIG9mIHRoaXMgc2NyaXB0IGFyZSBhbHJlYWR5IGxvYWRpbmcvbG9hZGVkXG4gICAgaWYgKFNjcmlwdENhY2hlLmhhcyhzcmMpKSB7XG4gICAgICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpO1xuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IG11bHRpcGxlIGBuZXh0L3NjcmlwdGAgY29tcG9uZW50cyBhbGwgaGF2ZSBzYW1lIFwic3JjXCIsIGJ1dCBoYXMgZGlmZmVyZW50IFwib25Mb2FkXCJcbiAgICAgICAgLy8gVGhpcyBpcyB0byBtYWtlIHN1cmUgdGhlIHNhbWUgcmVtb3RlIHNjcmlwdCB3aWxsIG9ubHkgbG9hZCBvbmNlLCBidXQgXCJvbkxvYWRcIiBhcmUgZXhlY3V0ZWQgaW4gb3JkZXJcbiAgICAgICAgU2NyaXB0Q2FjaGUuZ2V0KHNyYykudGhlbihvbkxvYWQsIG9uRXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKiBFeGVjdXRlIGFmdGVyIHRoZSBzY3JpcHQgZmlyc3QgbG9hZGVkICovIGNvbnN0IGFmdGVyTG9hZCA9ICgpPT57XG4gICAgICAgIC8vIFJ1biBvblJlYWR5IGZvciB0aGUgZmlyc3QgdGltZSBhZnRlciBsb2FkIGV2ZW50XG4gICAgICAgIGlmIChvblJlYWR5KSB7XG4gICAgICAgICAgICBvblJlYWR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGNhY2hlS2V5IHRvIExvYWRDYWNoZSB3aGVuIGxvYWQgc3VjY2Vzc2Z1bGx5XG4gICAgICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpO1xuICAgIH07XG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBjb25zdCBsb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgb25Mb2FkLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZnRlckxvYWQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSB7XG4gICAgICAgIGVsLmlubmVySFRNTCA9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCB8fCAnJztcbiAgICAgICAgYWZ0ZXJMb2FkKCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbikge1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgPyBjaGlsZHJlbiA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4uam9pbignJykgOiAnJztcbiAgICAgICAgYWZ0ZXJMb2FkKCk7XG4gICAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICAgICAgZWwuc3JjID0gc3JjO1xuICAgICAgICAvLyBkbyBub3QgYWRkIGNhY2hlS2V5IGludG8gTG9hZENhY2hlIGZvciByZW1vdGUgc2NyaXB0IGhlcmVcbiAgICAgICAgLy8gY2FjaGVLZXkgd2lsbCBiZSBhZGRlZCB0byBMb2FkQ2FjaGUgd2hlbiBpdCBpcyBhY3R1YWxseSBsb2FkZWQgKHNlZSBsb2FkUHJvbWlzZSBhYm92ZSlcbiAgICAgICAgU2NyaXB0Q2FjaGUuc2V0KHNyYywgbG9hZFByb21pc2UpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaWdub3JlUHJvcHMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF0dHIgPSBfaGVhZE1hbmFnZXIuRE9NQXR0cmlidXRlTmFtZXNba10gfHwgay50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoc3RyYXRlZ3kgPT09ICd3b3JrZXInKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L3BhcnR5dG93bicpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbnNjcmlwdCcsIHN0cmF0ZWd5KTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbn07XG5mdW5jdGlvbiBoYW5kbGVDbGllbnRTY3JpcHRMb2FkKHByb3BzKSB7XG4gICAgY29uc3QgeyBzdHJhdGVneSA9J2FmdGVySW50ZXJhY3RpdmUnICB9ID0gcHJvcHM7XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnbGF6eU9ubG9hZCcpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKT0+e1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvYWRTY3JpcHQocHJvcHMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvYWRMYXp5U2NyaXB0KHByb3BzKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKT0+e1xuICAgICAgICAgICAgKDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5yZXF1ZXN0SWRsZUNhbGxiYWNrKCgpPT5sb2FkU2NyaXB0KHByb3BzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSgpIHtcbiAgICBjb25zdCBzY3JpcHRzID0gW1xuICAgICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1uc2NyaXB0PVwiYmVmb3JlSW50ZXJhY3RpdmVcIl0nKSxcbiAgICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbnNjcmlwdD1cImJlZm9yZVBhZ2VSZW5kZXJcIl0nKSwgXG4gICAgXTtcbiAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdCk9PntcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY3JpcHQuaWQgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgIExvYWRDYWNoZS5hZGQoY2FjaGVLZXkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdFNjcmlwdExvYWRlcihzY3JpcHRMb2FkZXJJdGVtcykge1xuICAgIHNjcmlwdExvYWRlckl0ZW1zLmZvckVhY2goaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCk7XG4gICAgYWRkQmVmb3JlSW50ZXJhY3RpdmVUb0NhY2hlKCk7XG59XG5mdW5jdGlvbiBTY3JpcHQocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkICwgc3JjID0nJyAsIG9uTG9hZCA9KCk9Pnt9ICwgb25SZWFkeSA9bnVsbCAsIHN0cmF0ZWd5ID0nYWZ0ZXJJbnRlcmFjdGl2ZScgLCBvbkVycm9yICB9ID0gcHJvcHMsIHJlc3RQcm9wcyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHByb3BzLCBbXG4gICAgICAgIFwiaWRcIixcbiAgICAgICAgXCJzcmNcIixcbiAgICAgICAgXCJvbkxvYWRcIixcbiAgICAgICAgXCJvblJlYWR5XCIsXG4gICAgICAgIFwic3RyYXRlZ3lcIixcbiAgICAgICAgXCJvbkVycm9yXCJcbiAgICBdKTtcbiAgICAvLyBDb250ZXh0IGlzIGF2YWlsYWJsZSBvbmx5IGR1cmluZyBTU1JcbiAgICBjb25zdCB7IHVwZGF0ZVNjcmlwdHMgLCBzY3JpcHRzICwgZ2V0SXNTc3IgLCBhcHBEaXIgLCBub25jZSAgfSA9ICgwLCBfcmVhY3QpLnVzZUNvbnRleHQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQpO1xuICAgIC8qKlxuICAgKiAtIEZpcnN0IG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhc24ndCBsb2FkZWQgeWV0IChub3QgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgc2tpcHBlZCwgc2V0IGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCB0byB0cnVlXG4gICAqICAgMy4gVGhlIHVzZUVmZmVjdCBmb3IgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgIDQuIGhhc0xvYWRTY3JpcHRFZmZlY3RDYWxsZWQuY3VycmVudCBpcyBmYWxzZSwgbG9hZFNjcmlwdCBleGVjdXRlc1xuICAgKiAgICAgIE9uY2UgdGhlIHNjcmlwdCBpcyBsb2FkZWQsIHRoZSBvbkxvYWQgYW5kIG9uUmVhZHkgd2lsbCBiZSBjYWxsZWQgYnkgdGhlblxuICAgKiAgIFtJZiBzdHJpY3QgbW9kZSBpcyBlbmFibGVkIC8gaXMgd3JhcHBlZCBpbiA8T2ZmU2NyZWVuIC8+IGNvbXBvbmVudF1cbiAgICogICA1LiBUaGUgdXNlRWZmZWN0IGZvciBvblJlYWR5IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgNi4gaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKiAgIDcuIFRoZSB1c2VFZmZlY3QgZm9yIGxvYWRTY3JpcHQgZXhlY3V0ZXMgYWdhaW5cbiAgICogICA4LiBoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgdHJ1ZSwgc28gZW50aXJlIGVmZmVjdCBpcyBza2lwcGVkXG4gICAqXG4gICAqIC0gU2Vjb25kIG1vdW50OlxuICAgKiAgIDEuIFRoZSB1c2VFZmZlY3QgZm9yIG9uUmVhZHkgZXhlY3V0ZXNcbiAgICogICAyLiBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgaXMgZmFsc2UsIGJ1dCB0aGUgc2NyaXB0IGhhcyBhbHJlYWR5IGxvYWRlZCAoZm91bmQgaW4gTG9hZENhY2hlKVxuICAgKiAgICAgIG9uUmVhZHkgaXMgY2FsbGVkLCBzZXQgaGFzT25SZWFkeUVmZmVjdENhbGxlZC5jdXJyZW50IHRvIHRydWVcbiAgICogICAzLiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzXG4gICAqICAgNC4gVGhlIHNjcmlwdCBpcyBhbHJlYWR5IGxvYWRlZCwgbG9hZFNjcmlwdCBiYWlscyBvdXRcbiAgICogICBbSWYgc3RyaWN0IG1vZGUgaXMgZW5hYmxlZCAvIGlzIHdyYXBwZWQgaW4gPE9mZlNjcmVlbiAvPiBjb21wb25lbnRdXG4gICAqICAgNS4gVGhlIHVzZUVmZmVjdCBmb3Igb25SZWFkeSBleGVjdXRlcyBhZ2FpblxuICAgKiAgIDYuIGhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCBpcyB0cnVlLCBzbyBlbnRpcmUgZWZmZWN0IGlzIHNraXBwZWRcbiAgICogICA3LiBUaGUgdXNlRWZmZWN0IGZvciBsb2FkU2NyaXB0IGV4ZWN1dGVzIGFnYWluXG4gICAqICAgOC4gaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50IGlzIHRydWUsIHNvIGVudGlyZSBlZmZlY3QgaXMgc2tpcHBlZFxuICAgKi8gY29uc3QgaGFzT25SZWFkeUVmZmVjdENhbGxlZCA9ICgwLCBfcmVhY3QpLnVzZVJlZihmYWxzZSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gaWQgfHwgc3JjO1xuICAgICAgICBpZiAoIWhhc09uUmVhZHlFZmZlY3RDYWxsZWQuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gUnVuIG9uUmVhZHkgaWYgc2NyaXB0IGhhcyBsb2FkZWQgYmVmb3JlIGJ1dCBjb21wb25lbnQgaXMgcmUtbW91bnRlZFxuICAgICAgICAgICAgaWYgKG9uUmVhZHkgJiYgY2FjaGVLZXkgJiYgTG9hZENhY2hlLmhhcyhjYWNoZUtleSkpIHtcbiAgICAgICAgICAgICAgICBvblJlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXNPblJlYWR5RWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBvblJlYWR5LFxuICAgICAgICBpZCxcbiAgICAgICAgc3JjXG4gICAgXSk7XG4gICAgY29uc3QgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZCA9ICgwLCBfcmVhY3QpLnVzZVJlZihmYWxzZSk7XG4gICAgKDAsIF9yZWFjdCkudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoc3RyYXRlZ3kgPT09ICdhZnRlckludGVyYWN0aXZlJykge1xuICAgICAgICAgICAgICAgIGxvYWRTY3JpcHQocHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ2xhenlPbmxvYWQnKSB7XG4gICAgICAgICAgICAgICAgbG9hZExhenlTY3JpcHQocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFzTG9hZFNjcmlwdEVmZmVjdENhbGxlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgXSk7XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAnYmVmb3JlSW50ZXJhY3RpdmUnIHx8IHN0cmF0ZWd5ID09PSAnd29ya2VyJykge1xuICAgICAgICBpZiAodXBkYXRlU2NyaXB0cykge1xuICAgICAgICAgICAgc2NyaXB0c1tzdHJhdGVneV0gPSAoc2NyaXB0c1tzdHJhdGVneV0gfHwgW10pLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgICAgICBvbkxvYWQsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVhZHksXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3JcbiAgICAgICAgICAgICAgICB9LCByZXN0UHJvcHMpLCBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdXBkYXRlU2NyaXB0cyhzY3JpcHRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChnZXRJc1NzciAmJiBnZXRJc1NzcigpKSB7XG4gICAgICAgICAgICAvLyBTY3JpcHQgaGFzIGFscmVhZHkgbG9hZGVkIGR1cmluZyBTU1JcbiAgICAgICAgICAgIExvYWRDYWNoZS5hZGQoaWQgfHwgc3JjKTtcbiAgICAgICAgfSBlbHNlIGlmIChnZXRJc1NzciAmJiAhZ2V0SXNTc3IoKSkge1xuICAgICAgICAgICAgbG9hZFNjcmlwdChwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRm9yIHRoZSBhcHAgZGlyZWN0b3J5LCB3ZSBuZWVkIFJlYWN0IEZsb2F0IHRvIHByZWxvYWQgdGhlc2Ugc2NyaXB0cy5cbiAgICBpZiAoYXBwRGlyKSB7XG4gICAgICAgIC8vIEJlZm9yZSBpbnRlcmFjdGl2ZSBzY3JpcHRzIG5lZWQgdG8gYmUgbG9hZGVkIGJ5IE5leHQuanMnIHJ1bnRpbWUgaW5zdGVhZFxuICAgICAgICAvLyBvZiBuYXRpdmUgPHNjcmlwdD4gdGFncywgYmVjYXVzZSB0aGV5IG5vIGxvbmdlciBoYXZlIGBkZWZlcmAuXG4gICAgICAgIGlmIChzdHJhdGVneSA9PT0gJ2JlZm9yZUludGVyYWN0aXZlJykge1xuICAgICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgaW5saW5lZCBzY3JpcHRzLCB3ZSBwdXQgdGhlIGNvbnRlbnQgaW4gYGNoaWxkcmVuYC5cbiAgICAgICAgICAgICAgICBpZiAocmVzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RQcm9wcy5jaGlsZHJlbiA9IHJlc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IGAoc2VsZi5fX25leHRfcz1zZWxmLl9fbmV4dF9zfHxbXSkucHVzaCgke0pTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmRzKHt9LCByZXN0UHJvcHMpLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pfSlgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIF9yZWFjdERvbS5kZWZhdWx0LnByZWxvYWQoc3JjLCByZXN0UHJvcHMuaW50ZWdyaXR5ID8ge1xuICAgICAgICAgICAgICAgIGFzOiAnc2NyaXB0JyxcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlc3RQcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgICAgICAgICAgICAgIG5vbmNlOiBub25jZSxcbiAgICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IGAoc2VsZi5fX25leHRfcz1zZWxmLl9fbmV4dF9zfHxbXSkucHVzaCgke0pTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYywgXG4gICAgICAgICAgICAgICAgICAgIF0pfSlgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyYXRlZ3kgPT09ICdhZnRlckludGVyYWN0aXZlJykge1xuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBfcmVhY3REb20uZGVmYXVsdC5wcmVsb2FkKHNyYywgcmVzdFByb3BzLmludGVncml0eSA/IHtcbiAgICAgICAgICAgICAgICAgICAgYXM6ICdzY3JpcHQnLFxuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlc3RQcm9wcy5pbnRlZ3JpdHlcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBhczogJ3NjcmlwdCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY3JpcHQsICdfX25leHRTY3JpcHQnLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xudmFyIF9kZWZhdWx0ID0gU2NyaXB0O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcmlwdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwiaW5pdFNjcmlwdExvYWRlciIsImRlZmF1bHQiLCJfZXh0ZW5kcyIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UiLCJfcmVhY3REb20iLCJfcmVhY3QiLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX2hlYWRNYW5hZ2VyIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJTY3JpcHRDYWNoZSIsIk1hcCIsIkxvYWRDYWNoZSIsIlNldCIsImlnbm9yZVByb3BzIiwibG9hZFNjcmlwdCIsInByb3BzIiwic3JjIiwiaWQiLCJvbkxvYWQiLCJvblJlYWR5IiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJjaGlsZHJlbiIsInN0cmF0ZWd5Iiwib25FcnJvciIsImNhY2hlS2V5IiwiaGFzIiwiYWRkIiwiZ2V0IiwidGhlbiIsImFmdGVyTG9hZCIsImVsIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwibG9hZFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY2FsbCIsImNhdGNoIiwiaW5uZXJIVE1MIiwiX19odG1sIiwidGV4dENvbnRlbnQiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwic2V0IiwiayIsImVudHJpZXMiLCJ1bmRlZmluZWQiLCJpbmNsdWRlcyIsImF0dHIiLCJET01BdHRyaWJ1dGVOYW1lcyIsInRvTG93ZXJDYXNlIiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwid2luZG93IiwicmVxdWVzdElkbGVDYWxsYmFjayIsImxvYWRMYXp5U2NyaXB0IiwicmVhZHlTdGF0ZSIsImFkZEJlZm9yZUludGVyYWN0aXZlVG9DYWNoZSIsInNjcmlwdHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsInNjcmlwdCIsImdldEF0dHJpYnV0ZSIsInNjcmlwdExvYWRlckl0ZW1zIiwiU2NyaXB0IiwicmVzdFByb3BzIiwidXBkYXRlU2NyaXB0cyIsImdldElzU3NyIiwiYXBwRGlyIiwibm9uY2UiLCJ1c2VDb250ZXh0IiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiaGFzT25SZWFkeUVmZmVjdENhbGxlZCIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJoYXNMb2FkU2NyaXB0RWZmZWN0Q2FsbGVkIiwiY29uY2F0IiwiSlNPTiIsInN0cmluZ2lmeSIsInByZWxvYWQiLCJpbnRlZ3JpdHkiLCJhcyIsIl9kZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/script.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/trusted-types.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/client/trusted-types.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.__unsafeCreateTrustedScriptURL = __unsafeCreateTrustedScriptURL;\n/**\n * Stores the Trusted Types Policy. Starts as undefined and can be set to null\n * if Trusted Types is not supported in the browser.\n */ let policy;\n/**\n * Getter for the Trusted Types Policy. If it is undefined, it is instantiated\n * here or set to null if Trusted Types is not supported in the browser.\n */ function getPolicy() {\n    if (typeof policy === \"undefined\" && \"object\" !== \"undefined\") {\n        var ref;\n        policy = ((ref = window.trustedTypes) == null ? void 0 : ref.createPolicy(\"nextjs\", {\n            createHTML: (input)=>input,\n            createScript: (input)=>input,\n            createScriptURL: (input)=>input\n        })) || null;\n    }\n    return policy;\n}\nfunction __unsafeCreateTrustedScriptURL(url) {\n    var ref;\n    return ((ref = getPolicy()) == null ? void 0 : ref.createScriptURL(url)) || url;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=trusted-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC90cnVzdGVkLXR5cGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHNDQUFzQyxHQUFHRTtBQUN6Qzs7O0NBR0MsR0FBRyxJQUFJQztBQUNSOzs7Q0FHQyxHQUFHLFNBQVNDLFlBQVk7SUFDckIsSUFBSSxPQUFPRCxXQUFXLGVBQWUsYUFBa0IsYUFBYTtRQUNoRSxJQUFJRTtRQUNKRixTQUFTLENBQUMsQ0FBQ0UsTUFBTUMsT0FBT0MsWUFBWSxLQUFLLElBQUksR0FBRyxLQUFLLElBQUlGLElBQUlHLFlBQVksQ0FBQyxVQUFVO1lBQ2hGQyxZQUFZLENBQUNDLFFBQVFBO1lBQ3JCQyxjQUFjLENBQUNELFFBQVFBO1lBQ3ZCRSxpQkFBaUIsQ0FBQ0YsUUFBUUE7UUFDOUIsRUFBRSxLQUFLLElBQUk7SUFDZixDQUFDO0lBQ0QsT0FBT1A7QUFDWDtBQUNBLFNBQVNELCtCQUErQlcsR0FBRyxFQUFFO0lBQ3pDLElBQUlSO0lBQ0osT0FBTyxDQUFDLENBQUNBLE1BQU1ELFdBQVUsS0FBTSxJQUFJLEdBQUcsS0FBSyxJQUFJQyxJQUFJTyxlQUFlLENBQUNDLElBQUksS0FBS0E7QUFDaEY7QUFFQSxJQUFJLENBQUMsT0FBT2IsUUFBUWMsT0FBTyxLQUFLLGNBQWUsT0FBT2QsUUFBUWMsT0FBTyxLQUFLLFlBQVlkLFFBQVFjLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT2QsUUFBUWMsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS2pCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWMsT0FBTyxFQUFFLGNBQWM7UUFBRWIsT0FBTyxJQUFJO0lBQUM7SUFDbkVILE9BQU9rQixNQUFNLENBQUNoQixRQUFRYyxPQUFPLEVBQUVkO0lBQy9CaUIsT0FBT2pCLE9BQU8sR0FBR0EsUUFBUWMsT0FBTztBQUNsQyxDQUFDLENBRUQseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3RydXN0ZWQtdHlwZXMuanM/YTQxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX191bnNhZmVDcmVhdGVUcnVzdGVkU2NyaXB0VVJMID0gX191bnNhZmVDcmVhdGVUcnVzdGVkU2NyaXB0VVJMO1xuLyoqXG4gKiBTdG9yZXMgdGhlIFRydXN0ZWQgVHlwZXMgUG9saWN5LiBTdGFydHMgYXMgdW5kZWZpbmVkIGFuZCBjYW4gYmUgc2V0IHRvIG51bGxcbiAqIGlmIFRydXN0ZWQgVHlwZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3Nlci5cbiAqLyBsZXQgcG9saWN5O1xuLyoqXG4gKiBHZXR0ZXIgZm9yIHRoZSBUcnVzdGVkIFR5cGVzIFBvbGljeS4gSWYgaXQgaXMgdW5kZWZpbmVkLCBpdCBpcyBpbnN0YW50aWF0ZWRcbiAqIGhlcmUgb3Igc2V0IHRvIG51bGwgaWYgVHJ1c3RlZCBUeXBlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBicm93c2VyLlxuICovIGZ1bmN0aW9uIGdldFBvbGljeSgpIHtcbiAgICBpZiAodHlwZW9mIHBvbGljeSA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgcG9saWN5ID0gKChyZWYgPSB3aW5kb3cudHJ1c3RlZFR5cGVzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmNyZWF0ZVBvbGljeSgnbmV4dGpzJywge1xuICAgICAgICAgICAgY3JlYXRlSFRNTDogKGlucHV0KT0+aW5wdXQsXG4gICAgICAgICAgICBjcmVhdGVTY3JpcHQ6IChpbnB1dCk9PmlucHV0LFxuICAgICAgICAgICAgY3JlYXRlU2NyaXB0VVJMOiAoaW5wdXQpPT5pbnB1dFxuICAgICAgICB9KSkgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBvbGljeTtcbn1cbmZ1bmN0aW9uIF9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCh1cmwpIHtcbiAgICB2YXIgcmVmO1xuICAgIHJldHVybiAoKHJlZiA9IGdldFBvbGljeSgpKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmNyZWF0ZVNjcmlwdFVSTCh1cmwpKSB8fCB1cmw7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRydXN0ZWQtdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX191bnNhZmVDcmVhdGVUcnVzdGVkU2NyaXB0VVJMIiwicG9saWN5IiwiZ2V0UG9saWN5IiwicmVmIiwid2luZG93IiwidHJ1c3RlZFR5cGVzIiwiY3JlYXRlUG9saWN5IiwiY3JlYXRlSFRNTCIsImlucHV0IiwiY3JlYXRlU2NyaXB0IiwiY3JlYXRlU2NyaXB0VVJMIiwidXJsIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/trusted-types.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = withRouter;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nfunction withRouter(ComposedComponent) {\n    var _s = $RefreshSig$();\n    function WithRouterWrapper(props) {\n        _s();\n        return /*#__PURE__*/ _react.default.createElement(ComposedComponent, Object.assign({\n            router: (0, _router).useRouter()\n        }, props));\n    }\n    _s(WithRouterWrapper, \"CeygcqajjFExIxFEzW4x/gfWEGQ=\");\n    WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;\n    WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;\n    if (true) {\n        const name = ComposedComponent.displayName || ComposedComponent.name || \"Unknown\";\n        WithRouterWrapper.displayName = \"withRouter(\".concat(name, \")\");\n    }\n    return WithRouterWrapper;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=with-router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC93aXRoLXJvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixJQUFJQywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJQyxTQUFTRix5QkFBeUJDLG1CQUFPQSxDQUFDLCtEQUFPO0FBQ3JELElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDLDJEQUFVO0FBQ2hDLFNBQVNGLFdBQVdLLGlCQUFpQixFQUFFOztJQUNuQyxTQUFTQyxrQkFBa0JDLEtBQUssRUFBRTs7UUFDOUIsT0FBTyxXQUFXLEdBQUdKLE9BQU9KLE9BQU8sQ0FBQ1MsYUFBYSxDQUFDSCxtQkFBbUJWLE9BQU9jLE1BQU0sQ0FBQztZQUMvRUMsUUFBUSxDQUFDLEdBQUdOLE9BQU8sRUFBRU8sU0FBUztRQUNsQyxHQUFHSjtJQUNQO09BSlNEO0lBS1RBLGtCQUFrQk0sZUFBZSxHQUFHUCxrQkFBa0JPLGVBQWU7SUFDckVOLGtCQUFrQk8sbUJBQW1CLEdBQUdSLGtCQUFrQlEsbUJBQW1CO0lBQzdFLElBQUlDLElBQXlCLEVBQWM7UUFDdkMsTUFBTUMsT0FBT1Ysa0JBQWtCVyxXQUFXLElBQUlYLGtCQUFrQlUsSUFBSSxJQUFJO1FBQ3hFVCxrQkFBa0JVLFdBQVcsR0FBRyxjQUFtQixPQUFMRCxNQUFLO0lBQ3ZELENBQUM7SUFDRCxPQUFPVDtBQUNYO0FBRUEsSUFBSSxDQUFDLE9BQU9ULFFBQVFFLE9BQU8sS0FBSyxjQUFlLE9BQU9GLFFBQVFFLE9BQU8sS0FBSyxZQUFZRixRQUFRRSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9GLFFBQVFFLE9BQU8sQ0FBQ2tCLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdEIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRSxPQUFPLEVBQUUsY0FBYztRQUFFRCxPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT2MsTUFBTSxDQUFDWixRQUFRRSxPQUFPLEVBQUVGO0lBQy9CcUIsT0FBT3JCLE9BQU8sR0FBR0EsUUFBUUUsT0FBTztBQUNsQyxDQUFDLENBRUQsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3dpdGgtcm91dGVyLmpzP2FjN2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9yb3V0ZXIgPSByZXF1aXJlKFwiLi9yb3V0ZXJcIik7XG5mdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvc2VkQ29tcG9uZW50KSB7XG4gICAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICByb3V0ZXI6ICgwLCBfcm91dGVyKS51c2VSb3V0ZXIoKVxuICAgICAgICB9LCBwcm9wcykpO1xuICAgIH1cbiAgICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHM7XG4gICAgV2l0aFJvdXRlcldyYXBwZXIub3JpZ0dldEluaXRpYWxQcm9wcyA9IENvbXBvc2VkQ29tcG9uZW50Lm9yaWdHZXRJbml0aWFsUHJvcHM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nO1xuICAgICAgICBXaXRoUm91dGVyV3JhcHBlci5kaXNwbGF5TmFtZSA9IGB3aXRoUm91dGVyKCR7bmFtZX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIFdpdGhSb3V0ZXJXcmFwcGVyO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoLXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0Iiwid2l0aFJvdXRlciIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfcm91dGVyIiwiQ29tcG9zZWRDb21wb25lbnQiLCJXaXRoUm91dGVyV3JhcHBlciIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsImFzc2lnbiIsInJvdXRlciIsInVzZVJvdXRlciIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJwcm9jZXNzIiwibmFtZSIsImRpc3BsYXlOYW1lIiwiX19lc01vZHVsZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/with-router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/pages/_app.js":
/*!**********************************************!*\
  !*** ./node_modules/next/dist/pages/_app.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nfunction appGetInitialProps(_) {\n    return _appGetInitialProps.apply(this, arguments);\n}\nfunction _appGetInitialProps() {\n    _appGetInitialProps = /**\n * `App` component is used for initialize of pages. It allows for overwriting and full control of the `page` initialization.\n * This allows for keeping state between navigation, custom error handling, injecting additional data.\n */ _async_to_generator(function*(param) {\n        let { Component , ctx  } = param;\n        const pageProps = yield (0, _utils).loadGetInitialProps(Component, ctx);\n        return {\n            pageProps\n        };\n    });\n    return _appGetInitialProps.apply(this, arguments);\n}\nvar _Component;\nclass App extends (_Component = _react.default.Component) {\n    render() {\n        const { Component , pageProps  } = this.props;\n        return /*#__PURE__*/ _react.default.createElement(Component, Object.assign({}, pageProps));\n    }\n}\nApp.origGetInitialProps = appGetInitialProps;\nApp.getInitialProps = appGetInitialProps;\nexports[\"default\"] = App; //# sourceMappingURL=_app.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3BhZ2VzL19hcHAuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlHLHNCQUFzQkMseUlBQTBEO0FBQ3BGLElBQUlDLDJCQUEyQkQsbUpBQStEO0FBQzlGLElBQUlFLFNBQVNELHlCQUF5QkQsbUJBQU9BLENBQUMsK0RBQU87QUFDckQsSUFBSUcsU0FBU0gsbUJBQU9BLENBQUMseUVBQXFCO0FBQzFDLFNBQVNJLG1CQUFtQkMsQ0FBQyxFQUFFO0lBQzNCLE9BQU9DLG9CQUFvQkMsS0FBSyxDQUFDLElBQUksRUFBRUM7QUFDM0M7QUFDQSxTQUFTRixzQkFBc0I7SUFDM0JBLHNCQUFzQjs7O0NBR3pCLEdBQUdQLG9CQUFvQixVQUFVLEtBQW9CLEVBQUU7WUFBdEIsRUFBRVUsVUFBUyxFQUFHQyxJQUFHLEVBQUcsR0FBcEI7UUFDMUIsTUFBTUMsWUFBWSxNQUFNLENBQUMsR0FBR1IsTUFBTSxFQUFFUyxtQkFBbUIsQ0FBQ0gsV0FBV0M7UUFDbkUsT0FBTztZQUNIQztRQUNKO0lBQ0o7SUFDQSxPQUFPTCxvQkFBb0JDLEtBQUssQ0FBQyxJQUFJLEVBQUVDO0FBQzNDO0FBQ0EsSUFBSUs7QUFDSixNQUFNQyxZQUFhRCxDQUFBQSxhQUFhWCxPQUFPSixPQUFPLENBQUNXLFNBQVM7SUFDcERNLFNBQVM7UUFDTCxNQUFNLEVBQUVOLFVBQVMsRUFBR0UsVUFBUyxFQUFHLEdBQUcsSUFBSSxDQUFDSyxLQUFLO1FBQzdDLE9BQU8sV0FBVyxHQUFHZCxPQUFPSixPQUFPLENBQUNtQixhQUFhLENBQUNSLFdBQVdmLE9BQU93QixNQUFNLENBQUMsQ0FBQyxHQUFHUDtJQUNuRjtBQUNKO0FBQ0FHLElBQUlLLG1CQUFtQixHQUFHZjtBQUMxQlUsSUFBSU0sZUFBZSxHQUFHaEI7QUFDdEJSLGtCQUFlLEdBQUdrQixLQUVsQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9wYWdlcy9fYXBwLmpzPzk2MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi91dGlsc1wiKTtcbmZ1bmN0aW9uIGFwcEdldEluaXRpYWxQcm9wcyhfKSB7XG4gICAgcmV0dXJuIF9hcHBHZXRJbml0aWFsUHJvcHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9hcHBHZXRJbml0aWFsUHJvcHMoKSB7XG4gICAgX2FwcEdldEluaXRpYWxQcm9wcyA9IC8qKlxuICogYEFwcGAgY29tcG9uZW50IGlzIHVzZWQgZm9yIGluaXRpYWxpemUgb2YgcGFnZXMuIEl0IGFsbG93cyBmb3Igb3ZlcndyaXRpbmcgYW5kIGZ1bGwgY29udHJvbCBvZiB0aGUgYHBhZ2VgIGluaXRpYWxpemF0aW9uLlxuICogVGhpcyBhbGxvd3MgZm9yIGtlZXBpbmcgc3RhdGUgYmV0d2VlbiBuYXZpZ2F0aW9uLCBjdXN0b20gZXJyb3IgaGFuZGxpbmcsIGluamVjdGluZyBhZGRpdGlvbmFsIGRhdGEuXG4gKi8gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooeyBDb21wb25lbnQgLCBjdHggIH0pIHtcbiAgICAgICAgY29uc3QgcGFnZVByb3BzID0geWllbGQgKDAsIF91dGlscykubG9hZEdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYWdlUHJvcHNcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gX2FwcEdldEluaXRpYWxQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxudmFyIF9Db21wb25lbnQ7XG5jbGFzcyBBcHAgZXh0ZW5kcyAoX0NvbXBvbmVudCA9IF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCkge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQgLCBwYWdlUHJvcHMgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7fSwgcGFnZVByb3BzKSk7XG4gICAgfVxufVxuQXBwLm9yaWdHZXRJbml0aWFsUHJvcHMgPSBhcHBHZXRJbml0aWFsUHJvcHM7XG5BcHAuZ2V0SW5pdGlhbFByb3BzID0gYXBwR2V0SW5pdGlhbFByb3BzO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXBwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXBwLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9yZWFjdCIsIl91dGlscyIsImFwcEdldEluaXRpYWxQcm9wcyIsIl8iLCJfYXBwR2V0SW5pdGlhbFByb3BzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJDb21wb25lbnQiLCJjdHgiLCJwYWdlUHJvcHMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiX0NvbXBvbmVudCIsIkFwcCIsInJlbmRlciIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsImFzc2lnbiIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJnZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/pages/_app.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/pages/_error.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/pages/_error.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _head = _interop_require_default(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nconst statusCodes = {\n    400: \"Bad Request\",\n    404: \"This page could not be found\",\n    405: \"Method Not Allowed\",\n    500: \"Internal Server Error\"\n};\nfunction _getInitialProps(param) {\n    let { res , err  } = param;\n    const statusCode = res && res.statusCode ? res.statusCode : err ? err.statusCode : 404;\n    return {\n        statusCode\n    };\n}\nconst styles = {\n    error: {\n        fontFamily: '-apple-system, BlinkMacSystemFont, Roboto, \"Segoe UI\", \"Fira Sans\", Avenir, \"Helvetica Neue\", \"Lucida Grande\", sans-serif',\n        height: \"100vh\",\n        textAlign: \"center\",\n        display: \"flex\",\n        flexDirection: \"column\",\n        alignItems: \"center\",\n        justifyContent: \"center\"\n    },\n    desc: {\n        display: \"inline-block\",\n        textAlign: \"left\",\n        lineHeight: \"49px\",\n        height: \"49px\",\n        verticalAlign: \"middle\"\n    },\n    h1: {\n        display: \"inline-block\",\n        margin: 0,\n        marginRight: \"20px\",\n        padding: \"0 23px 0 0\",\n        fontSize: \"24px\",\n        fontWeight: 500,\n        verticalAlign: \"top\",\n        lineHeight: \"49px\"\n    },\n    h2: {\n        fontSize: \"14px\",\n        fontWeight: \"normal\",\n        lineHeight: \"49px\",\n        margin: 0,\n        padding: 0\n    }\n};\nvar _Component;\nclass Error extends (_Component = _react.default.Component) {\n    render() {\n        const { statusCode , withDarkMode =true  } = this.props;\n        const title = this.props.title || statusCodes[statusCode] || \"An unexpected error has occurred\";\n        return /*#__PURE__*/ _react.default.createElement(\"div\", {\n            style: styles.error\n        }, /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"title\", null, statusCode ? \"\".concat(statusCode, \": \").concat(title) : \"Application error: a client-side exception has occurred\")), /*#__PURE__*/ _react.default.createElement(\"div\", null, /*#__PURE__*/ _react.default.createElement(\"style\", {\n            dangerouslySetInnerHTML: {\n                __html: \"\\n                body { margin: 0; color: #000; background: #fff; }\\n                .next-error-h1 {\\n                  border-right: 1px solid rgba(0, 0, 0, .3);\\n                }\\n\\n                \".concat(withDarkMode ? \"@media (prefers-color-scheme: dark) {\\n                  body { color: #fff; background: #000; }\\n                  .next-error-h1 {\\n                    border-right: 1px solid rgba(255, 255, 255, .3);\\n                  }\\n                }\" : \"\")\n            }\n        }), statusCode ? /*#__PURE__*/ _react.default.createElement(\"h1\", {\n            className: \"next-error-h1\",\n            style: styles.h1\n        }, statusCode) : null, /*#__PURE__*/ _react.default.createElement(\"div\", {\n            style: styles.desc\n        }, /*#__PURE__*/ _react.default.createElement(\"h2\", {\n            style: styles.h2\n        }, this.props.title || statusCode ? title : /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, \"Application error: a client-side exception has occurred (see the browser console for more information)\"), \".\"))));\n    }\n}\nError.displayName = \"ErrorPage\";\nError.getInitialProps = _getInitialProps;\nError.origGetInitialProps = _getInitialProps;\nexports[\"default\"] = Error; //# sourceMappingURL=_error.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3BhZ2VzL19lcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUcsMkJBQTJCQyxtSkFBK0Q7QUFDOUYsSUFBSUMsU0FBU0YseUJBQXlCQyxtQkFBT0EsQ0FBQywrREFBTztBQUNyRCxJQUFJRSxRQUFRSCx5QkFBeUJDLG1CQUFPQSxDQUFDLHVFQUFvQjtBQUNqRSxNQUFNRyxjQUFjO0lBQ2hCLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7QUFDVDtBQUNBLFNBQVNDLGlCQUFpQixLQUFjLEVBQUU7UUFBaEIsRUFBRUMsSUFBRyxFQUFHQyxJQUFHLEVBQUcsR0FBZDtJQUN0QixNQUFNQyxhQUFhRixPQUFPQSxJQUFJRSxVQUFVLEdBQUdGLElBQUlFLFVBQVUsR0FBR0QsTUFBTUEsSUFBSUMsVUFBVSxHQUFHLEdBQUc7SUFDdEYsT0FBTztRQUNIQTtJQUNKO0FBQ0o7QUFDQSxNQUFNQyxTQUFTO0lBQ1hDLE9BQU87UUFDSEMsWUFBWTtRQUNaQyxRQUFRO1FBQ1JDLFdBQVc7UUFDWEMsU0FBUztRQUNUQyxlQUFlO1FBQ2ZDLFlBQVk7UUFDWkMsZ0JBQWdCO0lBQ3BCO0lBQ0FDLE1BQU07UUFDRkosU0FBUztRQUNURCxXQUFXO1FBQ1hNLFlBQVk7UUFDWlAsUUFBUTtRQUNSUSxlQUFlO0lBQ25CO0lBQ0FDLElBQUk7UUFDQVAsU0FBUztRQUNUUSxRQUFRO1FBQ1JDLGFBQWE7UUFDYkMsU0FBUztRQUNUQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWk4sZUFBZTtRQUNmRCxZQUFZO0lBQ2hCO0lBQ0FRLElBQUk7UUFDQUYsVUFBVTtRQUNWQyxZQUFZO1FBQ1pQLFlBQVk7UUFDWkcsUUFBUTtRQUNSRSxTQUFTO0lBQ2I7QUFDSjtBQUNBLElBQUlJO0FBQ0osTUFBTUMsY0FBZUQsQ0FBQUEsYUFBYTFCLE9BQU9ILE9BQU8sQ0FBQytCLFNBQVM7SUFDdERDLFNBQVM7UUFDTCxNQUFNLEVBQUV2QixXQUFVLEVBQUd3QixjQUFjLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQ0MsS0FBSztRQUN2RCxNQUFNQyxRQUFRLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxLQUFLLElBQUk5QixXQUFXLENBQUNJLFdBQVcsSUFBSTtRQUM3RCxPQUFPLFdBQVcsR0FBR04sT0FBT0gsT0FBTyxDQUFDb0MsYUFBYSxDQUFDLE9BQU87WUFDckRDLE9BQU8zQixPQUFPQyxLQUFLO1FBQ3ZCLEdBQUcsV0FBVyxHQUFHUixPQUFPSCxPQUFPLENBQUNvQyxhQUFhLENBQUNoQyxNQUFNSixPQUFPLEVBQUUsSUFBSSxFQUFFLFdBQVcsR0FBR0csT0FBT0gsT0FBTyxDQUFDb0MsYUFBYSxDQUFDLFNBQVMsSUFBSSxFQUFFM0IsYUFBYSxHQUFrQjBCLE9BQWYxQixZQUFXLE1BQVUsT0FBTjBCLFNBQVUseURBQXlELElBQUksV0FBVyxHQUFHaEMsT0FBT0gsT0FBTyxDQUFDb0MsYUFBYSxDQUFDLE9BQU8sSUFBSSxFQUFFLFdBQVcsR0FBR2pDLE9BQU9ILE9BQU8sQ0FBQ29DLGFBQWEsQ0FBQyxTQUFTO1lBQzNVRSx5QkFBeUI7Z0JBQ3JCQyxRQUFRLDhNQVdBLE9BTE5OLGVBQWdCLHVQQUtiLEVBQUU7WUFDWDtRQUNKLElBQUl4QixhQUFhLFdBQVcsR0FBR04sT0FBT0gsT0FBTyxDQUFDb0MsYUFBYSxDQUFDLE1BQU07WUFDOURJLFdBQVc7WUFDWEgsT0FBTzNCLE9BQU9ZLEVBQUU7UUFDcEIsR0FBR2IsY0FBYyxJQUFJLEVBQUUsV0FBVyxHQUFHTixPQUFPSCxPQUFPLENBQUNvQyxhQUFhLENBQUMsT0FBTztZQUNyRUMsT0FBTzNCLE9BQU9TLElBQUk7UUFDdEIsR0FBRyxXQUFXLEdBQUdoQixPQUFPSCxPQUFPLENBQUNvQyxhQUFhLENBQUMsTUFBTTtZQUNoREMsT0FBTzNCLE9BQU9rQixFQUFFO1FBQ3BCLEdBQUcsSUFBSSxDQUFDTSxLQUFLLENBQUNDLEtBQUssSUFBSTFCLGFBQWEwQixRQUFRLFdBQVcsR0FBR2hDLE9BQU9ILE9BQU8sQ0FBQ29DLGFBQWEsQ0FBQ2pDLE9BQU9ILE9BQU8sQ0FBQ3lDLFFBQVEsRUFBRSxJQUFJLEVBQUUseUdBQXlHLEVBQUU7SUFDck87QUFDSjtBQUNBWCxNQUFNWSxXQUFXLEdBQUc7QUFDcEJaLE1BQU1hLGVBQWUsR0FBR3JDO0FBQ3hCd0IsTUFBTWMsbUJBQW1CLEdBQUd0QztBQUM1QlIsa0JBQWUsR0FBR2dDLE9BRWxCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3BhZ2VzL19lcnJvci5qcz8xOGYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2hlYWRcIikpO1xuY29uc3Qgc3RhdHVzQ29kZXMgPSB7XG4gICAgNDAwOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwNDogJ1RoaXMgcGFnZSBjb3VsZCBub3QgYmUgZm91bmQnLFxuICAgIDQwNTogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gICAgNTAwOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yJ1xufTtcbmZ1bmN0aW9uIF9nZXRJbml0aWFsUHJvcHMoeyByZXMgLCBlcnIgIH0pIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzICYmIHJlcy5zdGF0dXNDb2RlID8gcmVzLnN0YXR1c0NvZGUgOiBlcnIgPyBlcnIuc3RhdHVzQ29kZSA6IDQwNDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXNDb2RlXG4gICAgfTtcbn1cbmNvbnN0IHN0eWxlcyA9IHtcbiAgICBlcnJvcjoge1xuICAgICAgICBmb250RmFtaWx5OiAnLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBSb2JvdG8sIFwiU2Vnb2UgVUlcIiwgXCJGaXJhIFNhbnNcIiwgQXZlbmlyLCBcIkhlbHZldGljYSBOZXVlXCIsIFwiTHVjaWRhIEdyYW5kZVwiLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgfSxcbiAgICBkZXNjOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgbGluZUhlaWdodDogJzQ5cHgnLFxuICAgICAgICBoZWlnaHQ6ICc0OXB4JyxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZSdcbiAgICB9LFxuICAgIGgxOiB7XG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIG1hcmdpblJpZ2h0OiAnMjBweCcsXG4gICAgICAgIHBhZGRpbmc6ICcwIDIzcHggMCAwJyxcbiAgICAgICAgZm9udFNpemU6ICcyNHB4JyxcbiAgICAgICAgZm9udFdlaWdodDogNTAwLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgICAgbGluZUhlaWdodDogJzQ5cHgnXG4gICAgfSxcbiAgICBoMjoge1xuICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcbiAgICAgICAgbGluZUhlaWdodDogJzQ5cHgnLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9XG59O1xudmFyIF9Db21wb25lbnQ7XG5jbGFzcyBFcnJvciBleHRlbmRzIChfQ29tcG9uZW50ID0gX3JlYWN0LmRlZmF1bHQuQ29tcG9uZW50KSB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1c0NvZGUgLCB3aXRoRGFya01vZGUgPXRydWUgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMucHJvcHMudGl0bGUgfHwgc3RhdHVzQ29kZXNbc3RhdHVzQ29kZV0gfHwgJ0FuIHVuZXhwZWN0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJztcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBzdHlsZTogc3R5bGVzLmVycm9yXG4gICAgICAgIH0sIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZC5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBzdGF0dXNDb2RlID8gYCR7c3RhdHVzQ29kZX06ICR7dGl0bGV9YCA6ICdBcHBsaWNhdGlvbiBlcnJvcjogYSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkJykpLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwge1xuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IGBcbiAgICAgICAgICAgICAgICBib2R5IHsgbWFyZ2luOiAwOyBjb2xvcjogIzAwMDsgYmFja2dyb3VuZDogI2ZmZjsgfVxuICAgICAgICAgICAgICAgIC5uZXh0LWVycm9yLWgxIHtcbiAgICAgICAgICAgICAgICAgIGJvcmRlci1yaWdodDogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgLjMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICR7d2l0aERhcmtNb2RlID8gYEBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcbiAgICAgICAgICAgICAgICAgIGJvZHkgeyBjb2xvcjogI2ZmZjsgYmFja2dyb3VuZDogIzAwMDsgfVxuICAgICAgICAgICAgICAgICAgLm5leHQtZXJyb3ItaDEge1xuICAgICAgICAgICAgICAgICAgICBib3JkZXItcmlnaHQ6IDFweCBzb2xpZCByZ2JhKDI1NSwgMjU1LCAyNTUsIC4zKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9YCA6ICcnfWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIHN0YXR1c0NvZGUgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwibmV4dC1lcnJvci1oMVwiLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlcy5oMVxuICAgICAgICB9LCBzdGF0dXNDb2RlKSA6IG51bGwsIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICBzdHlsZTogc3R5bGVzLmRlc2NcbiAgICAgICAgfSwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwge1xuICAgICAgICAgICAgc3R5bGU6IHN0eWxlcy5oMlxuICAgICAgICB9LCB0aGlzLnByb3BzLnRpdGxlIHx8IHN0YXR1c0NvZGUgPyB0aXRsZSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgXCJBcHBsaWNhdGlvbiBlcnJvcjogYSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkIChzZWUgdGhlIGJyb3dzZXIgY29uc29sZSBmb3IgbW9yZSBpbmZvcm1hdGlvbilcIiksIFwiLlwiKSkpKTtcbiAgICB9XG59XG5FcnJvci5kaXNwbGF5TmFtZSA9ICdFcnJvclBhZ2UnO1xuRXJyb3IuZ2V0SW5pdGlhbFByb3BzID0gX2dldEluaXRpYWxQcm9wcztcbkVycm9yLm9yaWdHZXRJbml0aWFsUHJvcHMgPSBfZ2V0SW5pdGlhbFByb3BzO1xuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9lcnJvci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl9oZWFkIiwic3RhdHVzQ29kZXMiLCJfZ2V0SW5pdGlhbFByb3BzIiwicmVzIiwiZXJyIiwic3RhdHVzQ29kZSIsInN0eWxlcyIsImVycm9yIiwiZm9udEZhbWlseSIsImhlaWdodCIsInRleHRBbGlnbiIsImRpc3BsYXkiLCJmbGV4RGlyZWN0aW9uIiwiYWxpZ25JdGVtcyIsImp1c3RpZnlDb250ZW50IiwiZGVzYyIsImxpbmVIZWlnaHQiLCJ2ZXJ0aWNhbEFsaWduIiwiaDEiLCJtYXJnaW4iLCJtYXJnaW5SaWdodCIsInBhZGRpbmciLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJoMiIsIl9Db21wb25lbnQiLCJFcnJvciIsIkNvbXBvbmVudCIsInJlbmRlciIsIndpdGhEYXJrTW9kZSIsInByb3BzIiwidGl0bGUiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsImNsYXNzTmFtZSIsIkZyYWdtZW50IiwiZGlzcGxheU5hbWUiLCJnZXRJbml0aWFsUHJvcHMiLCJvcmlnR2V0SW5pdGlhbFByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/pages/_error.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/amp-context.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AmpStateContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nexports.AmpStateContext = AmpStateContext;\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLCtEQUFPO0FBQ3JELE1BQU1GLGtCQUFrQkksT0FBT0QsT0FBTyxDQUFDRSxhQUFhLENBQUMsQ0FBQztBQUN0RFAsdUJBQXVCLEdBQUdFO0FBQzFCLElBQUlNLElBQXlCLEVBQWM7SUFDdkNOLGdCQUFnQk8sV0FBVyxHQUFHO0FBQ2xDLENBQUMsQ0FFRCx1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FtcC1jb250ZXh0LmpzP2U1YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFtcFN0YXRlQ29udGV4dCA9IHZvaWQgMDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IEFtcFN0YXRlQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQoe30pO1xuZXhwb3J0cy5BbXBTdGF0ZUNvbnRleHQgPSBBbXBTdGF0ZUNvbnRleHQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIEFtcFN0YXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdBbXBTdGF0ZUNvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBbXBTdGF0ZUNvbnRleHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9yZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/amp-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isInAmpMode = isInAmpMode;\nfunction isInAmpMode() {\n    let { ampFirst =false , hybrid =false , hasQuery =false  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsbUJBQW1CLEdBQUdFO0FBQ3RCLFNBQVNBLGNBQTJFO1FBQS9ELEVBQUVDLFVBQVUsS0FBSyxHQUFHQyxRQUFRLEtBQUssR0FBR0MsVUFBVSxLQUFLLEdBQUssR0FBeEQsaUVBQTJELENBQUMsQ0FBQztJQUM5RSxPQUFPRixZQUFZQyxVQUFVQztBQUNqQyxFQUVBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanM/NjIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNJbkFtcE1vZGUgPSBpc0luQW1wTW9kZTtcbmZ1bmN0aW9uIGlzSW5BbXBNb2RlKHsgYW1wRmlyc3QgPWZhbHNlICwgaHlicmlkID1mYWxzZSAsIGhhc1F1ZXJ5ID1mYWxzZSAsICB9ID0ge30pIHtcbiAgICByZXR1cm4gYW1wRmlyc3QgfHwgaHlicmlkICYmIGhhc1F1ZXJ5O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtbW9kZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0luQW1wTW9kZSIsImFtcEZpcnN0IiwiaHlicmlkIiwiaGFzUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/escape-regexp.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/escape-regexp.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.escapeStringRegexp = escapeStringRegexp;\n// regexp is based on https://github.com/sindresorhus/escape-string-regexp\nconst reHasRegExp = /[|\\\\{}()[\\]^$+*?.-]/;\nconst reReplaceRegExp = /[|\\\\{}()[\\]^$+*?.-]/g;\nfunction escapeStringRegexp(str) {\n    // see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23\n    if (reHasRegExp.test(str)) {\n        return str.replace(reReplaceRegExp, \"\\\\$&\");\n    }\n    return str;\n} //# sourceMappingURL=escape-regexp.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZXNjYXBlLXJlZ2V4cC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwwQkFBMEIsR0FBR0U7QUFDN0IsMEVBQTBFO0FBQzFFLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsa0JBQWtCO0FBQ3hCLFNBQVNGLG1CQUFtQkcsR0FBRyxFQUFFO0lBQzdCLCtHQUErRztJQUMvRyxJQUFJRixZQUFZRyxJQUFJLENBQUNELE1BQU07UUFDdkIsT0FBT0EsSUFBSUUsT0FBTyxDQUFDSCxpQkFBaUI7SUFDeEMsQ0FBQztJQUNELE9BQU9DO0FBQ1gsRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2VzY2FwZS1yZWdleHAuanM/ZGJmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXNjYXBlU3RyaW5nUmVnZXhwID0gZXNjYXBlU3RyaW5nUmVnZXhwO1xuLy8gcmVnZXhwIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvZXNjYXBlLXN0cmluZy1yZWdleHBcbmNvbnN0IHJlSGFzUmVnRXhwID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vO1xuY29uc3QgcmVSZXBsYWNlUmVnRXhwID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZztcbmZ1bmN0aW9uIGVzY2FwZVN0cmluZ1JlZ2V4cChzdHIpIHtcbiAgICAvLyBzZWUgYWxzbzogaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi8yZGEwMjRjM2I0Zjk5NDdhNDg1MTc2MzlkZTc1NjA0NTdjZDRlYzZjL2VzY2FwZVJlZ0V4cC5qcyNMMjNcbiAgICBpZiAocmVIYXNSZWdFeHAudGVzdChzdHIpKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZVJlcGxhY2VSZWdFeHAsICdcXFxcJCYnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjYXBlLXJlZ2V4cC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJyZUhhc1JlZ0V4cCIsInJlUmVwbGFjZVJlZ0V4cCIsInN0ciIsInRlc3QiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/escape-regexp.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defaultHead = defaultHead;\nexports[\"default\"] = void 0;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _sideEffect = _interop_require_default(__webpack_require__(/*! ./side-effect */ \"./node_modules/next/dist/shared/lib/side-effect.js\"));\nvar _ampContext = __webpack_require__(/*! ./amp-context */ \"./node_modules/next/dist/shared/lib/amp-context.js\");\nvar _headManagerContext = __webpack_require__(/*! ./head-manager-context */ \"./node_modules/next/dist/shared/lib/head-manager-context.js\");\nvar _ampMode = __webpack_require__(/*! ./amp-mode */ \"./node_modules/next/dist/shared/lib/amp-mode.js\");\nvar _warnOnce = __webpack_require__(/*! ./utils/warn-once */ \"./node_modules/next/dist/shared/lib/utils/warn-once.js\");\n\"use client\";\nfunction defaultHead() {\n    let inAmpMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n    const head = [\n        /*#__PURE__*/ _react.default.createElement(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ _react.default.createElement(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode  } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"'.concat(c.props[\"src\"], '\"') : \"inline <script>\";\n                (0, _warnOnce).warnOnce(\"Do not add <script> tags using next/head (see \".concat(srcMessage, \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\"));\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnOnce).warnOnce('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"'.concat(c.props[\"href\"], '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component'));\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children  } = param;\n    _s();\n    const ampState = (0, _react).useContext(_ampContext.AmpStateContext);\n    const headManager = (0, _react).useContext(_headManagerContext.HeadManagerContext);\n    return /*#__PURE__*/ _react.default.createElement(_sideEffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampMode).isInAmpMode(ampState)\n    }, children);\n}\n_s(Head, \"sCUayZmr5V93tUjujy03KdMBCec=\");\n_c = Head;\nvar _default = Head;\nexports[\"default\"] = _default;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsbUJBQW1CLEdBQUdFO0FBQ3RCRixrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUksV0FBV0MsbUhBQStDO0FBQzlELElBQUlDLDJCQUEyQkQsbUpBQStEO0FBQzlGLElBQUlFLDRCQUE0QkYscUpBQWdFO0FBQ2hHLElBQUlHLFNBQVNELDBCQUEwQkYsbUJBQU9BLENBQUMsK0RBQU87QUFDdEQsSUFBSUksY0FBY0gseUJBQXlCRCxtQkFBT0EsQ0FBQyx5RUFBZTtBQUNsRSxJQUFJSyxjQUFjTCxtQkFBT0EsQ0FBQyx5RUFBZTtBQUN6QyxJQUFJTSxzQkFBc0JOLG1CQUFPQSxDQUFDLDJGQUF3QjtBQUMxRCxJQUFJTyxXQUFXUCxtQkFBT0EsQ0FBQyxtRUFBWTtBQUNuQyxJQUFJUSxZQUFZUixtQkFBT0EsQ0FBQyxpRkFBbUI7QUFDM0M7QUFDQSxTQUFTSCxjQUErQjtRQUFuQlksWUFBQUEsaUVBQVksS0FBSztJQUNsQyxNQUFNQyxPQUFPO1FBQ1QsV0FBVyxHQUFHUCxPQUFPTCxPQUFPLENBQUNhLGFBQWEsQ0FBQyxRQUFRO1lBQy9DQyxTQUFTO1FBQ2I7S0FDSDtJQUNELElBQUksQ0FBQ0gsV0FBVztRQUNaQyxLQUFLRyxJQUFJLENBQUMsV0FBVyxHQUFHVixPQUFPTCxPQUFPLENBQUNhLGFBQWEsQ0FBQyxRQUFRO1lBQ3pERyxNQUFNO1lBQ05DLFNBQVM7UUFDYjtJQUNKLENBQUM7SUFDRCxPQUFPTDtBQUNYO0FBQ0EsU0FBU00saUJBQWlCQyxJQUFJLEVBQUVDLEtBQUssRUFBRTtJQUNuQyw4RkFBOEY7SUFDOUYsSUFBSSxPQUFPQSxVQUFVLFlBQVksT0FBT0EsVUFBVSxVQUFVO1FBQ3hELE9BQU9EO0lBQ1gsQ0FBQztJQUNELGtDQUFrQztJQUNsQyxJ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LEdBQUd0RSxPQUFPTCxPQUFPLENBQUNhLGFBQWEsQ0FBQ1AsWUFBWU4sT0FBTyxFQUFFO1FBQ25FNEUseUJBQXlCdkI7UUFDekJxQixhQUFhQTtRQUNiL0QsV0FBVyxDQUFDLEdBQUdGLFFBQVEsRUFBRW9FLFdBQVcsQ0FBQ047SUFDekMsR0FBRzVDO0FBQ1A7R0FSYTJDO0tBQUFBO0FBU2IsSUFBSVEsV0FBV1I7QUFDZnpFLGtCQUFlLEdBQUdpRjtBQUVsQixJQUFJLENBQUMsT0FBT2pGLFFBQVFHLE9BQU8sS0FBSyxjQUFlLE9BQU9ILFFBQVFHLE9BQU8sS0FBSyxZQUFZSCxRQUFRRyxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9ILFFBQVFHLE9BQU8sQ0FBQytFLFVBQVUsS0FBSyxhQUFhO0lBQ3JLcEYsT0FBT0MsY0FBYyxDQUFDQyxRQUFRRyxPQUFPLEVBQUUsY0FBYztRQUFFRixPQUFPLElBQUk7SUFBQztJQUNuRUgsT0FBT3FGLE1BQU0sQ0FBQ25GLFFBQVFHLE9BQU8sRUFBRUg7SUFDL0JvRixPQUFPcEYsT0FBTyxHQUFHQSxRQUFRRyxPQUFPO0FBQ2xDLENBQUMsQ0FFRCxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2hlYWQuanM/ZmI1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0SGVhZCA9IGRlZmF1bHRIZWFkO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfc2lkZUVmZmVjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi9zaWRlLWVmZmVjdFwiKSk7XG52YXIgX2FtcENvbnRleHQgPSByZXF1aXJlKFwiLi9hbXAtY29udGV4dFwiKTtcbnZhciBfaGVhZE1hbmFnZXJDb250ZXh0ID0gcmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyLWNvbnRleHRcIik7XG52YXIgX2FtcE1vZGUgPSByZXF1aXJlKFwiLi9hbXAtbW9kZVwiKTtcbnZhciBfd2Fybk9uY2UgPSByZXF1aXJlKFwiLi91dGlscy93YXJuLW9uY2VcIik7XG4ndXNlIGNsaWVudCc7XG5mdW5jdGlvbiBkZWZhdWx0SGVhZChpbkFtcE1vZGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGhlYWQgPSBbXG4gICAgICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAgICAgICAgY2hhclNldDogXCJ1dGYtOFwiXG4gICAgICAgIH0pXG4gICAgXTtcbiAgICBpZiAoIWluQW1wTW9kZSkge1xuICAgICAgICBoZWFkLnB1c2goLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KGxpc3QsIGNoaWxkKSB7XG4gICAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBsaXN0LmNvbmNhdChfcmVhY3QuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkLnByb3BzLmNoaWxkcmVuKS5yZWR1Y2UoKGZyYWdtZW50TGlzdCwgZnJhZ21lbnRDaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGZyYWdtZW50Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3QuY29uY2F0KGZyYWdtZW50Q2hpbGQpO1xuICAgICAgICB9LCBbXSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpO1xufVxuY29uc3QgTUVUQVRZUEVTID0gW1xuICAgICduYW1lJyxcbiAgICAnaHR0cEVxdWl2JyxcbiAgICAnY2hhclNldCcsXG4gICAgJ2l0ZW1Qcm9wJ1xuXTtcbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qLyBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhQ2F0ZWdvcmllcyA9IHt9O1xuICAgIHJldHVybiAoaCk9PntcbiAgICAgICAgbGV0IGlzVW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICAgICAgICBoYXNLZXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gaC5rZXkuc2xpY2UoaC5rZXkuaW5kZXhPZignJCcpICsgMSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2goaC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICAgICAgICAgIGlmICh0YWdzLmhhcyhoLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFncy5hZGQoaC50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gJ2NoYXJTZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YVR5cGVzLmhhcyhtZXRhdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhVHlwZXMuYWRkKG1ldGF0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgobWV0YXR5cGUgIT09ICduYW1lJyB8fCAhaGFzS2V5KSAmJiBjYXRlZ29yaWVzLmhhcyhjYXRlZ29yeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNVbmlxdWU7XG4gICAgfTtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBoZWFkQ2hpbGRyZW5FbGVtZW50cyBMaXN0IG9mIGNoaWxkcmVuIG9mIDxIZWFkPlxuICovIGZ1bmN0aW9uIHJlZHVjZUNvbXBvbmVudHMoaGVhZENoaWxkcmVuRWxlbWVudHMsIHByb3BzKSB7XG4gICAgY29uc3QgeyBpbkFtcE1vZGUgIH0gPSBwcm9wcztcbiAgICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHMucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKS5yZXZlcnNlKCkuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKS5maWx0ZXIodW5pcXVlKCkpLnJldmVyc2UoKS5tYXAoKGMsIGkpPT57XG4gICAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50JyAmJiBwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JWkVfRk9OVFMgJiYgIWluQW1wTW9kZSkge1xuICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gJ2xpbmsnICYmIGMucHJvcHNbJ2hyZWYnXSAmJiAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MnLFxuICAgICAgICAgICAgICAgICdodHRwczovL3VzZS50eXBla2l0Lm5ldC8nXG4gICAgICAgICAgICBdLnNvbWUoKHVybCk9PmMucHJvcHNbJ2hyZWYnXS5zdGFydHNXaXRoKHVybCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBfZXh0ZW5kcyh7fSwgYy5wcm9wcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbJ2RhdGEtaHJlZiddID0gbmV3UHJvcHNbJ2hyZWYnXTtcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1snaHJlZiddID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGF0dHJpYnV0ZSB0byBtYWtlIGl0IGVhc3kgdG8gaWRlbnRpZnkgb3B0aW1pemVkIHRhZ3NcbiAgICAgICAgICAgICAgICBuZXdQcm9wc1snZGF0YS1vcHRpbWl6ZWQtZm9udHMnXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIC8vIG9taXQgSlNPTi1MRCBzdHJ1Y3R1cmVkIGRhdGEgc25pcHBldHMgZnJvbSB0aGUgd2FybmluZ1xuICAgICAgICAgICAgaWYgKGMudHlwZSA9PT0gJ3NjcmlwdCcgJiYgYy5wcm9wc1sndHlwZSddICE9PSAnYXBwbGljYXRpb24vbGQranNvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNNZXNzYWdlID0gYy5wcm9wc1snc3JjJ10gPyBgPHNjcmlwdD4gdGFnIHdpdGggc3JjPVwiJHtjLnByb3BzWydzcmMnXX1cImAgOiBgaW5saW5lIDxzY3JpcHQ+YDtcbiAgICAgICAgICAgICAgICAoMCwgX3dhcm5PbmNlKS53YXJuT25jZShgRG8gbm90IGFkZCA8c2NyaXB0PiB0YWdzIHVzaW5nIG5leHQvaGVhZCAoc2VlICR7c3JjTWVzc2FnZX0pLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudGApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjLnR5cGUgPT09ICdsaW5rJyAmJiBjLnByb3BzWydyZWwnXSA9PT0gJ3N0eWxlc2hlZXQnKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJuT25jZSkud2Fybk9uY2UoYERvIG5vdCBhZGQgc3R5bGVzaGVldHMgdXNpbmcgbmV4dC9oZWFkIChzZWUgPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiPiB0YWcgd2l0aCBocmVmPVwiJHtjLnByb3BzWydocmVmJ119XCIpLiBVc2UgRG9jdW1lbnQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zdHlsZXNoZWV0cy1pbi1oZWFkLWNvbXBvbmVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNsb25lRWxlbWVudChjLCB7XG4gICAgICAgICAgICBrZXlcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGluamVjdHMgZWxlbWVudHMgdG8gYDxoZWFkPmAgb2YgeW91ciBwYWdlLlxuICogVG8gYXZvaWQgZHVwbGljYXRlZCBgdGFnc2AgaW4gYDxoZWFkPmAgeW91IGNhbiB1c2UgdGhlIGBrZXlgIHByb3BlcnR5LCB3aGljaCB3aWxsIG1ha2Ugc3VyZSBldmVyeSB0YWcgaXMgb25seSByZW5kZXJlZCBvbmNlLlxuICovIGZ1bmN0aW9uIEhlYWQoeyBjaGlsZHJlbiAgfSkge1xuICAgIGNvbnN0IGFtcFN0YXRlID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfYW1wQ29udGV4dC5BbXBTdGF0ZUNvbnRleHQpO1xuICAgIGNvbnN0IGhlYWRNYW5hZ2VyID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaGVhZE1hbmFnZXJDb250ZXh0LkhlYWRNYW5hZ2VyQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfc2lkZUVmZmVjdC5kZWZhdWx0LCB7XG4gICAgICAgIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlOiByZWR1Y2VDb21wb25lbnRzLFxuICAgICAgICBoZWFkTWFuYWdlcjogaGVhZE1hbmFnZXIsXG4gICAgICAgIGluQW1wTW9kZTogKDAsIF9hbXBNb2RlKS5pc0luQW1wTW9kZShhbXBTdGF0ZSlcbiAgICB9LCBjaGlsZHJlbik7XG59XG52YXIgX2RlZmF1bHQgPSBIZWFkO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlYWQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdEhlYWQiLCJkZWZhdWx0IiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZWFjdCIsIl9zaWRlRWZmZWN0IiwiX2FtcENvbnRleHQiLCJfaGVhZE1hbmFnZXJDb250ZXh0IiwiX2FtcE1vZGUiLCJfd2Fybk9uY2UiLCJpbkFtcE1vZGUiLCJoZWFkIiwiY3JlYXRlRWxlbWVudCIsImNoYXJTZXQiLCJwdXNoIiwibmFtZSIsImNvbnRlbnQiLCJvbmx5UmVhY3RFbGVtZW50IiwibGlzdCIsImNoaWxkIiwidHlwZSIsIkZyYWdtZW50IiwiY29uY2F0IiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwicHJvcHMiLCJjaGlsZHJlbiIsInJlZHVjZSIsImZyYWdtZW50TGlzdCIsImZyYWdtZW50Q2hpbGQiLCJNRVRBVFlQRVMiLCJ1bmlxdWUiLCJrZXlzIiwiU2V0IiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsImlzVW5pcXVlIiwiaGFzS2V5Iiwia2V5IiwiaW5kZXhPZiIsInNsaWNlIiwiaGFzIiwiYWRkIiwiaSIsImxlbiIsImxlbmd0aCIsIm1ldGF0eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYXRlZ29yeSIsImNhdGVnb3JpZXMiLCJyZWR1Y2VDb21wb25lbnRzIiwiaGVhZENoaWxkcmVuRWxlbWVudHMiLCJyZXZlcnNlIiwiZmlsdGVyIiwibWFwIiwiYyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfT1BUSU1JWkVfRk9OVFMiLCJzb21lIiwidXJsIiwic3RhcnRzV2l0aCIsIm5ld1Byb3BzIiwidW5kZWZpbmVkIiwiY2xvbmVFbGVtZW50Iiwic3JjTWVzc2FnZSIsIndhcm5PbmNlIiwiSGVhZCIsImFtcFN0YXRlIiwidXNlQ29udGV4dCIsIkFtcFN0YXRlQ29udGV4dCIsImhlYWRNYW5hZ2VyIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJpc0luQW1wTW9kZSIsIl9kZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizeLocalePath = normalizeLocalePath;\nfunction normalizeLocalePath(pathname, locales) {\n    let detectedLocale;\n    // first item will be empty string from splitting at first char\n    const pathnameParts = pathname.split(\"/\");\n    (locales || []).some((locale)=>{\n        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {\n            detectedLocale = locale;\n            pathnameParts.splice(1, 1);\n            pathname = pathnameParts.join(\"/\") || \"/\";\n            return true;\n        }\n        return false;\n    });\n    return {\n        pathname,\n        detectedLocale\n    };\n} //# sourceMappingURL=normalize-locale-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMkJBQTJCLEdBQUdFO0FBQzlCLFNBQVNBLG9CQUFvQkMsUUFBUSxFQUFFQyxPQUFPLEVBQUU7SUFDNUMsSUFBSUM7SUFDSiwrREFBK0Q7SUFDL0QsTUFBTUMsZ0JBQWdCSCxTQUFTSSxLQUFLLENBQUM7SUFDcENILENBQUFBLFdBQVcsRUFBRSxFQUFFSSxJQUFJLENBQUMsQ0FBQ0MsU0FBUztRQUMzQixJQUFJSCxhQUFhLENBQUMsRUFBRSxJQUFJQSxhQUFhLENBQUMsRUFBRSxDQUFDSSxXQUFXLE9BQU9ELE9BQU9DLFdBQVcsSUFBSTtZQUM3RUwsaUJBQWlCSTtZQUNqQkgsY0FBY0ssTUFBTSxDQUFDLEdBQUc7WUFDeEJSLFdBQVdHLGNBQWNNLElBQUksQ0FBQyxRQUFRO1lBQ3RDLE9BQU8sSUFBSTtRQUNmLENBQUM7UUFDRCxPQUFPLEtBQUs7SUFDaEI7SUFDQSxPQUFPO1FBQ0hUO1FBQ0FFO0lBQ0o7QUFDSixFQUVBLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGguanM/MDQzYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9ybWFsaXplTG9jYWxlUGF0aCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGg7XG5mdW5jdGlvbiBub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lLCBsb2NhbGVzKSB7XG4gICAgbGV0IGRldGVjdGVkTG9jYWxlO1xuICAgIC8vIGZpcnN0IGl0ZW0gd2lsbCBiZSBlbXB0eSBzdHJpbmcgZnJvbSBzcGxpdHRpbmcgYXQgZmlyc3QgY2hhclxuICAgIGNvbnN0IHBhdGhuYW1lUGFydHMgPSBwYXRobmFtZS5zcGxpdCgnLycpO1xuICAgIChsb2NhbGVzIHx8IFtdKS5zb21lKChsb2NhbGUpPT57XG4gICAgICAgIGlmIChwYXRobmFtZVBhcnRzWzFdICYmIHBhdGhuYW1lUGFydHNbMV0udG9Mb3dlckNhc2UoKSA9PT0gbG9jYWxlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGRldGVjdGVkTG9jYWxlID0gbG9jYWxlO1xuICAgICAgICAgICAgcGF0aG5hbWVQYXJ0cy5zcGxpY2UoMSwgMSk7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lUGFydHMuam9pbignLycpIHx8ICcvJztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgZGV0ZWN0ZWRMb2NhbGVcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUtbG9jYWxlLXBhdGguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhdGhuYW1lIiwibG9jYWxlcyIsImRldGVjdGVkTG9jYWxlIiwicGF0aG5hbWVQYXJ0cyIsInNwbGl0Iiwic29tZSIsImxvY2FsZSIsInRvTG93ZXJDYXNlIiwic3BsaWNlIiwiam9pbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-config-context.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ImageConfigContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _imageConfig = __webpack_require__(/*! ./image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageConfig.imageConfigDefault);\nexports.ImageConfigContext = ImageConfigContext;\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLCtEQUFPO0FBQ3JELElBQUlHLGVBQWVILG1CQUFPQSxDQUFDLDJFQUFnQjtBQUMzQyxNQUFNRixxQkFBcUJJLE9BQU9ELE9BQU8sQ0FBQ0csYUFBYSxDQUFDRCxhQUFhRSxrQkFBa0I7QUFDdkZULDBCQUEwQixHQUFHRTtBQUM3QixJQUFJUSxJQUF5QixFQUFjO0lBQ3ZDUixtQkFBbUJTLFdBQVcsR0FBRztBQUNyQyxDQUFDLENBRUQsZ0RBQWdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5qcz8zOWY1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5JbWFnZUNvbmZpZ0NvbnRleHQgPSB2b2lkIDA7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgX2ltYWdlQ29uZmlnID0gcmVxdWlyZShcIi4vaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgSW1hZ2VDb25maWdDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChfaW1hZ2VDb25maWcuaW1hZ2VDb25maWdEZWZhdWx0KTtcbmV4cG9ydHMuSW1hZ2VDb25maWdDb250ZXh0ID0gSW1hZ2VDb25maWdDb250ZXh0O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSAnSW1hZ2VDb25maWdDb250ZXh0Jztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtY29uZmlnLWNvbnRleHQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJfaW1hZ2VDb25maWciLCJjcmVhdGVDb250ZXh0IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-config-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.imageConfigDefault = exports.VALID_LOADERS = void 0;\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nexports.VALID_LOADERS = VALID_LOADERS;\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    remotePatterns: [],\n    unoptimized: false\n};\nexports.imageConfigDefault = imageConfigDefault; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDBCQUEwQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzFELE1BQU1HLGdCQUFnQjtJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDREgscUJBQXFCLEdBQUdHO0FBQ3hCLE1BQU1ELHFCQUFxQjtJQUN2QkUsYUFBYTtRQUNUO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNEQyxZQUFZO1FBQ1I7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0RDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxZQUFZO0lBQ1pDLFNBQVMsRUFBRTtJQUNYQyxxQkFBcUIsS0FBSztJQUMxQkMsaUJBQWlCO0lBQ2pCQyxTQUFTO1FBQ0w7S0FDSDtJQUNEQyxxQkFBcUIsS0FBSztJQUMxQkMsdUJBQXdCO0lBQ3hCQyxnQkFBZ0IsRUFBRTtJQUNsQkMsYUFBYSxLQUFLO0FBQ3RCO0FBQ0FoQiwwQkFBMEIsR0FBR0Usb0JBRTdCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzPzMxMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmltYWdlQ29uZmlnRGVmYXVsdCA9IGV4cG9ydHMuVkFMSURfTE9BREVSUyA9IHZvaWQgMDtcbmNvbnN0IFZBTElEX0xPQURFUlMgPSBbXG4gICAgJ2RlZmF1bHQnLFxuICAgICdpbWdpeCcsXG4gICAgJ2Nsb3VkaW5hcnknLFxuICAgICdha2FtYWknLFxuICAgICdjdXN0b20nLCBcbl07XG5leHBvcnRzLlZBTElEX0xPQURFUlMgPSBWQUxJRF9MT0FERVJTO1xuY29uc3QgaW1hZ2VDb25maWdEZWZhdWx0ID0ge1xuICAgIGRldmljZVNpemVzOiBbXG4gICAgICAgIDY0MCxcbiAgICAgICAgNzUwLFxuICAgICAgICA4MjgsXG4gICAgICAgIDEwODAsXG4gICAgICAgIDEyMDAsXG4gICAgICAgIDE5MjAsXG4gICAgICAgIDIwNDgsXG4gICAgICAgIDM4NDBcbiAgICBdLFxuICAgIGltYWdlU2l6ZXM6IFtcbiAgICAgICAgMTYsXG4gICAgICAgIDMyLFxuICAgICAgICA0OCxcbiAgICAgICAgNjQsXG4gICAgICAgIDk2LFxuICAgICAgICAxMjgsXG4gICAgICAgIDI1NixcbiAgICAgICAgMzg0XG4gICAgXSxcbiAgICBwYXRoOiAnL19uZXh0L2ltYWdlJyxcbiAgICBsb2FkZXI6ICdkZWZhdWx0JyxcbiAgICBsb2FkZXJGaWxlOiAnJyxcbiAgICBkb21haW5zOiBbXSxcbiAgICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgICBtaW5pbXVtQ2FjaGVUVEw6IDYwLFxuICAgIGZvcm1hdHM6IFtcbiAgICAgICAgJ2ltYWdlL3dlYnAnXG4gICAgXSxcbiAgICBkYW5nZXJvdXNseUFsbG93U1ZHOiBmYWxzZSxcbiAgICBjb250ZW50U2VjdXJpdHlQb2xpY3k6IGBzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtgLFxuICAgIHJlbW90ZVBhdHRlcm5zOiBbXSxcbiAgICB1bm9wdGltaXplZDogZmFsc2Vcbn07XG5leHBvcnRzLmltYWdlQ29uZmlnRGVmYXVsdCA9IGltYWdlQ29uZmlnRGVmYXVsdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImltYWdlQ29uZmlnRGVmYXVsdCIsIlZBTElEX0xPQURFUlMiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJwYXRoIiwibG9hZGVyIiwibG9hZGVyRmlsZSIsImRvbWFpbnMiLCJkaXNhYmxlU3RhdGljSW1hZ2VzIiwibWluaW11bUNhY2hlVFRMIiwiZm9ybWF0cyIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJjb250ZW50U2VjdXJpdHlQb2xpY3kiLCJyZW1vdGVQYXR0ZXJucyIsInVub3B0aW1pemVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/is-plain-object.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/is-plain-object.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getObjectClassLabel = getObjectClassLabel;\nexports.isPlainObject = isPlainObject;\nfunction getObjectClassLabel(value) {\n    return Object.prototype.toString.call(value);\n}\nfunction isPlainObject(value) {\n    if (getObjectClassLabel(value) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */ return prototype === null || prototype.hasOwnProperty(\"isPrototypeOf\");\n} //# sourceMappingURL=is-plain-object.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDJCQUEyQixHQUFHRTtBQUM5QkYscUJBQXFCLEdBQUdHO0FBQ3hCLFNBQVNELG9CQUFvQkQsS0FBSyxFQUFFO0lBQ2hDLE9BQU9ILE9BQU9NLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMO0FBQzFDO0FBQ0EsU0FBU0UsY0FBY0YsS0FBSyxFQUFFO0lBQzFCLElBQUlDLG9CQUFvQkQsV0FBVyxtQkFBbUI7UUFDbEQsT0FBTyxLQUFLO0lBQ2hCLENBQUM7SUFDRCxNQUFNRyxZQUFZTixPQUFPUyxjQUFjLENBQUNOO0lBQ3hDOzs7Ozs7OztHQVFELEdBQUcsT0FBT0csY0FBYyxJQUFJLElBQUlBLFVBQVVJLGNBQWMsQ0FBQztBQUM1RCxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaXMtcGxhaW4tb2JqZWN0LmpzPzM3NDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldE9iamVjdENsYXNzTGFiZWwgPSBnZXRPYmplY3RDbGFzc0xhYmVsO1xuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbmZ1bmN0aW9uIGdldE9iamVjdENsYXNzTGFiZWwodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICBpZiAoZ2V0T2JqZWN0Q2xhc3NMYWJlbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAvKipcbiAgICogdGhpcyB1c2VkIHRvIGJlIHByZXZpb3VzbHk6XG4gICAqXG4gICAqIGByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZWBcbiAgICpcbiAgICogYnV0IEVkZ2UgUnVudGltZSBleHBvc2UgT2JqZWN0IGZyb20gdm0sIGJlaW5nIHRoYXQga2luZCBvZiB0eXBlLWNoZWNraW5nIHdyb25nbHkgZmFpbC5cbiAgICpcbiAgICogSXQgd2FzIGNoYW5nZWQgdG8gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gc2luY2UgaXQncyByZXNpbGllbnQgdG8gc2VyaWFsaXphdGlvbi5cbiAgICovIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpc1Byb3RvdHlwZU9mJyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLXBsYWluLW9iamVjdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRPYmplY3RDbGFzc0xhYmVsIiwiaXNQbGFpbk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImdldFByb3RvdHlwZU9mIiwiaGFzT3duUHJvcGVydHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/is-plain-object.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/mitt.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/mitt.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = mitt;\nfunction mitt() {\n    const all = Object.create(null);\n    return {\n        on (type, handler) {\n            (all[type] || (all[type] = [])).push(handler);\n        },\n        off (type, handler) {\n            if (all[type]) {\n                all[type].splice(all[type].indexOf(handler) >>> 0, 1);\n            }\n        },\n        emit (type) {\n            for(var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                evts[_key - 1] = arguments[_key];\n            }\n            (all[type] || []).slice().map((handler)=>{\n                handler(...evts);\n            });\n        }\n    };\n} //# sourceMappingURL=mitt.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWl0dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxrQkFBZSxHQUFHRztBQUNsQixTQUFTQSxPQUFPO0lBQ1osTUFBTUMsTUFBTU4sT0FBT08sTUFBTSxDQUFDLElBQUk7SUFDOUIsT0FBTztRQUNIQyxJQUFJQyxJQUFJLEVBQUVDLE9BQU8sRUFBRTtZQUNkSixDQUFBQSxHQUFHLENBQUNHLEtBQUssSUFBS0gsQ0FBQUEsR0FBRyxDQUFDRyxLQUFLLEdBQUcsRUFBRSxHQUFHRSxJQUFJLENBQUNEO1FBQ3pDO1FBQ0FFLEtBQUtILElBQUksRUFBRUMsT0FBTyxFQUFFO1lBQ2hCLElBQUlKLEdBQUcsQ0FBQ0csS0FBSyxFQUFFO2dCQUNYSCxHQUFHLENBQUNHLEtBQUssQ0FBQ0ksTUFBTSxDQUFDUCxHQUFHLENBQUNHLEtBQUssQ0FBQ0ssT0FBTyxDQUFDSixhQUFhLEdBQUc7WUFDdkQsQ0FBQztRQUNMO1FBQ0FLLE1BQU1OLElBQUksRUFBVztZQUFULHlFQUFPLEdBQVA7Z0JBQUdPLEtBQUgsMkJBQU87WUFBRDtZQUNiVixDQUFBQSxHQUFHLENBQUNHLEtBQUssSUFBSSxFQUFFLEVBQUVRLEtBQUssR0FBR0MsR0FBRyxDQUFDLENBQUNSLFVBQVU7Z0JBQ3JDQSxXQUFXTTtZQUNmO1FBQ0o7SUFDSjtBQUNKLEVBRUEsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9taXR0LmpzPzg1MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtaXR0O1xuZnVuY3Rpb24gbWl0dCgpIHtcbiAgICBjb25zdCBhbGwgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uICh0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9mZiAodHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbWl0ICh0eXBlLCAuLi5ldnRzKSB7XG4gICAgICAgICAgICAoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcCgoaGFuZGxlcik9PntcbiAgICAgICAgICAgICAgICBoYW5kbGVyKC4uLmV2dHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXR0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHQiLCJtaXR0IiwiYWxsIiwiY3JlYXRlIiwib24iLCJ0eXBlIiwiaGFuZGxlciIsInB1c2giLCJvZmYiLCJzcGxpY2UiLCJpbmRleE9mIiwiZW1pdCIsImV2dHMiLCJzbGljZSIsIm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/mitt.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.denormalizePagePath = denormalizePagePath;\nvar _utils = __webpack_require__(/*! ../router/utils */ \"./node_modules/next/dist/shared/lib/router/utils/index.js\");\nvar _normalizePathSep = __webpack_require__(/*! ./normalize-path-sep */ \"./node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js\");\nfunction denormalizePagePath(page) {\n    let _page = (0, _normalizePathSep).normalizePathSep(page);\n    return _page.startsWith(\"/index/\") && !(0, _utils).isDynamicRoute(_page) ? _page.slice(6) : _page !== \"/index\" ? _page : \"/\";\n} //# sourceMappingURL=denormalize-page-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwyQkFBMkIsR0FBR0U7QUFDOUIsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsa0ZBQWlCO0FBQ3RDLElBQUlDLG9CQUFvQkQsbUJBQU9BLENBQUMsaUdBQXNCO0FBQ3RELFNBQVNGLG9CQUFvQkksSUFBSSxFQUFFO0lBQy9CLElBQUlDLFFBQVEsQ0FBQyxHQUFHRixpQkFBaUIsRUFBRUcsZ0JBQWdCLENBQUNGO0lBQ3BELE9BQU9DLE1BQU1FLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxHQUFHTixNQUFNLEVBQUVPLGNBQWMsQ0FBQ0gsU0FBU0EsTUFBTUksS0FBSyxDQUFDLEtBQUtKLFVBQVUsV0FBV0EsUUFBUSxHQUFHO0FBQ2hJLEVBRUEsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzP2RlMGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlbm9ybWFsaXplUGFnZVBhdGggPSBkZW5vcm1hbGl6ZVBhZ2VQYXRoO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9yb3V0ZXIvdXRpbHNcIik7XG52YXIgX25vcm1hbGl6ZVBhdGhTZXAgPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtcGF0aC1zZXBcIik7XG5mdW5jdGlvbiBkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhZ2UpIHtcbiAgICBsZXQgX3BhZ2UgPSAoMCwgX25vcm1hbGl6ZVBhdGhTZXApLm5vcm1hbGl6ZVBhdGhTZXAocGFnZSk7XG4gICAgcmV0dXJuIF9wYWdlLnN0YXJ0c1dpdGgoJy9pbmRleC8nKSAmJiAhKDAsIF91dGlscykuaXNEeW5hbWljUm91dGUoX3BhZ2UpID8gX3BhZ2Uuc2xpY2UoNikgOiBfcGFnZSAhPT0gJy9pbmRleCcgPyBfcGFnZSA6ICcvJztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJfdXRpbHMiLCJyZXF1aXJlIiwiX25vcm1hbGl6ZVBhdGhTZXAiLCJwYWdlIiwiX3BhZ2UiLCJub3JtYWxpemVQYXRoU2VwIiwic3RhcnRzV2l0aCIsImlzRHluYW1pY1JvdXRlIiwic2xpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.normalizePathSep = normalizePathSep;\nfunction normalizePathSep(path) {\n    return path.replace(/\\\\/g, \"/\");\n} //# sourceMappingURL=normalize-path-sep.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcGFnZS1wYXRoL25vcm1hbGl6ZS1wYXRoLXNlcC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx3QkFBd0IsR0FBR0U7QUFDM0IsU0FBU0EsaUJBQWlCQyxJQUFJLEVBQUU7SUFDNUIsT0FBT0EsS0FBS0MsT0FBTyxDQUFDLE9BQU87QUFDL0IsRUFFQSw4Q0FBOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3BhZ2UtcGF0aC9ub3JtYWxpemUtcGF0aC1zZXAuanM/YmFiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubm9ybWFsaXplUGF0aFNlcCA9IG5vcm1hbGl6ZVBhdGhTZXA7XG5mdW5jdGlvbiBub3JtYWxpemVQYXRoU2VwKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vcm1hbGl6ZS1wYXRoLXNlcC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJub3JtYWxpemVQYXRoU2VwIiwicGF0aCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router-context.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.RouterContext = void 0;\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _react = _interop_require_default(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nexports.RouterContext = RouterContext;\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQscUJBQXFCLEdBQUcsS0FBSztBQUM3QixJQUFJRywyQkFBMkJDLG1KQUErRDtBQUM5RixJQUFJRSxTQUFTSCx5QkFBeUJDLG1CQUFPQSxDQUFDLCtEQUFPO0FBQ3JELE1BQU1GLGdCQUFnQkksT0FBT0QsT0FBTyxDQUFDRSxhQUFhLENBQUMsSUFBSTtBQUN2RFAscUJBQXFCLEdBQUdFO0FBQ3hCLElBQUlNLElBQXlCLEVBQWM7SUFDdkNOLGNBQWNPLFdBQVcsR0FBRztBQUNoQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5qcz81ZTkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5Sb3V0ZXJDb250ZXh0ID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSBSb3V0ZXJDb250ZXh0O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSb3V0ZXJDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsImRlZmF1bHQiLCJfcmVhY3QiLCJjcmVhdGVDb250ZXh0IiwicHJvY2VzcyIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router-context.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/adapters.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/adapters.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.adaptForAppRouterInstance = adaptForAppRouterInstance;\nexports.adaptForSearchParams = adaptForSearchParams;\nexports.PathnameContextProviderAdapter = PathnameContextProviderAdapter;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _object_without_properties_loose = (__webpack_require__(/*! @swc/helpers/lib/_object_without_properties_loose.js */ \"./node_modules/@swc/helpers/lib/_object_without_properties_loose.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nvar _hooksClientContext = __webpack_require__(/*! ../hooks-client-context */ \"./node_modules/next/dist/shared/lib/hooks-client-context.js\");\nvar _utils = __webpack_require__(/*! ./utils */ \"./node_modules/next/dist/shared/lib/router/utils/index.js\");\nfunction adaptForAppRouterInstance(router) {\n    return {\n        back () {\n            router.back();\n        },\n        forward () {\n            router.forward();\n        },\n        refresh () {\n            router.reload();\n        },\n        push (href) {\n            void router.push(href);\n        },\n        replace (href) {\n            void router.replace(href);\n        },\n        prefetch (href) {\n            void router.prefetch(href);\n        }\n    };\n}\n/**\n * transforms the ParsedUrlQuery into a URLSearchParams.\n *\n * @param query the query to transform\n * @returns URLSearchParams\n */ function transformQuery(query) {\n    const params = new URLSearchParams();\n    for (const [name, value] of Object.entries(query)){\n        if (Array.isArray(value)) {\n            for (const val of value){\n                params.append(name, val);\n            }\n        } else if (typeof value !== \"undefined\") {\n            params.append(name, value);\n        }\n    }\n    return params;\n}\nfunction adaptForSearchParams(router) {\n    if (!router.isReady || !router.query) {\n        return new URLSearchParams();\n    }\n    return transformQuery(router.query);\n}\nfunction PathnameContextProviderAdapter(_param) {\n    _s();\n    var { children , router  } = _param, props = _object_without_properties_loose(_param, [\n        \"children\",\n        \"router\"\n    ]);\n    const ref = (0, _react).useRef(props.isAutoExport);\n    const value = (0, _react).useMemo(()=>{\n        // isAutoExport is only ever `true` on the first render from the server,\n        // so reset it to `false` after we read it for the first time as `true`. If\n        // we don't use the value, then we don't need it.\n        const isAutoExport = ref.current;\n        if (isAutoExport) {\n            ref.current = false;\n        }\n        // When the route is a dynamic route, we need to do more processing to\n        // determine if we need to stop showing the pathname.\n        if ((0, _utils).isDynamicRoute(router.pathname)) {\n            // When the router is rendering the fallback page, it can't possibly know\n            // the path, so return `null` here. Read more about fallback pages over\n            // at:\n            // https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-pages\n            if (router.isFallback) {\n                return null;\n            }\n            // When `isAutoExport` is true, meaning this is a page page has been\n            // automatically statically optimized, and the router is not ready, then\n            // we can't know the pathname yet. Read more about automatic static\n            // optimization at:\n            // https://nextjs.org/docs/advanced-features/automatic-static-optimization\n            if (isAutoExport && !router.isReady) {\n                return null;\n            }\n        }\n        // The `router.asPath` contains the pathname seen by the browser (including\n        // any query strings), so it should have that stripped. Read more about the\n        // `asPath` option over at:\n        // https://nextjs.org/docs/api-reference/next/router#router-object\n        const url = new URL(router.asPath, \"http://f\");\n        return url.pathname;\n    }, [\n        router.asPath,\n        router.isFallback,\n        router.isReady,\n        router.pathname\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_hooksClientContext.PathnameContext.Provider, {\n        value: value\n    }, children);\n} //# sourceMappingURL=adapters.js.map\n_s(PathnameContextProviderAdapter, \"Iutd72mcKTljzdnM+BkWSt/bppI=\");\n_c = PathnameContextProviderAdapter;\nvar _c;\n$RefreshReg$(_c, \"PathnameContextProviderAdapter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL2FkYXB0ZXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxpQ0FBaUMsR0FBR0U7QUFDcENGLDRCQUE0QixHQUFHRztBQUMvQkgsc0NBQXNDLEdBQUdJO0FBQ3pDLElBQUlDLDRCQUE0QkMscUpBQWdFO0FBQ2hHLElBQUlFLG1DQUFtQ0YsbUtBQXVFO0FBQzlHLElBQUlHLFNBQVNKLDBCQUEwQkMsbUJBQU9BLENBQUMsK0RBQU87QUFDdEQsSUFBSUksc0JBQXNCSixtQkFBT0EsQ0FBQyw0RkFBeUI7QUFDM0QsSUFBSUssU0FBU0wsbUJBQU9BLENBQUMsMEVBQVM7QUFDOUIsU0FBU0osMEJBQTBCVSxNQUFNLEVBQUU7SUFDdkMsT0FBTztRQUNIQyxRQUFRO1lBQ0pELE9BQU9DLElBQUk7UUFDZjtRQUNBQyxXQUFXO1lBQ1BGLE9BQU9FLE9BQU87UUFDbEI7UUFDQUMsV0FBVztZQUNQSCxPQUFPSSxNQUFNO1FBQ2pCO1FBQ0FDLE1BQU1DLElBQUksRUFBRTtZQUNSLEtBQUtOLE9BQU9LLElBQUksQ0FBQ0M7UUFDckI7UUFDQUMsU0FBU0QsSUFBSSxFQUFFO1lBQ1gsS0FBS04sT0FBT08sT0FBTyxDQUFDRDtRQUN4QjtRQUNBRSxVQUFVRixJQUFJLEVBQUU7WUFDWixLQUFLTixPQUFPUSxRQUFRLENBQUNGO1FBQ3pCO0lBQ0o7QUFDSjtBQUNBOzs7OztDQUtDLEdBQUcsU0FBU0csZUFBZUMsS0FBSyxFQUFFO0lBQy9CLE1BQU1DLFNBQVMsSUFBSUM7SUFDbkIsS0FBSyxNQUFNLENBQUNDLE1BQU14QixNQUFNLElBQUlILE9BQU80QixPQUFPLENBQUNKLE9BQU87UUFDOUMsSUFBSUssTUFBTUMsT0FBTyxDQUFDM0IsUUFBUTtZQUN0QixLQUFLLE1BQU00QixPQUFPNUIsTUFBTTtnQkFDcEJzQixPQUFPTyxNQUFNLENBQUNMLE1BQU1JO1lBQ3hCO1FBQ0osT0FBTyxJQUFJLE9BQU81QixVQUFVLGFBQWE7WUFDckNzQixPQUFPTyxNQUFNLENBQUNMLE1BQU14QjtRQUN4QixDQUFDO0lBQ0w7SUFDQSxPQUFPc0I7QUFDWDtBQUNBLFNBQVNwQixxQkFBcUJTLE1BQU0sRUFBRTtJQUNsQyxJQUFJLENBQUNBLE9BQU9tQixPQUFPLElBQUksQ0FBQ25CLE9BQU9VLEtBQUssRUFBRTtRQUNsQyxPQUFPLElBQUlFO0lBQ2YsQ0FBQztJQUNELE9BQU9ILGVBQWVULE9BQU9VLEtBQUs7QUFDdEM7QUFDQSxTQUFTbEIsK0JBQStCNEIsTUFBTSxFQUFFOztJQUM1QyxJQUFJLEVBQUVDLFNBQVEsRUFBR3JCLE9BQU0sRUFBRyxHQUFHb0IsUUFBUUUsUUFBUTFCLGlDQUFpQ3dCLFFBQVE7UUFDbEY7UUFDQTtLQUNIO0lBQ0QsTUFBTUcsTUFBTSxDQUFDLEdBQUcxQixNQUFNLEVBQUUyQixNQUFNLENBQUNGLE1BQU1HLFlBQVk7SUFDakQsTUFBTXBDLFFBQVEsQ0FBQyxHQUFHUSxNQUFNLEVBQUU2QixPQUFPLENBQUMsSUFBSTtRQUNsQyx3RUFBd0U7UUFDeEUsMkVBQTJFO1FBQzNFLGlEQUFpRDtRQUNqRCxNQUFNRCxlQUFlRixJQUFJSSxPQUFPO1FBQ2hDLElBQUlGLGNBQWM7WUFDZEYsSUFBSUksT0FBTyxHQUFHLEtBQUs7UUFDdkIsQ0FBQztRQUNELHNFQUFzRTtRQUN0RSxxREFBcUQ7UUFDckQsSUFBSSxDQUFDLEdBQUc1QixNQUFNLEVBQUU2QixjQUFjLENBQUM1QixPQUFPNkIsUUFBUSxHQUFHO1lBQzdDLHlFQUF5RTtZQUN6RSx1RUFBdUU7WUFDdkUsTUFBTTtZQUNOLHNGQUFzRjtZQUN0RixJQUFJN0IsT0FBTzhCLFVBQVUsRUFBRTtnQkFDbkIsT0FBTyxJQUFJO1lBQ2YsQ0FBQztZQUNELG9FQUFvRTtZQUNwRSx3RUFBd0U7WUFDeEUsbUVBQW1FO1lBQ25FLG1CQUFtQjtZQUNuQiwwRUFBMEU7WUFDMUUsSUFBSUwsZ0JBQWdCLENBQUN6QixPQUFPbUIsT0FBTyxFQUFFO2dCQUNqQyxPQUFPLElBQUk7WUFDZixDQUFDO1FBQ0wsQ0FBQztRQUNELDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UsMkJBQTJCO1FBQzNCLGtFQUFrRTtRQUNsRSxNQUFNWSxNQUFNLElBQUlDLElBQUloQyxPQUFPaUMsTUFBTSxFQUFFO1FBQ25DLE9BQU9GLElBQUlGLFFBQVE7SUFDdkIsR0FBRztRQUNDN0IsT0FBT2lDLE1BQU07UUFDYmpDLE9BQU84QixVQUFVO1FBQ2pCOUIsT0FBT21CLE9BQU87UUFDZG5CLE9BQU82QixRQUFRO0tBQ2xCO0lBQ0QsT0FBTyxXQUFXLEdBQUdoQyxPQUFPRixPQUFPLENBQUN1QyxhQUFhLENBQUNwQyxvQkFBb0JxQyxlQUFlLENBQUNDLFFBQVEsRUFBRTtRQUM1Ri9DLE9BQU9BO0lBQ1gsR0FBR2dDO0FBQ1AsRUFFQSxvQ0FBb0M7R0FsRDNCN0I7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVycy5qcz9lNjc1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGFwdEZvckFwcFJvdXRlckluc3RhbmNlID0gYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZTtcbmV4cG9ydHMuYWRhcHRGb3JTZWFyY2hQYXJhbXMgPSBhZGFwdEZvclNlYXJjaFBhcmFtcztcbmV4cG9ydHMuUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyID0gUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZS5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZWFjdCA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfaG9va3NDbGllbnRDb250ZXh0ID0gcmVxdWlyZShcIi4uL2hvb2tzLWNsaWVudC1jb250ZXh0XCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrICgpIHtcbiAgICAgICAgICAgIHJvdXRlci5iYWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcndhcmQgKCkge1xuICAgICAgICAgICAgcm91dGVyLmZvcndhcmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVmcmVzaCAoKSB7XG4gICAgICAgICAgICByb3V0ZXIucmVsb2FkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHB1c2ggKGhyZWYpIHtcbiAgICAgICAgICAgIHZvaWQgcm91dGVyLnB1c2goaHJlZik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlcGxhY2UgKGhyZWYpIHtcbiAgICAgICAgICAgIHZvaWQgcm91dGVyLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0sXG4gICAgICAgIHByZWZldGNoIChocmVmKSB7XG4gICAgICAgICAgICB2b2lkIHJvdXRlci5wcmVmZXRjaChocmVmKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIHRyYW5zZm9ybXMgdGhlIFBhcnNlZFVybFF1ZXJ5IGludG8gYSBVUkxTZWFyY2hQYXJhbXMuXG4gKlxuICogQHBhcmFtIHF1ZXJ5IHRoZSBxdWVyeSB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm5zIFVSTFNlYXJjaFBhcmFtc1xuICovIGZ1bmN0aW9uIHRyYW5zZm9ybVF1ZXJ5KHF1ZXJ5KSB7XG4gICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhxdWVyeSkpe1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlKXtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKG5hbWUsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmZ1bmN0aW9uIGFkYXB0Rm9yU2VhcmNoUGFyYW1zKHJvdXRlcikge1xuICAgIGlmICghcm91dGVyLmlzUmVhZHkgfHwgIXJvdXRlci5xdWVyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtUXVlcnkocm91dGVyLnF1ZXJ5KTtcbn1cbmZ1bmN0aW9uIFBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlcihfcGFyYW0pIHtcbiAgICB2YXIgeyBjaGlsZHJlbiAsIHJvdXRlciAgfSA9IF9wYXJhbSwgcHJvcHMgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfcGFyYW0sIFtcbiAgICAgICAgXCJjaGlsZHJlblwiLFxuICAgICAgICBcInJvdXRlclwiXG4gICAgXSk7XG4gICAgY29uc3QgcmVmID0gKDAsIF9yZWFjdCkudXNlUmVmKHByb3BzLmlzQXV0b0V4cG9ydCk7XG4gICAgY29uc3QgdmFsdWUgPSAoMCwgX3JlYWN0KS51c2VNZW1vKCgpPT57XG4gICAgICAgIC8vIGlzQXV0b0V4cG9ydCBpcyBvbmx5IGV2ZXIgYHRydWVgIG9uIHRoZSBmaXJzdCByZW5kZXIgZnJvbSB0aGUgc2VydmVyLFxuICAgICAgICAvLyBzbyByZXNldCBpdCB0byBgZmFsc2VgIGFmdGVyIHdlIHJlYWQgaXQgZm9yIHRoZSBmaXJzdCB0aW1lIGFzIGB0cnVlYC4gSWZcbiAgICAgICAgLy8gd2UgZG9uJ3QgdXNlIHRoZSB2YWx1ZSwgdGhlbiB3ZSBkb24ndCBuZWVkIGl0LlxuICAgICAgICBjb25zdCBpc0F1dG9FeHBvcnQgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGlzQXV0b0V4cG9ydCkge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSByb3V0ZSBpcyBhIGR5bmFtaWMgcm91dGUsIHdlIG5lZWQgdG8gZG8gbW9yZSBwcm9jZXNzaW5nIHRvXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHN0b3Agc2hvd2luZyB0aGUgcGF0aG5hbWUuXG4gICAgICAgIGlmICgoMCwgX3V0aWxzKS5pc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSByb3V0ZXIgaXMgcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBwYWdlLCBpdCBjYW4ndCBwb3NzaWJseSBrbm93XG4gICAgICAgICAgICAvLyB0aGUgcGF0aCwgc28gcmV0dXJuIGBudWxsYCBoZXJlLiBSZWFkIG1vcmUgYWJvdXQgZmFsbGJhY2sgcGFnZXMgb3ZlclxuICAgICAgICAgICAgLy8gYXQ6XG4gICAgICAgICAgICAvLyBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL2RhdGEtZmV0Y2hpbmcvZ2V0LXN0YXRpYy1wYXRocyNmYWxsYmFjay1wYWdlc1xuICAgICAgICAgICAgaWYgKHJvdXRlci5pc0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIGBpc0F1dG9FeHBvcnRgIGlzIHRydWUsIG1lYW5pbmcgdGhpcyBpcyBhIHBhZ2UgcGFnZSBoYXMgYmVlblxuICAgICAgICAgICAgLy8gYXV0b21hdGljYWxseSBzdGF0aWNhbGx5IG9wdGltaXplZCwgYW5kIHRoZSByb3V0ZXIgaXMgbm90IHJlYWR5LCB0aGVuXG4gICAgICAgICAgICAvLyB3ZSBjYW4ndCBrbm93IHRoZSBwYXRobmFtZSB5ZXQuIFJlYWQgbW9yZSBhYm91dCBhdXRvbWF0aWMgc3RhdGljXG4gICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gYXQ6XG4gICAgICAgICAgICAvLyBodHRwczovL25leHRqcy5vcmcvZG9jcy9hZHZhbmNlZC1mZWF0dXJlcy9hdXRvbWF0aWMtc3RhdGljLW9wdGltaXphdGlvblxuICAgICAgICAgICAgaWYgKGlzQXV0b0V4cG9ydCAmJiAhcm91dGVyLmlzUmVhZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYHJvdXRlci5hc1BhdGhgIGNvbnRhaW5zIHRoZSBwYXRobmFtZSBzZWVuIGJ5IHRoZSBicm93c2VyIChpbmNsdWRpbmdcbiAgICAgICAgLy8gYW55IHF1ZXJ5IHN0cmluZ3MpLCBzbyBpdCBzaG91bGQgaGF2ZSB0aGF0IHN0cmlwcGVkLiBSZWFkIG1vcmUgYWJvdXQgdGhlXG4gICAgICAgIC8vIGBhc1BhdGhgIG9wdGlvbiBvdmVyIGF0OlxuICAgICAgICAvLyBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvcm91dGVyI3JvdXRlci1vYmplY3RcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyb3V0ZXIuYXNQYXRoLCAnaHR0cDovL2YnKTtcbiAgICAgICAgcmV0dXJuIHVybC5wYXRobmFtZTtcbiAgICB9LCBbXG4gICAgICAgIHJvdXRlci5hc1BhdGgsXG4gICAgICAgIHJvdXRlci5pc0ZhbGxiYWNrLFxuICAgICAgICByb3V0ZXIuaXNSZWFkeSxcbiAgICAgICAgcm91dGVyLnBhdGhuYW1lXG4gICAgXSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaG9va3NDbGllbnRDb250ZXh0LlBhdGhuYW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9LCBjaGlsZHJlbik7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkYXB0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJhZGFwdEZvclNlYXJjaFBhcmFtcyIsIlBhdGhuYW1lQ29udGV4dFByb3ZpZGVyQWRhcHRlciIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlIiwiX3JlYWN0IiwiX2hvb2tzQ2xpZW50Q29udGV4dCIsIl91dGlscyIsInJvdXRlciIsImJhY2siLCJmb3J3YXJkIiwicmVmcmVzaCIsInJlbG9hZCIsInB1c2giLCJocmVmIiwicmVwbGFjZSIsInByZWZldGNoIiwidHJhbnNmb3JtUXVlcnkiLCJxdWVyeSIsInBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsIm5hbWUiLCJlbnRyaWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsIiwiYXBwZW5kIiwiaXNSZWFkeSIsIl9wYXJhbSIsImNoaWxkcmVuIiwicHJvcHMiLCJyZWYiLCJ1c2VSZWYiLCJpc0F1dG9FeHBvcnQiLCJ1c2VNZW1vIiwiY3VycmVudCIsImlzRHluYW1pY1JvdXRlIiwicGF0aG5hbWUiLCJpc0ZhbGxiYWNrIiwidXJsIiwiVVJMIiwiYXNQYXRoIiwiY3JlYXRlRWxlbWVudCIsIlBhdGhuYW1lQ29udGV4dCIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/adapters.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchesMiddleware = matchesMiddleware;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.createKey = createKey;\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _removeTrailingSlash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nvar _isError = _interop_require_wildcard(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nvar _resolveRewrites = _interop_require_default(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formatUrl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectDomainLocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsePath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addLocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _removeLocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nvar _removeBasePath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _addBasePath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _getNextPathnameInfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatNextPathnameInfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _compareStates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _isBot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator(function*(options) {\n        const matchers = yield Promise.resolve(options.router.pageLoader.getMiddleware());\n        if (!matchers) return false;\n        const { pathname: asPathname  } = (0, _parsePath).parsePath(options.asPath);\n        // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n        const cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n        const asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));\n        // Check only path match on client. Matching \"has\" should be done on server\n        // where we can access more info such as headers, HttpOnly cookie, etc.\n        return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction omit(object, keys) {\n    const omitted = {};\n    Object.keys(object).forEach((key)=>{\n        if (!keys.includes(key)) {\n            omitted[key] = object[key];\n        }\n    });\n    return omitted;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (!(0, _utils).isAbsoluteUrl(url)) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && (0, _hasBasePath).hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = \"\";\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : \"\") || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || \"\";\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = \"[\".concat(repeat ? \"...\" : \"\").concat(param, \"]\");\n        if (optional) {\n            replaced = \"\".concat(!value ? \"/\" : \"\", \"[\").concat(replaced, \"]\");\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)).join(\"/\") : encodeURIComponent(value)) || \"/\");\n    })) {\n        interpolatedRoute = \"\" // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\");\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href passed to next/router: \".concat(urlAsString, \", repeated forward-slashes (//) or backslashes \\\\ are not valid in the href\"));\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omit(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    const matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\")) {\n            const parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            const pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites  }] = param;\n                let as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    const matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsePath).parsePath(source);\n        const pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n        });\n    }\n    const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            const src1 = (0, _parsePath).parsePath(redirectTarget);\n            const pathname1 = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src1.pathname, {\n                nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\".concat(pathname1).concat(src1.query).concat(src1.hash),\n                newUrl: \"\".concat(pathname1).concat(src1.query).concat(src1.hash)\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return matchesMiddleware(options).then((matches)=>{\n        if (matches && options.fetchData) {\n            return options.fetchData().then((data)=>getMiddlewareData(data.dataHref, data.response, options).then((effect)=>({\n                        dataHref: data.dataHref,\n                        cacheKey: data.cacheKey,\n                        json: data.json,\n                        response: data.response,\n                        text: data.text,\n                        effect\n                    }))).catch((_err)=>{\n                /**\n           * TODO: Revisit this in the future.\n           * For now we will not consider middleware data errors to be fatal.\n           * maybe we should revisit in the future.\n           */ return null;\n            });\n        }\n        return null;\n    });\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nconst backgroundCache = {};\nfunction handleSmoothScroll(fn) {\n    const htmlElement = document.documentElement;\n    const existing = htmlElement.style.scrollBehavior;\n    htmlElement.style.scrollBehavior = \"auto\";\n    fn();\n    htmlElement.style.scrollBehavior = existing;\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref , inflightCache , isPrefetch , hasMiddleware , isServerRender , parseJSON , persistCache , isBackground , unstable_skipClientCache  } = param;\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    var ref1;\n    const getData = (params)=>{\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {},\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : \"GET\"\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref,\n                    response,\n                    text: \"\",\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (!hasMiddleware && response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            delete inflightCache[cacheKey];\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url , router  } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route , router  } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"'.concat(route, '\"'));\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        if (false) {}\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change(\"pushState\", url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change(\"replaceState\", url, as, options);\n    }\n    change(method, url, as, options, forcedScroll) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            if (!isLocalURL(url)) {\n                handleHardNavigation({\n                    url,\n                    router: _this\n                });\n                return false;\n            }\n            // WARNING: `_h` is an internal option for handing Next.js client-side\n            // hydration. Your app should _never_ use this property. It may change at\n            // any time without notice.\n            const isQueryUpdating = options._h;\n            let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n            const nextState = _extends({}, _this.state);\n            // for static pages with query params in the URL we delay\n            // marking the router ready until after the query is updated\n            // or a navigation has occurred\n            const readyStateChange = _this.isReady !== true;\n            _this.isReady = true;\n            const isSsr = _this.isSsr;\n            if (!isQueryUpdating) {\n                _this.isSsr = false;\n            }\n            // if a route transition is already in progress before\n            // the query updating is triggered ignore query updating\n            if (isQueryUpdating && _this.clc) {\n                return false;\n            }\n            const prevLocale = nextState.locale;\n            if (false) { var ref; }\n            // marking route changes as a navigation start entry\n            if (_utils.ST) {\n                performance.mark(\"routeChange\");\n            }\n            const { shallow =false , scroll =true  } = options;\n            const routeProps = {\n                shallow\n            };\n            if (_this._inFlightRoute && _this.clc) {\n                if (!isSsr) {\n                    Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                }\n                _this.clc();\n                _this.clc = null;\n            }\n            as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n            const cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n            _this._inFlightRoute = as;\n            const localeChange = prevLocale !== nextState.locale;\n            // If the url change is only related to a hash change\n            // We should not proceed. We should only change the state.\n            if (!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange) {\n                nextState.asPath = cleanedAs;\n                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                // TODO: do we need the resolved href when only a hash change?\n                _this.changeState(method, url, as, _extends({}, options, {\n                    scroll: false\n                }));\n                if (scroll) {\n                    _this.scrollToHash(cleanedAs);\n                }\n                try {\n                    yield _this.set(nextState, _this.components[nextState.route], null);\n                } catch (err) {\n                    if ((0, _isError).default(err) && err.cancelled) {\n                        Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                return true;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            // The build manifest needs to be loaded before auto-static dynamic pages\n            // get their query parameters to allow ensuring they can be parsed properly\n            // when rewritten to\n            let pages, rewrites;\n            try {\n                [pages, { __rewrites: rewrites  }] = yield Promise.all([\n                    _this.pageLoader.getPageList(),\n                    (0, _routeLoader).getClientBuildManifest(),\n                    _this.pageLoader.getMiddleware()\n                ]);\n            } catch (err1) {\n                // If we fail to resolve the page list or client-build manifest, we must\n                // do a server-side transition:\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            // If asked to change the current URL we should reload the current page\n            // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n            // We also need to set the method = replaceState always\n            // as this should not go into the history (That's how browsers work)\n            // We should compare the new asPath to the current asPath, not the url\n            if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                method = \"replaceState\";\n            }\n            // we need to resolve the as value using rewrites for dynamic SSG\n            // pages to allow building the data URL correctly\n            let resolvedAs = as;\n            // url and as should always be prefixed with basePath by this\n            // point by either next/link or router.push/replace so strip the\n            // basePath from the pathname to match the pages dir 1-to-1\n            pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n            // we don't attempt resolve asPath when we need to execute\n            // middleware as the resolving will occur server-side\n            const isMiddlewareMatch = yield matchesMiddleware({\n                asPath: as,\n                locale: nextState.locale,\n                router: _this\n            });\n            if (options.shallow && isMiddlewareMatch) {\n                pathname = _this.pathname;\n            }\n            if (isQueryUpdating && isMiddlewareMatch) {\n                shouldResolveHref = false;\n            }\n            if (shouldResolveHref && pathname !== \"/_error\") {\n                options._shouldResolveHref = true;\n                if (false) {} else {\n                    parsed.pathname = resolveDynamicRoute(pathname, pages);\n                    if (parsed.pathname !== pathname) {\n                        pathname = parsed.pathname;\n                        parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                        if (!isMiddlewareMatch) {\n                            url = (0, _formatUrl).formatWithValidation(parsed);\n                        }\n                    }\n                }\n            }\n            if (!isLocalURL(as)) {\n                if (true) {\n                    throw new Error('Invalid href: \"'.concat(url, '\" and as: \"').concat(as, '\", received relative href and external as') + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                }\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                return false;\n            }\n            resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n            let route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            let routeMatch = false;\n            if ((0, _isDynamic).isDynamicRoute(route)) {\n                const parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                const asPathname = parsedAs1.pathname;\n                const routeRegex = (0, _routeRegex).getRouteRegex(route);\n                routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                const shouldInterpolate = route === asPathname;\n                const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n                if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                    const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                    if (missingParams.length > 0 && !isMiddlewareMatch) {\n                        if (true) {\n                            console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(\", \"), \" in the `href`'s `query`\"));\n                        }\n                        throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(\", \"), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\"));\n                    }\n                } else if (shouldInterpolate) {\n                    as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs1, {\n                        pathname: interpolatedAs.result,\n                        query: omit(query, interpolatedAs.params)\n                    }));\n                } else {\n                    // Merge params into `query`, overwriting any specified in search\n                    Object.assign(query, routeMatch);\n                }\n            }\n            if (!isQueryUpdating) {\n                Router.events.emit(\"routeChangeStart\", as, routeProps);\n            }\n            try {\n                var ref2, ref3;\n                let routeInfo = yield _this.getRouteInfo({\n                    route,\n                    pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps,\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    hasMiddleware: isMiddlewareMatch,\n                    unstable_skipClientCache: options.unstable_skipClientCache,\n                    isQueryUpdating: isQueryUpdating && !_this.isFallback\n                });\n                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                    pathname = routeInfo.route || route;\n                    route = pathname;\n                    if (!routeProps.shallow) {\n                        query = Object.assign({}, routeInfo.query || {}, query);\n                    }\n                    const cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                        Object.keys(routeMatch).forEach((key)=>{\n                            if (routeMatch && query[key] === routeMatch[key]) {\n                                delete query[key];\n                            }\n                        });\n                    }\n                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                        const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                        let rewriteAs = prefixedAs;\n                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                        }\n                        if (false) {}\n                        const routeRegex1 = (0, _routeRegex).getRouteRegex(pathname);\n                        const curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                        if (curRouteMatch) {\n                            Object.assign(query, curRouteMatch);\n                        }\n                    }\n                }\n                // If the routeInfo brings a redirect we simply apply it.\n                if (\"type\" in routeInfo) {\n                    if (routeInfo.type === \"redirect-internal\") {\n                        return _this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                    } else {\n                        handleHardNavigation({\n                            url: routeInfo.destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                }\n                let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n                const component = routeInfo.Component;\n                if (component && component.unstable_scriptLoader) {\n                    const scripts = [].concat(component.unstable_scriptLoader());\n                    scripts.forEach((script)=>{\n                        (0, _script).handleClientScriptLoad(script.props);\n                    });\n                }\n                // handle redirect on client-transition\n                if ((__N_SSG || __N_SSP) && props) {\n                    if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                        // Use the destination from redirect without adding locale\n                        options.locale = false;\n                        const destination = props.pageProps.__N_REDIRECT;\n                        // check if destination is internal (resolves to a page) and attempt\n                        // client-navigation if it is falling back to hard navigation if\n                        // it's not\n                        if (destination.startsWith(\"/\") && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                            const { url: newUrl , as: newAs  } = prepareUrlAs(_this, destination, destination);\n                            return _this.change(method, newUrl, newAs, options);\n                        }\n                        handleHardNavigation({\n                            url: destination,\n                            router: _this\n                        });\n                        return new Promise(()=>{});\n                    }\n                    nextState.isPreview = !!props.__N_PREVIEW;\n                    // handle SSG data 404\n                    if (props.notFound === SSG_DATA_NOT_FOUND) {\n                        let notFoundRoute;\n                        try {\n                            yield _this.fetchComponent(\"/404\");\n                            notFoundRoute = \"/404\";\n                        } catch (_) {\n                            notFoundRoute = \"/_error\";\n                        }\n                        routeInfo = yield _this.getRouteInfo({\n                            route: notFoundRoute,\n                            pathname: notFoundRoute,\n                            query,\n                            as,\n                            resolvedAs,\n                            routeProps: {\n                                shallow: false\n                            },\n                            locale: nextState.locale,\n                            isPreview: nextState.isPreview\n                        });\n                        if (\"type\" in routeInfo) {\n                            throw new Error(\"Unexpected middleware effect on /404\");\n                        }\n                    }\n                }\n                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                _this.changeState(method, url, as, options);\n                if (isQueryUpdating && pathname === \"/_error\" && ((ref2 = self.__NEXT_DATA__.props) == null ? void 0 : (ref3 = ref2.pageProps) == null ? void 0 : ref3.statusCode) === 500 && (props == null ? void 0 : props.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    props.pageProps.statusCode = 500;\n                }\n                var _route;\n                // shallow routing is only allowed for same page URL changes.\n                const isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                var _scroll;\n                const shouldScroll = (_scroll = options.scroll) != null ? _scroll : !options._h && !isValidShallowRoute;\n                const resetScroll = shouldScroll ? {\n                    x: 0,\n                    y: 0\n                } : null;\n                // the new state that the router gonna set\n                const upcomingRouterState = _extends({}, nextState, {\n                    route,\n                    pathname,\n                    query,\n                    asPath: cleanedAs,\n                    isFallback: false\n                });\n                const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                // for query updates we can skip it if the state is unchanged and we don't\n                // need to scroll\n                // https://github.com/vercel/next.js/issues/37139\n                const canSkipUpdating = options._h && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                if (!canSkipUpdating) {\n                    yield _this.set(upcomingRouterState, routeInfo, upcomingScrollState).catch((e)=>{\n                        if (e.cancelled) error = error || e;\n                        else throw e;\n                    });\n                    if (error) {\n                        if (!isQueryUpdating) {\n                            Router.events.emit(\"routeChangeError\", error, cleanedAs, routeProps);\n                        }\n                        throw error;\n                    }\n                    if (false) {}\n                    if (!isQueryUpdating) {\n                        Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                    }\n                    // A hash mark # is the optional last part of a URL\n                    const hashRegex = /#.+$/;\n                    if (shouldScroll && hashRegex.test(as)) {\n                        _this.scrollToHash(as);\n                    }\n                }\n                return true;\n            } catch (err11) {\n                if ((0, _isError).default(err11) && err11.cancelled) {\n                    return false;\n                }\n                throw err11;\n            }\n        })();\n    }\n    changeState(method, url, as) {\n        let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n        if (true) {\n            if (typeof window.history === \"undefined\") {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === \"undefined\") {\n                console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                return;\n            }\n        }\n        if (method !== \"pushState\" || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== \"pushState\" ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            \"\", as);\n        }\n    }\n    handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            console.error(err);\n            if (err.cancelled) {\n                // bubble up cancellation errors\n                throw err;\n            }\n            if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                // If we can't load the page it could be one of following reasons\n                //  1. Page doesn't exists\n                //  2. Page does exist in a different zone\n                //  3. Internal error while loading the page\n                // So, doing a hard reload is the proper way to deal with this.\n                handleHardNavigation({\n                    url: as,\n                    router: _this\n                });\n                // Changing the URL doesn't block executing the current code path.\n                // So let's throw a cancellation error stop the routing logic.\n                throw buildCancellationError();\n            }\n            try {\n                let props;\n                const { page: Component , styleSheets  } = yield _this.fetchComponent(\"/_error\");\n                const routeInfo = {\n                    props,\n                    Component,\n                    styleSheets,\n                    err,\n                    error: err\n                };\n                if (!routeInfo.props) {\n                    try {\n                        routeInfo.props = yield _this.getInitialProps(Component, {\n                            err,\n                            pathname,\n                            query\n                        });\n                    } catch (gipErr) {\n                        console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                        routeInfo.props = {};\n                    }\n                }\n                return routeInfo;\n            } catch (routeInfoErr) {\n                return _this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n            }\n        })();\n    }\n    getRouteInfo(param) {\n        let { route: requestedRoute , pathname , query , as , resolvedAs , routeProps , locale , hasMiddleware , isPreview , unstable_skipClientCache , isQueryUpdating  } = param;\n        var _this = this;\n        return _async_to_generator(function*() {\n            /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n            try {\n                var ref, ref4, ref5;\n                const handleCancelled = getCancelledHandler({\n                    route,\n                    router: _this\n                });\n                let existingInfo = _this.components[route];\n                if (routeProps.shallow && existingInfo && _this.route === route) {\n                    return existingInfo;\n                }\n                if (hasMiddleware) {\n                    existingInfo = undefined;\n                }\n                let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                const fetchNextDataParams = {\n                    dataHref: _this.pageLoader.getDataHref({\n                        href: (0, _formatUrl).formatWithValidation({\n                            pathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: _this.isSsr,\n                    parseJSON: true,\n                    inflightCache: _this.sdc,\n                    persistCache: !isPreview,\n                    isPrefetch: false,\n                    unstable_skipClientCache,\n                    isBackground: isQueryUpdating\n                };\n                const data = isQueryUpdating ? {} : yield withMiddlewareEffects({\n                    fetchData: ()=>fetchNextData(fetchNextDataParams),\n                    asPath: resolvedAs,\n                    locale: locale,\n                    router: _this\n                });\n                if (isQueryUpdating && data) {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n                handleCancelled();\n                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === \"redirect-internal\" || (data == null ? void 0 : (ref4 = data.effect) == null ? void 0 : ref4.type) === \"redirect-external\") {\n                    return data.effect;\n                }\n                if ((data == null ? void 0 : (ref5 = data.effect) == null ? void 0 : ref5.type) === \"rewrite\") {\n                    route = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                    pathname = data.effect.resolvedHref;\n                    query = _extends({}, query, data.effect.parsedAs.query);\n                    resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = _this.components[route];\n                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return _extends({}, existingInfo, {\n                            route\n                        });\n                    }\n                }\n                if (route === \"/api\" || route.startsWith(\"/api/\")) {\n                    handleHardNavigation({\n                        url: as,\n                        router: _this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routeInfo = cachedRouteInfo || (yield _this.fetchComponent(route).then((res)=>({\n                        Component: res.page,\n                        styleSheets: res.styleSheets,\n                        __N_SSG: res.mod.__N_SSG,\n                        __N_SSP: res.mod.__N_SSP\n                    })));\n                if (true) {\n                    const { isValidElementType  } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                    if (!isValidElementType(routeInfo.Component)) {\n                        throw new Error('The default export is not a React Component in page: \"'.concat(pathname, '\"'));\n                    }\n                }\n                const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                const { props , cacheKey  } = yield _this._getData(_async_to_generator(function*() {\n                    if (shouldFetchData) {\n                        const { json , cacheKey: _cacheKey  } = (data == null ? void 0 : data.json) ? data : yield fetchNextData({\n                            dataHref: _this.pageLoader.getDataHref({\n                                href: (0, _formatUrl).formatWithValidation({\n                                    pathname,\n                                    query\n                                }),\n                                asPath: resolvedAs,\n                                locale\n                            }),\n                            isServerRender: _this.isSsr,\n                            parseJSON: true,\n                            inflightCache: _this.sdc,\n                            persistCache: !isPreview,\n                            isPrefetch: false,\n                            unstable_skipClientCache\n                        });\n                        return {\n                            cacheKey: _cacheKey,\n                            props: json || {}\n                        };\n                    }\n                    return {\n                        headers: {},\n                        cacheKey: \"\",\n                        props: yield _this.getInitialProps(routeInfo.Component, {\n                            pathname,\n                            query,\n                            asPath: as,\n                            locale,\n                            locales: _this.locales,\n                            defaultLocale: _this.defaultLocale\n                        })\n                    };\n                }));\n                // Only bust the data cache for SSP routes although\n                // middleware can skip cache per request with\n                // x-middleware-cache: no-cache as well\n                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref) {\n                    delete _this.sdc[cacheKey];\n                }\n                // we kick off a HEAD request in the background\n                // when a non-prefetch request is made to signal revalidation\n                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                props.pageProps = Object.assign({}, props.pageProps);\n                routeInfo.props = props;\n                routeInfo.route = route;\n                routeInfo.query = query;\n                routeInfo.resolvedAs = resolvedAs;\n                _this.components[route] = routeInfo;\n                return routeInfo;\n            } catch (err) {\n                return _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n            }\n        })();\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\");\n        const [newUrlNoHash, newHash] = as.split(\"#\");\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = \"\"] = as.split(\"#\");\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === \"\" || hash === \"top\") {\n            handleSmoothScroll(()=>window.scrollTo(0, 0));\n            return;\n        }\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash);\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash);\n        if (idEl) {\n            handleSmoothScroll(()=>idEl.scrollIntoView());\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0];\n        if (nameEl) {\n            handleSmoothScroll(()=>nameEl.scrollIntoView());\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ prefetch(url) {\n        let asPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : url, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        var _this = this;\n        return _async_to_generator(function*() {\n            if ( true && (0, _isBot).isBot(window.navigator.userAgent)) {\n                // No prefetches for bots that render the link since they are typically navigating\n                // links via the equivalent of a hard navigation and hence never utilize these\n                // prefetches.\n                return;\n            }\n            let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            let { pathname , query  } = parsed;\n            if (false) {}\n            const pages = yield _this.pageLoader.getPageList();\n            let resolvedAs = asPath;\n            const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n            if (false) {}\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n            // Prefetch is not supported in development mode because it would trigger on-demand-entries\n            if (true) {\n                return;\n            }\n            const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n            yield Promise.all([\n                _this.pageLoader._isSsg(route).then((isSsg)=>{\n                    return isSsg ? fetchNextData({\n                        dataHref: _this.pageLoader.getDataHref({\n                            href: url,\n                            asPath: resolvedAs,\n                            locale: locale\n                        }),\n                        isServerRender: false,\n                        parseJSON: true,\n                        inflightCache: _this.sdc,\n                        persistCache: !_this.isPreview,\n                        isPrefetch: true,\n                        unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                    }).then(()=>false) : false;\n                }),\n                _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n            ]);\n        })();\n    }\n    fetchComponent(route) {\n        var _this = this;\n        return _async_to_generator(function*() {\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: _this\n            });\n            try {\n                const componentResult = yield _this.pageLoader.loadPage(route);\n                handleCancelled();\n                return componentResult;\n            } catch (err) {\n                handleCancelled();\n                throw err;\n            }\n        })();\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error(\"Loading initial props cancelled\");\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then((param)=>{\n            let { text  } = param;\n            return {\n                data: text\n            };\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components[\"/_app\"];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){\n        // Server Data Cache\n        this.sdc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent  } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState(\"replaceState\", (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , key  } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname: pathname1  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addBasePath).addBasePath(this.asPath) && pathname1 === (0, _addBasePath).addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== \"/_error\") {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as1 !== pathname1;\n                    this.changeState(\"replaceState\", matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n}\nRouter.events = (0, _mitt).default();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx5QkFBeUIsR0FBR0U7QUFDNUJGLGtCQUFrQixHQUFHRztBQUNyQkgscUJBQXFCLEdBQUdJO0FBQ3hCSixtQkFBbUIsR0FBR0s7QUFDdEJMLGlCQUFpQixHQUFHTTtBQUNwQk4sa0JBQWUsR0FBRyxLQUFLO0FBQ3ZCLElBQUlRLHNCQUFzQkMseUlBQTBEO0FBQ3BGLElBQUlDLFdBQVdELG1IQUErQztBQUM5RCxJQUFJRSwyQkFBMkJGLG1KQUErRDtBQUM5RixJQUFJRyw0QkFBNEJILHFKQUFnRTtBQUNoRyxJQUFJSSwwQkFBMEJKLG1CQUFPQSxDQUFDLDZHQUEwQztBQUNoRixJQUFJSyx1QkFBdUJMLG1CQUFPQSxDQUFDLGdIQUErQjtBQUNsRSxJQUFJTSxlQUFlTixtQkFBT0EsQ0FBQyxxRkFBOEI7QUFDekQsSUFBSU8sVUFBVVAsbUJBQU9BLENBQUMseUVBQXdCO0FBQzlDLElBQUlRLFdBQVdMLDBCQUEwQkgsbUJBQU9BLENBQUMsdUVBQXVCO0FBQ3hFLElBQUlTLHVCQUF1QlQsbUJBQU9BLENBQUMsa0hBQW9DO0FBQ3ZFLElBQUlVLHVCQUF1QlYsbUJBQU9BLENBQUMsd0dBQStCO0FBQ2xFLElBQUlXLFFBQVFULHlCQUF5QkYsbUJBQU9BLENBQUMsNERBQVM7QUFDdEQsSUFBSVksU0FBU1osbUJBQU9BLENBQUMsOERBQVU7QUFDL0IsSUFBSWEsYUFBYWIsbUJBQU9BLENBQUMsMEZBQW9CO0FBQzdDLElBQUljLG9CQUFvQmQsbUJBQU9BLENBQUMsMEdBQTRCO0FBQzVELElBQUllLGVBQWVmLG1CQUFPQSxDQUFDLDRGQUFxQjtBQUNoRCxJQUFJZ0IsbUJBQW1CZCx5QkFBeUJGLG1CQUFPQSxDQUFDLHVDQUEwQjtBQUNsRixJQUFJaUIsZ0JB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Q0osQ0FBQztZQUNEc0IsT0FBT2tQLGdCQUFnQixDQUFDLFlBQVksSUFBSSxDQUFDZCxVQUFVO1lBQ25ELDJEQUEyRDtZQUMzRCxtREFBbUQ7WUFDbkQsSUFBSXJSLEtBQXFDLEVBQUUsRUFJMUM7UUFDTCxDQUFDO0lBQ0w7QUFDSjtBQUNBdUcsT0FBTzZDLE1BQU0sR0FBRyxDQUFDLEdBQUcvUixLQUFLLEVBQUViLE9BQU87QUFDbENQLGtCQUFlLEdBQUdzUSxRQUVsQixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXIuanM/ODY4NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWF0Y2hlc01pZGRsZXdhcmUgPSBtYXRjaGVzTWlkZGxld2FyZTtcbmV4cG9ydHMuaXNMb2NhbFVSTCA9IGlzTG9jYWxVUkw7XG5leHBvcnRzLmludGVycG9sYXRlQXMgPSBpbnRlcnBvbGF0ZUFzO1xuZXhwb3J0cy5yZXNvbHZlSHJlZiA9IHJlc29sdmVIcmVmO1xuZXhwb3J0cy5jcmVhdGVLZXkgPSBjcmVhdGVLZXk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbnZhciBfZXh0ZW5kcyA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19leHRlbmRzLmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0LmpzXCIpLmRlZmF1bHQ7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yZW1vdmVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yb3V0ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xudmFyIF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX2Rlbm9ybWFsaXplUGFnZVBhdGggPSByZXF1aXJlKFwiLi4vcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xudmFyIF9xdWVyeXN0cmluZyA9IHJlcXVpcmUoXCIuL3V0aWxzL3F1ZXJ5c3RyaW5nXCIpO1xudmFyIF9yZXNvbHZlUmV3cml0ZXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG52YXIgX3JvdXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG52YXIgX3JvdXRlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbnZhciBfZm9ybWF0VXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbnZhciBfZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcGF0aFwiKTtcbnZhciBfYWRkTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xudmFyIF9yZW1vdmVMb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG52YXIgX3JlbW92ZUJhc2VQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG52YXIgX2dldE5leHRQYXRobmFtZUluZm8gPSByZXF1aXJlKFwiLi91dGlscy9nZXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xudmFyIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LW5leHQtcGF0aG5hbWUtaW5mb1wiKTtcbnZhciBfY29tcGFyZVN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xudmFyIF9pc0JvdCA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWJvdFwiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgICAgICBjYW5jZWxsZWQ6IHRydWVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX21hdGNoZXNNaWRkbGV3YXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfbWF0Y2hlc01pZGRsZXdhcmUoKSB7XG4gICAgX21hdGNoZXNNaWRkbGV3YXJlID0gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbioob3B0aW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaGVycyA9IHlpZWxkIFByb21pc2UucmVzb2x2ZShvcHRpb25zLnJvdXRlci5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKSk7XG4gICAgICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSAgfSA9ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgob3B0aW9ucy5hc1BhdGgpO1xuICAgICAgICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXNQYXRobmFtZSkgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhc1BhdGhuYW1lKSA6IGFzUGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IGFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShjbGVhbmVkQXMsIG9wdGlvbnMubG9jYWxlKSk7XG4gICAgICAgIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gICAgICAgIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gICAgICAgIHJldHVybiBtYXRjaGVycy5zb21lKChtKT0+bmV3IFJlZ0V4cChtLnJlZ2V4cCkudGVzdChhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBfbWF0Y2hlc01pZGRsZXdhcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gb21pdChvYmplY3QsIGtleXMpIHtcbiAgICBjb25zdCBvbWl0dGVkID0ge307XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGlmICgha2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBvbWl0dGVkW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvbWl0dGVkO1xufVxuZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmwpIHtcbiAgICAvLyBwcmV2ZW50IGEgaHlkcmF0aW9uIG1pc21hdGNoIG9uIGhyZWYgZm9yIHVybCB3aXRoIGFuY2hvciByZWZzXG4gICAgaWYgKCEoMCwgX3V0aWxzKS5pc0Fic29sdXRlVXJsKHVybCkpIHJldHVybiB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgICAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkLm9yaWdpbiA9PT0gbG9jYXRpb25PcmlnaW4gJiYgKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocmVzb2x2ZWQucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSB7XG4gICAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJyc7XG4gICAgY29uc3QgZHluYW1pY1JlZ2V4ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3VwcztcbiAgICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9IC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKGR5bmFtaWNSZWdleCkoYXNQYXRobmFtZSkgOiAnJykgfHwgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5O1xuICAgIGludGVycG9sYXRlZFJvdXRlID0gcm91dGU7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3Vwcyk7XG4gICAgaWYgKCFwYXJhbXMuZXZlcnkoKHBhcmFtKT0+e1xuICAgICAgICBsZXQgdmFsdWUgPSBkeW5hbWljTWF0Y2hlc1twYXJhbV0gfHwgJyc7XG4gICAgICAgIGNvbnN0IHsgcmVwZWF0ICwgb3B0aW9uYWwgIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXTtcbiAgICAgICAgLy8gc3VwcG9ydCBzaW5nbGUtbGV2ZWwgY2F0Y2gtYWxsXG4gICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYDtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAob3B0aW9uYWwgfHwgcGFyYW0gaW4gZHluYW1pY01hdGNoZXMpICYmIC8vIEludGVycG9sYXRlIGdyb3VwIGludG8gZGF0YSBVUkwgaWYgcHJlc2VudFxuICAgICAgICAoaW50ZXJwb2xhdGVkUm91dGUgPSBpbnRlcnBvbGF0ZWRSb3V0ZS5yZXBsYWNlKHJlcGxhY2VkLCByZXBlYXQgPyB2YWx1ZS5tYXAoLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAoc2VnbWVudCk9PmVuY29kZVVSSUNvbXBvbmVudChzZWdtZW50KSkuam9pbignLycpIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSkgfHwgJy8nKTtcbiAgICB9KSkge1xuICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4gICAgICAgIDtcbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlSHJlZihyb3V0ZXIsIGhyZWYsIHJlc29sdmVBcykge1xuICAgIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gICAgbGV0IGJhc2U7XG4gICAgbGV0IHVybEFzU3RyaW5nID0gdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKTtcbiAgICAvLyByZXBlYXRlZCBzbGFzaGVzIGFuZCBiYWNrc2xhc2hlcyBpbiB0aGUgVVJMIGFyZSBjb25zaWRlcmVkXG4gICAgLy8gaW52YWxpZCBhbmQgd2lsbCBuZXZlciBtYXRjaCBhIE5leHQuanMgcGFnZS9maWxlXG4gICAgY29uc3QgdXJsUHJvdG9NYXRjaCA9IHVybEFzU3RyaW5nLm1hdGNoKC9eW2EtekEtWl17MSx9OlxcL1xcLy8pO1xuICAgIGNvbnN0IHVybEFzU3RyaW5nTm9Qcm90byA9IHVybFByb3RvTWF0Y2ggPyB1cmxBc1N0cmluZy5zbGljZSh1cmxQcm90b01hdGNoWzBdLmxlbmd0aCkgOiB1cmxBc1N0cmluZztcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybEFzU3RyaW5nTm9Qcm90by5zcGxpdCgnPycpO1xuICAgIGlmICgodXJsUGFydHNbMF0gfHwgJycpLm1hdGNoKC8oXFwvXFwvfFxcXFwpLykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byBuZXh0L3JvdXRlcjogJHt1cmxBc1N0cmluZ30sIHJlcGVhdGVkIGZvcndhcmQtc2xhc2hlcyAoLy8pIG9yIGJhY2tzbGFzaGVzIFxcXFwgYXJlIG5vdCB2YWxpZCBpbiB0aGUgaHJlZmApO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVXJsID0gKDAsIF91dGlscykubm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzKHVybEFzU3RyaW5nTm9Qcm90byk7XG4gICAgICAgIHVybEFzU3RyaW5nID0gKHVybFByb3RvTWF0Y2ggPyB1cmxQcm90b01hdGNoWzBdIDogJycpICsgbm9ybWFsaXplZFVybDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGJlY2F1c2UgaXQgY2Fubm90IGJlIHJvdXRlZCBieSB0aGUgTmV4dC5qcyByb3V0ZXJcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsQXNTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICB1cmxBc1N0cmluZ1xuICAgICAgICBdIDogdXJsQXNTdHJpbmc7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKHVybEFzU3RyaW5nLnN0YXJ0c1dpdGgoJyMnKSA/IHJvdXRlci5hc1BhdGggOiByb3V0ZXIucGF0aG5hbWUsICdodHRwOi8vbicpO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gLyBmb3IgaW52YWxpZCBhc1BhdGggdmFsdWVzIGUuZy4gLy9cbiAgICAgICAgYmFzZSA9IG5ldyBVUkwoJy8nLCAnaHR0cDovL24nKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmluYWxVcmwgPSBuZXcgVVJMKHVybEFzU3RyaW5nLCBiYXNlKTtcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZVRyYWlsaW5nU2xhc2gpLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKTtcbiAgICAgICAgbGV0IGludGVycG9sYXRlZEFzID0gJyc7XG4gICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJiByZXNvbHZlQXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gKDAsIF9xdWVyeXN0cmluZykuc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShmaW5hbFVybC5zZWFyY2hQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgLCBwYXJhbXMgIH0gPSBpbnRlcnBvbGF0ZUFzKGZpbmFsVXJsLnBhdGhuYW1lLCBmaW5hbFVybC5wYXRobmFtZSwgcXVlcnkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGludGVycG9sYXRlZEFzID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IG9taXQocXVlcnksIHBhcmFtcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgb3JpZ2luIGRpZG4ndCBjaGFuZ2UsIGl0IG1lYW5zIHdlIHJlY2VpdmVkIGEgcmVsYXRpdmUgaHJlZlxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSBmaW5hbFVybC5vcmlnaW4gPT09IGJhc2Uub3JpZ2luID8gZmluYWxVcmwuaHJlZi5zbGljZShmaW5hbFVybC5vcmlnaW4ubGVuZ3RoKSA6IGZpbmFsVXJsLmhyZWY7XG4gICAgICAgIHJldHVybiByZXNvbHZlQXMgPyBbXG4gICAgICAgICAgICByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgXSA6IHJlc29sdmVkSHJlZjtcbiAgICB9IGNhdGNoIChfMSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZUFzID8gW1xuICAgICAgICAgICAgdXJsQXNTdHJpbmdcbiAgICAgICAgXSA6IHVybEFzU3RyaW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIGNvbnN0IGhyZWZIYWRPcmlnaW4gPSByZXNvbHZlZEhyZWYuc3RhcnRzV2l0aChvcmlnaW4pO1xuICAgIGNvbnN0IGFzSGFkT3JpZ2luID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZkhhZE9yaWdpbiA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzSGFkT3JpZ2luID8gcHJlcGFyZWRBcyA6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHByZXBhcmVkQXMpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKSB7XG4gICAgY29uc3QgY2xlYW5QYXRobmFtZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaCgoMCwgX2Rlbm9ybWFsaXplUGFnZVBhdGgpLmRlbm9ybWFsaXplUGFnZVBhdGgocGF0aG5hbWUpKTtcbiAgICBpZiAoY2xlYW5QYXRobmFtZSA9PT0gJy80MDQnIHx8IGNsZWFuUGF0aG5hbWUgPT09ICcvX2Vycm9yJykge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWU7XG4gICAgfVxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcGFnZXMuc29tZSgocGFnZSk9PntcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocGFnZSkgJiYgKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhKHNvdXJjZSwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0Q29uZmlnID0ge1xuICAgICAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIGxvY2FsZXM6IG9wdGlvbnMucm91dGVyLmxvY2FsZXNcbiAgICAgICAgfSxcbiAgICAgICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpXG4gICAgfTtcbiAgICBjb25zdCByZXdyaXRlSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLXJld3JpdGUnKTtcbiAgICBsZXQgcmV3cml0ZVRhcmdldCA9IHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLW1hdGNoZWQtcGF0aCcpO1xuICAgIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWF0Y2hlZC1wYXRoJyk7XG4gICAgaWYgKG1hdGNoZWRQYXRoICYmICFyZXdyaXRlVGFyZ2V0ICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnX19uZXh0X2RhdGFfY2F0Y2hhbGwnKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy9fZXJyb3InKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy80MDQnKSkge1xuICAgICAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICAgICAgcmV3cml0ZVRhcmdldCA9IG1hdGNoZWRQYXRoO1xuICAgIH1cbiAgICBpZiAocmV3cml0ZVRhcmdldCkge1xuICAgICAgICBpZiAocmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8ocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksIFxuICAgICAgICAgICAgXSkudGhlbigoW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSk9PntcbiAgICAgICAgICAgICAgICBsZXQgYXMgPSAoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKHBhdGhuYW1lSW5mby5wYXRobmFtZSwgcGF0aG5hbWVJbmZvLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShhcykgfHwgIXJld3JpdGVIZWFkZXIgJiYgcGFnZXMuaW5jbHVkZXMoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9ICgwLCBfZ2V0TmV4dFBhdGhuYW1lSW5mbykuZ2V0TmV4dFBhdGhuYW1lSW5mbygoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoc291cmNlKS5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aCgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZXdyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogJydcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZWRpcmVjdCcpO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgICAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiAnJ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWludGVybmFsJyxcbiAgICAgICAgICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgICAgICAgICAgIG5ld1VybDogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiAnbmV4dCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpLnRoZW4oKG1hdGNoZXMpPT57XG4gICAgICAgIGlmIChtYXRjaGVzICYmIG9wdGlvbnMuZmV0Y2hEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5mZXRjaERhdGEoKS50aGVuKChkYXRhKT0+Z2V0TWlkZGxld2FyZURhdGEoZGF0YS5kYXRhSHJlZiwgZGF0YS5yZXNwb25zZSwgb3B0aW9ucykudGhlbigoZWZmZWN0KT0+KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGRhdGEuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZGF0YS5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICAgICAgICAgICAgICB9KSkpLmNhdGNoKChfZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRPRE86IFJldmlzaXQgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAqIEZvciBub3cgd2Ugd2lsbCBub3QgY29uc2lkZXIgbWlkZGxld2FyZSBkYXRhIGVycm9ycyB0byBiZSBmYXRhbC5cbiAgICAgICAgICAgKiBtYXliZSB3ZSBzaG91bGQgcmV2aXNpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAqLyByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiYgISFmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgdiA9ICdfX25leHQnO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHt9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICAneC1uZXh0anMtZGF0YSc6ICcxJ1xuICAgICAgICB9KVxuICAgIH0pLnRoZW4oKHJlc3BvbnNlKT0+e1xuICAgICAgICByZXR1cm4gIXJlc3BvbnNlLm9rICYmIGF0dGVtcHRzID4gMSAmJiByZXNwb25zZS5zdGF0dXMgPj0gNTAwID8gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSwgb3B0aW9ucykgOiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmNvbnN0IGJhY2tncm91bmRDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaGFuZGxlU21vb3RoU2Nyb2xsKGZuKSB7XG4gICAgY29uc3QgaHRtbEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvcjtcbiAgICBodG1sRWxlbWVudC5zdHlsZS5zY3JvbGxCZWhhdmlvciA9ICdhdXRvJztcbiAgICBmbigpO1xuICAgIGh0bWxFbGVtZW50LnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZXhpc3Rpbmc7XG59XG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHsgZGF0YUhyZWYgLCBpbmZsaWdodENhY2hlICwgaXNQcmVmZXRjaCAsIGhhc01pZGRsZXdhcmUgLCBpc1NlcnZlclJlbmRlciAsIHBhcnNlSlNPTiAsIHBlcnNpc3RDYWNoZSAsIGlzQmFja2dyb3VuZCAsIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAgfSkge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgIH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIHJlZjE7XG4gICAgY29uc3QgZ2V0RGF0YSA9IChwYXJhbXMpPT57XG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiBpc1ByZWZldGNoID8ge1xuICAgICAgICAgICAgICAgIHB1cnBvc2U6ICdwcmVmZXRjaCdcbiAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgIG1ldGhvZDogKHJlZjEgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyByZWYxIDogJ0dFVCdcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09ICdIRUFEJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oKHRleHQpPT57XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gdGhlIGRhdGEgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCBiZWNhdXNlIG9mIGEgbWlkZGxld2FyZVxuICAgICAgICAgICAgICogd2UgZG8gbm90IGNvbnNpZGVyIGl0IGFuIGVycm9yLiBUaGUgaGVhZGVycyBtdXN0IGJyaW5nIHRoZVxuICAgICAgICAgICAgICogbWFwcGVkIGxvY2F0aW9uLlxuICAgICAgICAgICAgICogVE9ETzogQ2hhbmdlIHRoZSBzdGF0dXMgY29kZSBpbiB0aGUgaGFuZGxlci5cbiAgICAgICAgICAgICAqLyBpZiAoaGFzTWlkZGxld2FyZSAmJiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDcsXG4gICAgICAgICAgICAgICAgICAgICAgICAzMDhcbiAgICAgICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNNaWRkbGV3YXJlICYmIHJlc3BvbnNlLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChyZWYgPSB0cnlUb1BhcnNlQXNKU09OKHRleHQpKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLm5vdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kOiBTU0dfREFUQV9OT1RfRk9VTkRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYCk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5tYXJrQXNzZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCBkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW1pZGRsZXdhcmUtY2FjaGUnKSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICB9IDoge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybCAsIHJvdXRlciAgfSkge1xuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFyaWFudDogYXR0ZW1wdGVkIHRvIGhhcmQgbmF2aWdhdGUgdG8gdGhlIHNhbWUgVVJMICR7dXJsfSAke2xvY2F0aW9uLmhyZWZ9YCk7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xufVxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9ICh7IHJvdXRlICwgcm91dGVyICB9KT0+e1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYW5jZWwgPSByb3V0ZXIuY2xjID0gKCk9PntcbiAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9ICgpPT57XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsICwgYXMgIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3B1c2hTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IG9wdGlvbnMuX2g7XG4gICAgICAgICAgICBsZXQgc2hvdWxkUmVzb2x2ZUhyZWYgPSBpc1F1ZXJ5VXBkYXRpbmcgfHwgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgfHwgKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aCh1cmwpLnBhdGhuYW1lID09PSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKGFzKS5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IF9leHRlbmRzKHt9LCBfdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAgICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgICAgICAgICAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZSA9IF90aGlzLmlzUmVhZHkgIT09IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzU3NyID0gX3RoaXMuaXNTc3I7XG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcbiAgICAgICAgICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIF90aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlID8gX3RoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChhcykgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcykgOiBhcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aCgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aCh1cmwpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgodXJsKSA6IHVybCwgX3RoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghKChyZWYgPSBfdGhpcy5sb2NhbGVzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKHBhcnNlZEFzLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0RG9tYWluTG9jYWxlKS5kZXRlY3REb21haW5Mb2NhbGUoX3RoaXMuZG9tYWluTG9jYWxlcywgdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpZE5hdmlnYXRlICYmIGRldGVjdGVkRG9tYWluICYmIF90aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0keygwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKGAke25leHRTdGF0ZS5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGUgPyAnJyA6IGAvJHtuZXh0U3RhdGUubG9jYWxlfWB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBzaGFsbG93ID1mYWxzZSAsIHNjcm9sbCA9dHJ1ZSAgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2luRmxpZ2h0Um91dGUgJiYgX3RoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Nzcikge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBidWlsZENhbmNlbGxhdGlvbkVycm9yKCksIF90aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xjKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZSgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChhcykgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIF90aGlzLmRlZmF1bHRMb2NhbGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfcmVtb3ZlTG9jYWxlKS5yZW1vdmVMb2NhbGUoKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgoYXMpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXMpIDogYXMsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgX3RoaXMuX2luRmxpZ2h0Um91dGUgPSBhcztcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgX3RoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5hc1BhdGggPSBjbGVhbmVkQXM7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCB0aGUgcmVzb2x2ZWQgaHJlZiB3aGVuIG9ubHkgYSBoYXNoIGNoYW5nZT9cbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KG5leHRTdGF0ZSwgX3RoaXMuY29tcG9uZW50c1tuZXh0U3RhdGUucm91dGVdLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAgICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAgICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICAgICAgICAgIGxldCBwYWdlcywgcmV3cml0ZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyLmdldE1pZGRsZXdhcmUoKSwgXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgICAgICAgIGlmICghX3RoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgICAgICAgICAgLy8gcGFnZXMgdG8gYWxsb3cgYnVpbGRpbmcgdGhlIGRhdGEgVVJMIGNvcnJlY3RseVxuICAgICAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAgICAgICAgIC8vIHBvaW50IGJ5IGVpdGhlciBuZXh0L2xpbmsgb3Igcm91dGVyLnB1c2gvcmVwbGFjZSBzbyBzdHJpcCB0aGVcbiAgICAgICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lID8gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHBhdGhuYW1lKSkgOiBwYXRobmFtZTtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9IHlpZWxkIG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNoYWxsb3cgJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IF90aGlzLnBhdGhuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVzb2x2ZUhyZWYgJiYgcGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhcy5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdCgoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCBfdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgKyBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlTG9jYWxlKS5yZW1vdmVMb2NhbGUoKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgbGV0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgIGxldCByb3V0ZU1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aG5hbWUgPSBwYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZVJlZ2V4KS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICAgICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRJbnRlcnBvbGF0ZSA9IHJvdXRlID09PSBhc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGUgPyBpbnRlcnBvbGF0ZUFzKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgc2hvdWxkSW50ZXJwb2xhdGUgJiYgIWludGVycG9sYXRlZEFzLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7c2hvdWxkSW50ZXJwb2xhdGUgPyBgSW50ZXJwb2xhdGluZyBocmVmYCA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGB9IGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgKyBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oJywgJyl9IGluIHRoZSBcXGBocmVmXFxgJ3MgXFxgcXVlcnlcXGBgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSkgdG8gYmUgaW50ZXJwb2xhdGVkIHByb3Blcmx5LiBgIDogYFRoZSBwcm92aWRlZCBcXGBhc1xcYCB2YWx1ZSAoJHthc1BhdGhuYW1lfSkgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIFxcYGhyZWZcXGAgdmFsdWUgKCR7cm91dGV9KS4gYCkgKyBgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy8ke3Nob3VsZEludGVycG9sYXRlID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnIDogJ2luY29tcGF0aWJsZS1ocmVmLWFzJ31gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBpbnRlcnBvbGF0ZWRBcy5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogb21pdChxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZWYyLCByZWYzO1xuICAgICAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICgncm91dGUnIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJvdXRlSW5mby5yb3V0ZSB8fCByb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGVJbmZvLnF1ZXJ5IHx8IHt9LCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHBhdGhuYW1lICE9PSBjbGVhbmVkUGFyc2VkUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmV3cml0ZUFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHJld3JpdGVBcywgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9IGxvY2FsZVJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkobmV3IFVSTChyZXdyaXRlQXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSAncmVkaXJlY3QtaW50ZXJuYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hhbmdlKG1ldGhvZCwgcm91dGVJbmZvLm5ld1VybCwgcm91dGVJbmZvLm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB7IGVycm9yICwgcHJvcHMgLCBfX05fU1NHICwgX19OX1NTUCAgfSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIF9zY3JpcHQpLmhhbmRsZUNsaWVudFNjcmlwdExvYWQoc2NyaXB0LnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgICAgICAgICAgIGlmICgoX19OX1NTRyB8fCBfX05fU1NQKSAmJiBwcm9wcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMucGFnZVByb3BzICYmIHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykgJiYgcHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXMoX3RoaXMsIGRlc3RpbmF0aW9uLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFwcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vdEZvdW5kUm91dGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KCcvNDA0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy9fZXJyb3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0geWllbGQgX3RoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gLzQwNGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgcGF0aG5hbWUgPT09ICcvX2Vycm9yJyAmJiAoKHJlZjIgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAocmVmMyA9IHJlZjIucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMy5zdGF0dXNDb2RlKSA9PT0gNTAwICYmIChwcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcHJvcHMucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9yb3V0ZTtcbiAgICAgICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlIDogcm91dGUpO1xuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfc2Nyb2xsIDogIW9wdGlvbnMuX2ggJiYgIWlzVmFsaWRTaGFsbG93Um91dGU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbmV3IHN0YXRlIHRoYXQgdGhlIHJvdXRlciBnb25uYSBzZXRcbiAgICAgICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcbiAgICAgICAgICAgICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy8zNzEzOVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9IG9wdGlvbnMuX2ggJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVTdGF0ZXMpLmNvbXBhcmVSb3V0ZXJTdGF0ZXModXBjb21pbmdSb3V0ZXJTdGF0ZSwgX3RoaXMuc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpLmNhdGNoKChlKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSBlcnJvciA9IGVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQubGFuZyA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsICYmIGhhc2hSZWdleC50ZXN0KGFzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjEpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycjEpICYmIGVycjEuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgKDAsIF91dGlscykuZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSAncHVzaFN0YXRlJyA/IHRoaXMuX2tleSA6IGNyZWF0ZUtleSgpXG4gICAgICAgICAgICB9LCAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgdGhlIGVtcHR5IHN0cmluZyBoZXJlIHNob3VsZCBiZSBzYWZlIGFnYWluc3QgZnV0dXJlIGNoYW5nZXMgdG8gdGhlIG1ldGhvZC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAgICAgJycsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgX3JvdXRlTG9hZGVyKS5pc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCAsIHN0eWxlU2hlZXRzICB9ID0geWllbGQgX3RoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB5aWVsZCBfdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcigoMCwgX2lzRXJyb3IpLmRlZmF1bHQocm91dGVJbmZvRXJyKSA/IHJvdXRlSW5mb0VyciA6IG5ldyBFcnJvcihyb3V0ZUluZm9FcnIgKyAnJyksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBnZXRSb3V0ZUluZm8oeyByb3V0ZTogcmVxdWVzdGVkUm91dGUgLCBwYXRobmFtZSAsIHF1ZXJ5ICwgYXMgLCByZXNvbHZlZEFzICwgcm91dGVQcm9wcyAsIGxvY2FsZSAsIGhhc01pZGRsZXdhcmUgLCBpc1ByZXZpZXcgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgLCBpc1F1ZXJ5VXBkYXRpbmcgIH0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICogVGhpcyBgcm91dGVgIGJpbmRpbmcgY2FuIGNoYW5nZSBpZiB0aGVyZSdzIGEgcmV3cml0ZVxuICAgICAqIHNvIHdlIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIHJlcXVlc3RlZCByb3V0ZVxuICAgICAqIHNvIHdlIGNhbiBzdG9yZSB0aGUgY2FjaGUgZm9yIGl0IGFuZCBhdm9pZCByZS1yZXF1ZXN0aW5nIGV2ZXJ5IHRpbWVcbiAgICAgKiBmb3Igc2hhbGxvdyByb3V0aW5nIHB1cnBvc2VzLlxuICAgICAqLyBsZXQgcm91dGUgPSByZXF1ZXN0ZWRSb3V0ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiwgcmVmNCwgcmVmNTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gX3RoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgX3RoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luZm87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKCdpbml0aWFsJyBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnID8gZXhpc3RpbmdJbmZvIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiBfdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBfdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBfdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiBpc1F1ZXJ5VXBkYXRpbmdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgPyB7fSA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoZmV0Y2hOZXh0RGF0YVBhcmFtcyksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi50eXBlKSA9PT0gJ3JlZGlyZWN0LWludGVybmFsJyB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKHJlZjQgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZjQudHlwZSkgPT09ICdyZWRpcmVjdC1leHRlcm5hbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZWZmZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY1ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiByZWY1LnR5cGUpID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2goZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gX2V4dGVuZHMoe30sIHF1ZXJ5LCBkYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aCgoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgoZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWUsIF90aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gX3RoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIF90aGlzLnJvdXRlID09PSByb3V0ZSAmJiAhaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgcm91dGUgZHVlIHRvIHJld3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gY29weSB0aGUgZXhpc3RpbmcgaW5mb3JtYXRpb24gdG8gdGhlIHJld3JpdHRlbiBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3ZSByZXR1cm4gdGhlIGluZm9ybWF0aW9uIGFsb25nIHdpdGggdGhlIG1hdGNoZWQgcm91dGUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGV4aXN0aW5nSW5mbywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocm91dGUgPT09ICcvYXBpJyB8fCByb3V0ZS5zdGFydHNXaXRoKCcvYXBpLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8ICh5aWVsZCBfdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHByb3BzICwgY2FjaGVLZXkgIH0gPSB5aWVsZCBfdGhpcy5fZ2V0RGF0YShfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBqc29uICwgY2FjaGVLZXk6IF9jYWNoZUtleSAgfSA9IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA6IHlpZWxkIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiBfdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBfdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBfY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHlpZWxkIF90aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IF90aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogX3RoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXG4gICAgICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YShPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogYmFja2dyb3VuZENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZ2V0UHJvcGVyRXJyb3IoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIHNldChzdGF0ZSwgZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJyk7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goYXMpIHtcbiAgICAgICAgY29uc3QgWywgaGFzaCA9ICcnXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgICAgICAgaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT53aW5kb3cuc2Nyb2xsVG8oMCwgMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgY29uc3QgcmF3SGFzaCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKTtcbiAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xuICAgICAgICBpZiAoaWRFbCkge1xuICAgICAgICAgICAgaGFuZGxlU21vb3RoU2Nyb2xsKCgpPT5pZEVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgY29uc3QgbmFtZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUocmF3SGFzaClbMF07XG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgIGhhbmRsZVNtb290aFNjcm9sbCgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gcHJlZmV0Y2godXJsLCBhc1BhdGggPSB1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKDAsIF9pc0JvdCkuaXNCb3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgICAgIC8vIHByZWZldGNoZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcnNlZCA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybCh1cmwpO1xuICAgICAgICAgICAgbGV0IHsgcGF0aG5hbWUgLCBxdWVyeSAgfSA9IHBhcnNlZDtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXRobmFtZSwgX3RoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZUxvY2FsZVBhdGgpLm5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIF90aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBfdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0geWllbGQgX3RoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhc1BhdGg7XG4gICAgICAgICAgICBjb25zdCBsb2NhbGUgPSB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogX3RoaXMubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyAgfSA9IHlpZWxkICgwLCBfcm91dGVMb2FkZXIpLmdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVSZXdyaXRlcykuZGVmYXVsdCgoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKGFzUGF0aCwgX3RoaXMubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCBfdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlTG9jYWxlKS5yZW1vdmVMb2NhbGUoKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgX3RoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcigoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogX3RoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhX3RoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHwgb3B0aW9ucy5wcmlvcml0eSAmJiAhIXByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLCBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0geWllbGQgX3RoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZSBSU0MgZmxpZ2h0IHJlc3BvbnNlIHNpbmNlIGl0J3Mgbm90IGEgc3RhdGljIHJlc291cmNlXG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRydWUsXG4gICAgICAgICAgICBwYXJzZUpTT046IGZhbHNlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2VcbiAgICAgICAgfSkudGhlbigoeyB0ZXh0ICB9KT0+KHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lMSwgcXVlcnkxLCBhczEsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcbiAgICAgICAgLy8gU2VydmVyIERhdGEgQ2FjaGVcbiAgICAgICAgdGhpcy5zZGMgPSB7fTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdldCBzdGF0ZSBhcyB1bmRlZmluZWQgZm9yIHR3byByZWFzb25zLlxuICAgICAgICAgICAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgICAgICAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAgICAgICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gc2ltcGx5IHJlcGxhY2UgdGhlIHN0YXRlIHdpdGggdGhlIG5ldyBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICwgcXVlcnkgIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgfSksICgwLCBfdXRpbHMpLmdldFVSTCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBfX05BIGlzIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGhpc3RvcnkgZW50cnkgY2FuIGJlIGhhbmRsZWQgYnkgdGhlIGFwcC1yb3V0ZXIuXG4gICAgICAgICAgICBpZiAoc3RhdGUuX19OQSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXRlLl9fTikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhZmFyaSBmaXJlcyBwb3BzdGF0ZWV2ZW50IHdoZW4gcmVvcGVuaW5nIHRoZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICYmIHRoaXMubG9jYWxlID09PSBzdGF0ZS5vcHRpb25zLmxvY2FsZSAmJiBzdGF0ZS5hcyA9PT0gdGhpcy5hc1BhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2VkU2Nyb2xsO1xuICAgICAgICAgICAgY29uc3QgeyB1cmwgLCBhcyAsIG9wdGlvbnMgLCBrZXkgIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0gSlNPTi5wYXJzZSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCh0aGlzLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGludGVybmFsIHZhbHVlIG5vdCBleHBvc2VkIG9uIHR5cGVzXG4gICAgICAgICAgICAgICAgX2g6IDBcbiAgICAgICAgICAgIH0pLCBmb3JjZWRTY3JvbGwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUxKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lMSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1BcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIGJlIHJlbW92ZSB0aGUgZm9sbG93aW5nIG1ham9yIHZlcnNpb24gYXMgaXQgd2FzIG5ldmVyIGRvY3VtZW50ZWRcbiAgICAgICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzO1xuICAgICAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICAgICAgICAvLyBpZiBhdXRvIHByZXJlbmRlcmVkIGFuZCBkeW5hbWljIHJvdXRlIHdhaXQgdG8gdXBkYXRlIGFzUGF0aFxuICAgICAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBjb25zdCBhdXRvRXhwb3J0RHluYW1pYyA9ICgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZTEpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCAnJztcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhKDAsIF9kZXRlY3REb21haW5Mb2NhbGUpLmRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUxLFxuICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5MSxcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZTEgOiBhczEsXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxuICAgICAgICAgICAgbG9jYWxlOiBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUID8gbG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMxLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNQYXRoID0gKDAsIF91dGlscykuZ2V0VVJMKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKG1hdGNoZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMxICE9PSBwYXRobmFtZTE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhdGhuYW1lMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnkxXG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblJvdXRlci5ldmVudHMgPSAoMCwgX21pdHQpLmRlZmF1bHQoKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiaXNMb2NhbFVSTCIsImludGVycG9sYXRlQXMiLCJyZXNvbHZlSHJlZiIsImNyZWF0ZUtleSIsImRlZmF1bHQiLCJfYXN5bmNfdG9fZ2VuZXJhdG9yIiwicmVxdWlyZSIsIl9leHRlbmRzIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiX3JlbW92ZVRyYWlsaW5nU2xhc2giLCJfcm91dGVMb2FkZXIiLCJfc2NyaXB0IiwiX2lzRXJyb3IiLCJfZGVub3JtYWxpemVQYWdlUGF0aCIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNEeW5hbWljIiwiX3BhcnNlUmVsYXRpdmVVcmwiLCJfcXVlcnlzdHJpbmciLCJfcmVzb2x2ZVJld3JpdGVzIiwiX3JvdXRlTWF0Y2hlciIsIl9yb3V0ZVJlZ2V4IiwiX2Zvcm1hdFVybCIsIl9kZXRlY3REb21haW5Mb2NhbGUiLCJfcGFyc2VQYXRoIiwiX2FkZExvY2FsZSIsIl9yZW1vdmVMb2NhbGUiLCJfcmVtb3ZlQmFzZVBhdGgiLCJfYWRkQmFzZVBhdGgiLCJfaGFzQmFzZVBhdGgiLCJfZ2V0TmV4dFBhdGhuYW1lSW5mbyIsIl9mb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiX2NvbXBhcmVTdGF0ZXMiLCJfaXNCb3QiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwiX21hdGNoZXNNaWRkbGV3YXJlIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJtYXRjaGVycyIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXRobmFtZSIsImFzUGF0aG5hbWUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJjbGVhbmVkQXMiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwib21pdCIsIm9iamVjdCIsImtleXMiLCJvbWl0dGVkIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiaXNBYnNvbHV0ZVVybCIsImxvY2F0aW9uT3JpZ2luIiwicmVzb2x2ZWQiLCJVUkwiLCJfIiwicm91dGUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInBhcmFtcyIsImV2ZXJ5IiwicGFyYW0iLCJyZXBlYXQiLCJvcHRpb25hbCIsInJlcGxhY2VkIiwiQXJyYXkiLCJpc0FycmF5IiwicmVwbGFjZSIsIm1hcCIsInNlZ21lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJqb2luIiwicmVzdWx0IiwiaHJlZiIsInJlc29sdmVBcyIsImJhc2UiLCJ1cmxBc1N0cmluZyIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsUHJvdG9NYXRjaCIsIm1hdGNoIiwidXJsQXNTdHJpbmdOb1Byb3RvIiwic2xpY2UiLCJ1cmxQYXJ0cyIsInNwbGl0IiwiY29uc29sZSIsImVycm9yIiwibm9ybWFsaXplZFVybCIsIm5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyIsImZpbmFsVXJsIiwibm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2giLCJpbnRlcnBvbGF0ZWRBcyIsImlzRHluYW1pY1JvdXRlIiwic2VhcmNoUGFyYW1zIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsImhhc2giLCJyZXNvbHZlZEhyZWYiLCJfMSIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRBcyIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZGVub3JtYWxpemVQYWdlUGF0aCIsInBhZ2UiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0IiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImFsbCIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZmV0Y2hEYXRhIiwiZGF0YSIsImRhdGFIcmVmIiwiZWZmZWN0IiwiY2FjaGVLZXkiLCJqc29uIiwidGV4dCIsImNhdGNoIiwiX2VyciIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiIsIndpbmRvdyIsImhpc3RvcnkiLCJ2Iiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsIm4iLCJTU0dfREFUQV9OT1RfRk9VTkQiLCJTeW1ib2wiLCJmZXRjaFJldHJ5IiwiYXR0ZW1wdHMiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwibWV0aG9kIiwib2siLCJzdGF0dXMiLCJiYWNrZ3JvdW5kQ2FjaGUiLCJoYW5kbGVTbW9vdGhTY3JvbGwiLCJmbiIsImh0bWxFbGVtZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJleGlzdGluZyIsInN0eWxlIiwic2Nyb2xsQmVoYXZpb3IiLCJ0cnlUb1BhcnNlQXNKU09OIiwiSlNPTiIsInBhcnNlIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwibG9jYXRpb24iLCJyZWYxIiwiZ2V0RGF0YSIsInB1cnBvc2UiLCJyZWYiLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiZXJyIiwidW5kZWZpbmVkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwiY2FuY2VsIiwiY2xjIiwiaGFuZGxlQ2FuY2VsbGVkIiwiUm91dGVyIiwicmVsb2FkIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwiX2tleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJlIiwiY2hhbmdlIiwiZm9yY2VkU2Nyb2xsIiwiX3RoaXMiLCJpc1F1ZXJ5VXBkYXRpbmciLCJfaCIsInNob3VsZFJlc29sdmVIcmVmIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwibmV4dFN0YXRlIiwic3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwiaXNSZWFkeSIsImlzU3NyIiwicHJldkxvY2FsZSIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkaWROYXZpZ2F0ZSIsImRldGVjdGVkRG9tYWluIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiZG9tYWluTG9jYWxlcyIsImlzTG9jYWxlRG9tYWluIiwiaG9zdG5hbWUiLCJkb21haW4iLCJhc05vQmFzZVBhdGgiLCJodHRwIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJzaGFsbG93Iiwic2Nyb2xsIiwicm91dGVQcm9wcyIsIl9pbkZsaWdodFJvdXRlIiwiZXZlbnRzIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsImxvY2FsZUNoYW5nZSIsIm9ubHlBSGFzaENoYW5nZSIsImNoYW5nZVN0YXRlIiwic2Nyb2xsVG9IYXNoIiwic2V0IiwiY29tcG9uZW50cyIsInBhcnNlZCIsInVybElzTmV3IiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsImZpbHRlciIsIndhcm4iLCJyZWYyIiwicmVmMyIsInJvdXRlSW5mbyIsImdldFJvdXRlSW5mbyIsImlzUHJldmlldyIsImlzRmFsbGJhY2siLCJjbGVhbmVkUGFyc2VkUGF0aG5hbWUiLCJwcmVmaXhlZEFzIiwicmV3cml0ZUFzIiwibG9jYWxlUmVzdWx0IiwiY3VyUm91dGVNYXRjaCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJjb21wb25lbnQiLCJDb21wb25lbnQiLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJzY3JpcHRzIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJwYXJzZWRIcmVmIiwiX19OX1BSRVZJRVciLCJub3RGb3VuZFJvdXRlIiwiZmV0Y2hDb21wb25lbnQiLCJfX05FWFRfREFUQV9fIiwic3RhdHVzQ29kZSIsIl9yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfc2Nyb2xsIiwic2hvdWxkU2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsImNhblNraXBVcGRhdGluZyIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJsYW5nIiwiaGFzaFJlZ2V4IiwiZXJyMSIsImdldFVSTCIsIl9zaGFsbG93IiwiX19OIiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwic3R5bGVTaGVldHMiLCJnZXRJbml0aWFsUHJvcHMiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJyZXF1ZXN0ZWRSb3V0ZSIsInJlZjQiLCJyZWY1IiwiZXhpc3RpbmdJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiZmV0Y2hOZXh0RGF0YVBhcmFtcyIsImdldERhdGFIcmVmIiwic2tpcEludGVycG9sYXRpb24iLCJzZGMiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJzaG91bGRGZXRjaERhdGEiLCJfZ2V0RGF0YSIsIl9jYWNoZUtleSIsImdldFByb3BlckVycm9yIiwic3ViIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIl9icHMiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJwcmVmZXRjaCIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiX2lzU3NnIiwiaXNTc2ciLCJwcmlvcml0eSIsIl9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRSIsImNvbXBvbmVudFJlc3VsdCIsImxvYWRQYWdlIiwiX2dldEZsaWdodERhdGEiLCJjdHgiLCJBcHAiLCJBcHBUcmVlIiwiX3dyYXBBcHAiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiY29uc3RydWN0b3IiLCJwYXRobmFtZTEiLCJxdWVyeTEiLCJhczEiLCJpbml0aWFsUHJvcHMiLCJ3cmFwQXBwIiwic3Vic2NyaXB0aW9uIiwiaXNGaXJzdFBvcFN0YXRlRXZlbnQiLCJvblBvcFN0YXRlIiwiX19OQSIsImdldEl0ZW0iLCJlMSIsImluaXRpYWwiLCJhdXRvRXhwb3J0RHluYW1pYyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/add-locale.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-locale.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addLocale = addLocale;\nvar _addPathPrefix = __webpack_require__(/*! ./add-path-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nvar _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction addLocale(path, locale, defaultLocale, ignorePrefix) {\n    if (locale && locale !== defaultLocale && (ignorePrefix || !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), \"/\".concat(locale.toLowerCase())) && !(0, _pathHasPrefix).pathHasPrefix(path.toLowerCase(), \"/api\"))) {\n        return (0, _addPathPrefix).addPathPrefix(path, \"/\".concat(locale));\n    }\n    return path;\n} //# sourceMappingURL=add-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCLElBQUlDLGlCQUFpQkMsbUJBQU9BLENBQUMsOEZBQW1CO0FBQ2hELElBQUlDLGlCQUFpQkQsbUJBQU9BLENBQUMsOEZBQW1CO0FBQ2hELFNBQVNGLFVBQVVJLElBQUksRUFBRUMsTUFBTSxFQUFFQyxhQUFhLEVBQUVDLFlBQVksRUFBRTtJQUMxRCxJQUFJRixVQUFVQSxXQUFXQyxpQkFBa0JDLENBQUFBLGdCQUFnQixDQUFDLENBQUMsR0FBR0osY0FBYyxFQUFFSyxhQUFhLENBQUNKLEtBQUtLLFdBQVcsSUFBSSxJQUF5QixPQUFyQkosT0FBT0ksV0FBVyxRQUFTLENBQUMsQ0FBQyxHQUFHTixjQUFjLEVBQUVLLGFBQWEsQ0FBQ0osS0FBS0ssV0FBVyxJQUFJLE9BQU0sR0FBSTtRQUM5TSxPQUFPLENBQUMsR0FBR1IsY0FBYyxFQUFFUyxhQUFhLENBQUNOLE1BQU0sSUFBVyxPQUFQQztJQUN2RCxDQUFDO0lBQ0QsT0FBT0Q7QUFDWCxFQUVBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1sb2NhbGUuanM/MDIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYWRkTG9jYWxlID0gYWRkTG9jYWxlO1xudmFyIF9hZGRQYXRoUHJlZml4ID0gcmVxdWlyZShcIi4vYWRkLXBhdGgtcHJlZml4XCIpO1xudmFyIF9wYXRoSGFzUHJlZml4ID0gcmVxdWlyZShcIi4vcGF0aC1oYXMtcHJlZml4XCIpO1xuZnVuY3Rpb24gYWRkTG9jYWxlKHBhdGgsIGxvY2FsZSwgZGVmYXVsdExvY2FsZSwgaWdub3JlUHJlZml4KSB7XG4gICAgaWYgKGxvY2FsZSAmJiBsb2NhbGUgIT09IGRlZmF1bHRMb2NhbGUgJiYgKGlnbm9yZVByZWZpeCB8fCAhKDAsIF9wYXRoSGFzUHJlZml4KS5wYXRoSGFzUHJlZml4KHBhdGgudG9Mb3dlckNhc2UoKSwgYC8ke2xvY2FsZS50b0xvd2VyQ2FzZSgpfWApICYmICEoMCwgX3BhdGhIYXNQcmVmaXgpLnBhdGhIYXNQcmVmaXgocGF0aC50b0xvd2VyQ2FzZSgpLCAnL2FwaScpKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9hZGRQYXRoUHJlZml4KS5hZGRQYXRoUHJlZml4KHBhdGgsIGAvJHtsb2NhbGV9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtbG9jYWxlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZExvY2FsZSIsIl9hZGRQYXRoUHJlZml4IiwicmVxdWlyZSIsIl9wYXRoSGFzUHJlZml4IiwicGF0aCIsImxvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJpZ25vcmVQcmVmaXgiLCJwYXRoSGFzUHJlZml4IiwidG9Mb3dlckNhc2UiLCJhZGRQYXRoUHJlZml4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/add-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addPathPrefix = addPathPrefix;\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith(\"/\") || !prefix) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    return \"\".concat(prefix).concat(pathname).concat(query).concat(hash);\n} //# sourceMappingURL=add-path-prefix.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXByZWZpeC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSUMsYUFBYUMsbUJBQU9BLENBQUMsb0ZBQWM7QUFDdkMsU0FBU0YsY0FBY0csSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDakMsSUFBSSxDQUFDRCxLQUFLRSxVQUFVLENBQUMsUUFBUSxDQUFDRCxRQUFRO1FBQ2xDLE9BQU9EO0lBQ1gsQ0FBQztJQUNELE1BQU0sRUFBRUcsU0FBUSxFQUFHQyxNQUFLLEVBQUdDLEtBQUksRUFBRyxHQUFHLENBQUMsR0FBR1AsVUFBVSxFQUFFUSxTQUFTLENBQUNOO0lBQy9ELE9BQU8sR0FBWUcsT0FBVEYsUUFBb0JHLE9BQVhELFVBQW1CRSxPQUFSRCxPQUFhLE9BQUxDO0FBQzFDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtcHJlZml4LmpzP2MxMjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZFBhdGhQcmVmaXggPSBhZGRQYXRoUHJlZml4O1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi9wYXJzZS1wYXRoXCIpO1xuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAsIGhhc2ggIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBgJHtwcmVmaXh9JHtwYXRobmFtZX0ke3F1ZXJ5fSR7aGFzaH1gO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtcGF0aC1wcmVmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkUGF0aFByZWZpeCIsIl9wYXJzZVBhdGgiLCJyZXF1aXJlIiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCIsInBhcnNlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addPathSuffix = addPathSuffix;\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction addPathSuffix(path, suffix) {\n    if (!path.startsWith(\"/\") || !suffix) {\n        return path;\n    }\n    const { pathname , query , hash  } = (0, _parsePath).parsePath(path);\n    return \"\".concat(pathname).concat(suffix).concat(query).concat(hash);\n} //# sourceMappingURL=add-path-suffix.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2FkZC1wYXRoLXN1ZmZpeC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSUMsYUFBYUMsbUJBQU9BLENBQUMsb0ZBQWM7QUFDdkMsU0FBU0YsY0FBY0csSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDakMsSUFBSSxDQUFDRCxLQUFLRSxVQUFVLENBQUMsUUFBUSxDQUFDRCxRQUFRO1FBQ2xDLE9BQU9EO0lBQ1gsQ0FBQztJQUNELE1BQU0sRUFBRUcsU0FBUSxFQUFHQyxNQUFLLEVBQUdDLEtBQUksRUFBRyxHQUFHLENBQUMsR0FBR1AsVUFBVSxFQUFFUSxTQUFTLENBQUNOO0lBQy9ELE9BQU8sR0FBY0MsT0FBWEUsVUFBb0JDLE9BQVRILFFBQWlCSSxPQUFSRCxPQUFhLE9BQUxDO0FBQzFDLEVBRUEsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvYWRkLXBhdGgtc3VmZml4LmpzPzdiMzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFkZFBhdGhTdWZmaXggPSBhZGRQYXRoU3VmZml4O1xudmFyIF9wYXJzZVBhdGggPSByZXF1aXJlKFwiLi9wYXJzZS1wYXRoXCIpO1xuZnVuY3Rpb24gYWRkUGF0aFN1ZmZpeChwYXRoLCBzdWZmaXgpIHtcbiAgICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpIHx8ICFzdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aG5hbWUgLCBxdWVyeSAsIGhhc2ggIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBgJHtwYXRobmFtZX0ke3N1ZmZpeH0ke3F1ZXJ5fSR7aGFzaH1gO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtcGF0aC1zdWZmaXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYWRkUGF0aFN1ZmZpeCIsIl9wYXJzZVBhdGgiLCJyZXF1aXJlIiwicGF0aCIsInN1ZmZpeCIsInN0YXJ0c1dpdGgiLCJwYXRobmFtZSIsInF1ZXJ5IiwiaGFzaCIsInBhcnNlUGF0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/compare-states.js":
/*!**************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/compare-states.js ***!
  \**************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.compareRouterStates = compareRouterStates;\nfunction compareRouterStates(a, b) {\n    const stateKeys = Object.keys(a);\n    if (stateKeys.length !== Object.keys(b).length) return false;\n    for(let i = stateKeys.length; i--;){\n        const key = stateKeys[i];\n        if (key === \"query\") {\n            const queryKeys = Object.keys(a.query);\n            if (queryKeys.length !== Object.keys(b.query).length) {\n                return false;\n            }\n            for(let j = queryKeys.length; j--;){\n                const queryKey = queryKeys[j];\n                if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {\n                    return false;\n                }\n            }\n        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {\n            return false;\n        }\n    }\n    return true;\n} //# sourceMappingURL=compare-states.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2NvbXBhcmUtc3RhdGVzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDJCQUEyQixHQUFHRTtBQUM5QixTQUFTQSxvQkFBb0JDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO0lBQy9CLE1BQU1DLFlBQVlQLE9BQU9RLElBQUksQ0FBQ0g7SUFDOUIsSUFBSUUsVUFBVUUsTUFBTSxLQUFLVCxPQUFPUSxJQUFJLENBQUNGLEdBQUdHLE1BQU0sRUFBRSxPQUFPLEtBQUs7SUFDNUQsSUFBSSxJQUFJQyxJQUFJSCxVQUFVRSxNQUFNLEVBQUVDLEtBQUs7UUFDL0IsTUFBTUMsTUFBTUosU0FBUyxDQUFDRyxFQUFFO1FBQ3hCLElBQUlDLFFBQVEsU0FBUztZQUNqQixNQUFNQyxZQUFZWixPQUFPUSxJQUFJLENBQUNILEVBQUVRLEtBQUs7WUFDckMsSUFBSUQsVUFBVUgsTUFBTSxLQUFLVCxPQUFPUSxJQUFJLENBQUNGLEVBQUVPLEtBQUssRUFBRUosTUFBTSxFQUFFO2dCQUNsRCxPQUFPLEtBQUs7WUFDaEIsQ0FBQztZQUNELElBQUksSUFBSUssSUFBSUYsVUFBVUgsTUFBTSxFQUFFSyxLQUFLO2dCQUMvQixNQUFNQyxXQUFXSCxTQUFTLENBQUNFLEVBQUU7Z0JBQzdCLElBQUksQ0FBQ1IsRUFBRU8sS0FBSyxDQUFDRyxjQUFjLENBQUNELGFBQWFWLEVBQUVRLEtBQUssQ0FBQ0UsU0FBUyxLQUFLVCxFQUFFTyxLQUFLLENBQUNFLFNBQVMsRUFBRTtvQkFDOUUsT0FBTyxLQUFLO2dCQUNoQixDQUFDO1lBQ0w7UUFDSixPQUFPLElBQUksQ0FBQ1QsRUFBRVUsY0FBYyxDQUFDTCxRQUFRTixDQUFDLENBQUNNLElBQUksS0FBS0wsQ0FBQyxDQUFDSyxJQUFJLEVBQUU7WUFDcEQsT0FBTyxLQUFLO1FBQ2hCLENBQUM7SUFDTDtJQUNBLE9BQU8sSUFBSTtBQUNmLEVBRUEsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvY29tcGFyZS1zdGF0ZXMuanM/ZWEwZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29tcGFyZVJvdXRlclN0YXRlcyA9IGNvbXBhcmVSb3V0ZXJTdGF0ZXM7XG5mdW5jdGlvbiBjb21wYXJlUm91dGVyU3RhdGVzKGEsIGIpIHtcbiAgICBjb25zdCBzdGF0ZUtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBpZiAoc3RhdGVLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yKGxldCBpID0gc3RhdGVLZXlzLmxlbmd0aDsgaS0tOyl7XG4gICAgICAgIGNvbnN0IGtleSA9IHN0YXRlS2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3F1ZXJ5Jykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnlLZXlzID0gT2JqZWN0LmtleXMoYS5xdWVyeSk7XG4gICAgICAgICAgICBpZiAocXVlcnlLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYi5xdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKGxldCBqID0gcXVlcnlLZXlzLmxlbmd0aDsgai0tOyl7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBxdWVyeUtleXNbal07XG4gICAgICAgICAgICAgICAgaWYgKCFiLnF1ZXJ5Lmhhc093blByb3BlcnR5KHF1ZXJ5S2V5KSB8fCBhLnF1ZXJ5W3F1ZXJ5S2V5XSAhPT0gYi5xdWVyeVtxdWVyeUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghYi5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhcmUtc3RhdGVzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJhIiwiYiIsInN0YXRlS2V5cyIsImtleXMiLCJsZW5ndGgiLCJpIiwia2V5IiwicXVlcnlLZXlzIiwicXVlcnkiLCJqIiwicXVlcnlLZXkiLCJoYXNPd25Qcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/compare-states.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js ***!
  \*************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.formatNextPathnameInfo = formatNextPathnameInfo;\nvar _removeTrailingSlash = __webpack_require__(/*! ./remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _addPathPrefix = __webpack_require__(/*! ./add-path-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js\");\nvar _addPathSuffix = __webpack_require__(/*! ./add-path-suffix */ \"./node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js\");\nvar _addLocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/shared/lib/router/utils/add-locale.js\");\nfunction formatNextPathnameInfo(info) {\n    let pathname = (0, _addLocale).addLocale(info.pathname, info.locale, info.buildId ? undefined : info.defaultLocale, info.ignorePrefix);\n    if (info.buildId || !info.trailingSlash) {\n        pathname = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n    }\n    if (info.buildId) {\n        pathname = (0, _addPathSuffix).addPathSuffix((0, _addPathPrefix).addPathPrefix(pathname, \"/_next/data/\".concat(info.buildId)), info.pathname === \"/\" ? \"index.json\" : \".json\");\n    }\n    pathname = (0, _addPathPrefix).addPathPrefix(pathname, info.basePath);\n    return !info.buildId && info.trailingSlash ? !pathname.endsWith(\"/\") ? (0, _addPathSuffix).addPathSuffix(pathname, \"/\") : pathname : (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n} //# sourceMappingURL=format-next-pathname-info.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsOEJBQThCLEdBQUdFO0FBQ2pDLElBQUlDLHVCQUF1QkMsbUJBQU9BLENBQUMsMEdBQXlCO0FBQzVELElBQUlDLGlCQUFpQkQsbUJBQU9BLENBQUMsOEZBQW1CO0FBQ2hELElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUMsOEZBQW1CO0FBQ2hELElBQUlHLGFBQWFILG1CQUFPQSxDQUFDLG9GQUFjO0FBQ3ZDLFNBQVNGLHVCQUF1Qk0sSUFBSSxFQUFFO0lBQ2xDLElBQUlDLFdBQVcsQ0FBQyxHQUFHRixVQUFVLEVBQUVHLFNBQVMsQ0FBQ0YsS0FBS0MsUUFBUSxFQUFFRCxLQUFLRyxNQUFNLEVBQUVILEtBQUtJLE9BQU8sR0FBR0MsWUFBWUwsS0FBS00sYUFBYSxFQUFFTixLQUFLTyxZQUFZO0lBQ3JJLElBQUlQLEtBQUtJLE9BQU8sSUFBSSxDQUFDSixLQUFLUSxhQUFhLEVBQUU7UUFDckNQLFdBQVcsQ0FBQyxHQUFHTixvQkFBb0IsRUFBRWMsbUJBQW1CLENBQUNSO0lBQzdELENBQUM7SUFDRCxJQUFJRCxLQUFLSSxPQUFPLEVBQUU7UUFDZEgsV0FBVyxDQUFDLEdBQUdILGNBQWMsRUFBRVksYUFBYSxDQUFDLENBQUMsR0FBR2IsY0FBYyxFQUFFYyxhQUFhLENBQUNWLFVBQVUsZUFBNEIsT0FBYkQsS0FBS0ksT0FBTyxJQUFLSixLQUFLQyxRQUFRLEtBQUssTUFBTSxlQUFlLE9BQU87SUFDM0ssQ0FBQztJQUNEQSxXQUFXLENBQUMsR0FBR0osY0FBYyxFQUFFYyxhQUFhLENBQUNWLFVBQVVELEtBQUtZLFFBQVE7SUFDcEUsT0FBTyxDQUFDWixLQUFLSSxPQUFPLElBQUlKLEtBQUtRLGFBQWEsR0FBRyxDQUFDUCxTQUFTWSxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUdmLGNBQWMsRUFBRVksYUFBYSxDQUFDVCxVQUFVLE9BQU9BLFFBQVEsR0FBRyxDQUFDLEdBQUdOLG9CQUFvQixFQUFFYyxtQkFBbUIsQ0FBQ1IsU0FBUztBQUNoTSxFQUVBLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8uanM/YjE0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyA9IGZvcm1hdE5leHRQYXRobmFtZUluZm87XG52YXIgX3JlbW92ZVRyYWlsaW5nU2xhc2ggPSByZXF1aXJlKFwiLi9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG52YXIgX2FkZFBhdGhQcmVmaXggPSByZXF1aXJlKFwiLi9hZGQtcGF0aC1wcmVmaXhcIik7XG52YXIgX2FkZFBhdGhTdWZmaXggPSByZXF1aXJlKFwiLi9hZGQtcGF0aC1zdWZmaXhcIik7XG52YXIgX2FkZExvY2FsZSA9IHJlcXVpcmUoXCIuL2FkZC1sb2NhbGVcIik7XG5mdW5jdGlvbiBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKGluZm8pIHtcbiAgICBsZXQgcGF0aG5hbWUgPSAoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKGluZm8ucGF0aG5hbWUsIGluZm8ubG9jYWxlLCBpbmZvLmJ1aWxkSWQgPyB1bmRlZmluZWQgOiBpbmZvLmRlZmF1bHRMb2NhbGUsIGluZm8uaWdub3JlUHJlZml4KTtcbiAgICBpZiAoaW5mby5idWlsZElkIHx8ICFpbmZvLnRyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgcGF0aG5hbWUgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xuICAgIH1cbiAgICBpZiAoaW5mby5idWlsZElkKSB7XG4gICAgICAgIHBhdGhuYW1lID0gKDAsIF9hZGRQYXRoU3VmZml4KS5hZGRQYXRoU3VmZml4KCgwLCBfYWRkUGF0aFByZWZpeCkuYWRkUGF0aFByZWZpeChwYXRobmFtZSwgYC9fbmV4dC9kYXRhLyR7aW5mby5idWlsZElkfWApLCBpbmZvLnBhdGhuYW1lID09PSAnLycgPyAnaW5kZXguanNvbicgOiAnLmpzb24nKTtcbiAgICB9XG4gICAgcGF0aG5hbWUgPSAoMCwgX2FkZFBhdGhQcmVmaXgpLmFkZFBhdGhQcmVmaXgocGF0aG5hbWUsIGluZm8uYmFzZVBhdGgpO1xuICAgIHJldHVybiAhaW5mby5idWlsZElkICYmIGluZm8udHJhaWxpbmdTbGFzaCA/ICFwYXRobmFtZS5lbmRzV2l0aCgnLycpID8gKDAsIF9hZGRQYXRoU3VmZml4KS5hZGRQYXRoU3VmZml4KHBhdGhuYW1lLCAnLycpIDogcGF0aG5hbWUgOiAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZvcm1hdE5leHRQYXRobmFtZUluZm8iLCJfcmVtb3ZlVHJhaWxpbmdTbGFzaCIsInJlcXVpcmUiLCJfYWRkUGF0aFByZWZpeCIsIl9hZGRQYXRoU3VmZml4IiwiX2FkZExvY2FsZSIsImluZm8iLCJwYXRobmFtZSIsImFkZExvY2FsZSIsImxvY2FsZSIsImJ1aWxkSWQiLCJ1bmRlZmluZWQiLCJkZWZhdWx0TG9jYWxlIiwiaWdub3JlUHJlZml4IiwidHJhaWxpbmdTbGFzaCIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJhZGRQYXRoU3VmZml4IiwiYWRkUGF0aFByZWZpeCIsImJhc2VQYXRoIiwiZW5kc1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.formatUrl = formatUrl;\nexports.formatWithValidation = formatWithValidation;\nexports.urlObjectKeys = void 0;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar querystring = _interop_require_wildcard(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth , hostname  } = urlObj;\n    let protocol = urlObj.protocol || \"\";\n    let pathname = urlObj.pathname || \"\";\n    let hash = urlObj.hash || \"\";\n    let query = urlObj.query || \"\";\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, \":\") + \"@\" : \"\";\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(\":\") ? \"[\".concat(hostname, \"]\") : hostname);\n        if (urlObj.port) {\n            host += \":\" + urlObj.port;\n        }\n    }\n    if (query && typeof query === \"object\") {\n        query = String(querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\".concat(query) || \"\";\n    if (protocol && !protocol.endsWith(\":\")) protocol += \":\";\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = \"//\" + (host || \"\");\n        if (pathname && pathname[0] !== \"/\") pathname = \"/\" + pathname;\n    } else if (!host) {\n        host = \"\";\n    }\n    if (hash && hash[0] !== \"#\") hash = \"#\" + hash;\n    if (search && search[0] !== \"?\") search = \"?\" + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace(\"#\", \"%23\");\n    return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n}\nconst urlObjectKeys = [\n    \"auth\",\n    \"hash\",\n    \"host\",\n    \"hostname\",\n    \"href\",\n    \"path\",\n    \"pathname\",\n    \"port\",\n    \"protocol\",\n    \"query\",\n    \"search\",\n    \"slashes\"\n];\nexports.urlObjectKeys = urlObjectKeys;\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === \"object\") {\n            Object.keys(url).forEach((key)=>{\n                if (urlObjectKeys.indexOf(key) === -1) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \".concat(key));\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCRiw0QkFBNEIsR0FBR0c7QUFDL0JILHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUssNEJBQTRCQyxxSkFBZ0U7QUFDaEcsSUFBSUUsY0FBY0gsMEJBQTBCQyxtQkFBT0EsQ0FBQyxzRkFBZTtBQUNuRSxNQUFNRyxtQkFBbUI7QUFDekIsU0FBU1AsVUFBVVEsTUFBTSxFQUFFO0lBQ3ZCLElBQUksRUFBRUMsS0FBSSxFQUFHQyxTQUFRLEVBQUcsR0FBR0Y7SUFDM0IsSUFBSUcsV0FBV0gsT0FBT0csUUFBUSxJQUFJO0lBQ2xDLElBQUlDLFdBQVdKLE9BQU9JLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxPQUFPTCxPQUFPSyxJQUFJLElBQUk7SUFDMUIsSUFBSUMsUUFBUU4sT0FBT00sS0FBSyxJQUFJO0lBQzVCLElBQUlDLE9BQU8sS0FBSztJQUNoQk4sT0FBT0EsT0FBT08sbUJBQW1CUCxNQUFNUSxPQUFPLENBQUMsUUFBUSxPQUFPLE1BQU0sRUFBRTtJQUN0RSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDYkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUM3QixPQUFPLElBQUlMLFVBQVU7UUFDakJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQU8sSUFBYSxPQUFUUixVQUFTLE9BQUtBLFFBQVE7UUFDbEUsSUFBSUYsT0FBT1csSUFBSSxFQUFFO1lBQ2JKLFFBQVEsTUFBTVAsT0FBT1csSUFBSTtRQUM3QixDQUFDO0lBQ0wsQ0FBQztJQUNELElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3BDQSxRQUFRTSxPQUFPZCxZQUFZZSxzQkFBc0IsQ0FBQ1A7SUFDdEQsQ0FBQztJQUNELElBQUlRLFNBQVNkLE9BQU9jLE1BQU0sSUFBSVIsU0FBUyxJQUFVLE9BQU5BLFVBQVc7SUFDdEQsSUFBSUgsWUFBWSxDQUFDQSxTQUFTWSxRQUFRLENBQUMsTUFBTVosWUFBWTtJQUNyRCxJQUFJSCxPQUFPZ0IsT0FBTyxJQUFJLENBQUMsQ0FBQ2IsWUFBWUosaUJBQWlCa0IsSUFBSSxDQUFDZCxTQUFRLEtBQU1JLFNBQVMsS0FBSyxFQUFFO1FBQ3BGQSxPQUFPLE9BQVFBLENBQUFBLFFBQVEsRUFBQztRQUN4QixJQUFJSCxZQUFZQSxRQUFRLENBQUMsRUFBRSxLQUFLLEtBQUtBLFdBQVcsTUFBTUE7SUFDMUQsT0FBTyxJQUFJLENBQUNHLE1BQU07UUFDZEEsT0FBTztJQUNYLENBQUM7SUFDRCxJQUFJRixRQUFRQSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUtBLE9BQU8sTUFBTUE7SUFDMUMsSUFBSVMsVUFBVUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxTQUFTLE1BQU1BO0lBQ2hEVixXQUFXQSxTQUFTSyxPQUFPLENBQUMsU0FBU0Q7SUFDckNNLFNBQVNBLE9BQU9MLE9BQU8sQ0FBQyxLQUFLO0lBQzdCLE9BQU8sR0FBY0YsT0FBWEosVUFBa0JDLE9BQVBHLE1BQWtCTyxPQUFYVixVQUFvQkMsT0FBVFMsUUFBYyxPQUFMVDtBQUNwRDtBQUNBLE1BQU1YLGdCQUFnQjtJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNESixxQkFBcUIsR0FBR0k7QUFDeEIsU0FBU0QscUJBQXFCeUIsR0FBRyxFQUFFO0lBQy9CLElBQUlDLElBQXlCLEVBQWU7UUFDeEMsSUFBSUQsUUFBUSxJQUFJLElBQUksT0FBT0EsUUFBUSxVQUFVO1lBQ3pDOUIsT0FBT2dDLElBQUksQ0FBQ0YsS0FBS0csT0FBTyxDQUFDLENBQUNDLE1BQU07Z0JBQzVCLElBQUk1QixjQUFjZ0IsT0FBTyxDQUFDWSxTQUFTLENBQUMsR0FBRztvQkFDbkNDLFFBQVFDLElBQUksQ0FBQyxxREFBeUQsT0FBSkY7Z0JBQ3RFLENBQUM7WUFDTDtRQUNKLENBQUM7SUFDTCxDQUFDO0lBQ0QsT0FBTzlCLFVBQVUwQjtBQUNyQixFQUVBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanM/N2I1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZm9ybWF0VXJsID0gZm9ybWF0VXJsO1xuZXhwb3J0cy5mb3JtYXRXaXRoVmFsaWRhdGlvbiA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uO1xuZXhwb3J0cy51cmxPYmplY3RLZXlzID0gdm9pZCAwO1xudmFyIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLmpzXCIpLmRlZmF1bHQ7XG52YXIgcXVlcnlzdHJpbmcgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCIuL3F1ZXJ5c3RyaW5nXCIpKTtcbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87XG5mdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqKSB7XG4gICAgbGV0IHsgYXV0aCAsIGhvc3RuYW1lICB9ID0gdXJsT2JqO1xuICAgIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJztcbiAgICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJyc7XG4gICAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJztcbiAgICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJyc7XG4gICAgbGV0IGhvc3QgPSBmYWxzZTtcbiAgICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnO1xuICAgIGlmICh1cmxPYmouaG9zdCkge1xuICAgICAgICBob3N0ID0gYXV0aCArIHVybE9iai5ob3N0O1xuICAgIH0gZWxzZSBpZiAoaG9zdG5hbWUpIHtcbiAgICAgICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKTtcbiAgICAgICAgaWYgKHVybE9iai5wb3J0KSB7XG4gICAgICAgICAgICBob3N0ICs9ICc6JyArIHVybE9iai5wb3J0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkpKTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgcXVlcnkgJiYgYD8ke3F1ZXJ5fWAgfHwgJyc7XG4gICAgaWYgKHByb3RvY29sICYmICFwcm90b2NvbC5lbmRzV2l0aCgnOicpKSBwcm90b2NvbCArPSAnOic7XG4gICAgaWYgKHVybE9iai5zbGFzaGVzIHx8ICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICAgICAgaG9zdCA9ICcnO1xuICAgIH1cbiAgICBpZiAoaGFzaCAmJiBoYXNoWzBdICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICAgIGlmIChzZWFyY2ggJiYgc2VhcmNoWzBdICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWA7XG59XG5jb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAgICdhdXRoJyxcbiAgICAnaGFzaCcsXG4gICAgJ2hvc3QnLFxuICAgICdob3N0bmFtZScsXG4gICAgJ2hyZWYnLFxuICAgICdwYXRoJyxcbiAgICAncGF0aG5hbWUnLFxuICAgICdwb3J0JyxcbiAgICAncHJvdG9jb2wnLFxuICAgICdxdWVyeScsXG4gICAgJ3NlYXJjaCcsXG4gICAgJ3NsYXNoZXMnLCBcbl07XG5leHBvcnRzLnVybE9iamVjdEtleXMgPSB1cmxPYmplY3RLZXlzO1xuZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24odXJsKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRVcmwodXJsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0LXVybC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmb3JtYXRVcmwiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybE9iamVjdEtleXMiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsImRlZmF1bHQiLCJxdWVyeXN0cmluZyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJzZWFyY2giLCJlbmRzV2l0aCIsInNsYXNoZXMiLCJ0ZXN0IiwidXJsIiwicHJvY2VzcyIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js ***!
  \*************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = getAssetPathFromRoute;\nfunction getAssetPathFromRoute(route) {\n    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\";\n    const path = route === \"/\" ? \"/index\" : /^\\/index(\\/|$)/.test(route) ? \"/index\".concat(route) : \"\".concat(route);\n    return path + ext;\n} //# sourceMappingURL=get-asset-path-from-route.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsa0JBQWUsR0FBR0c7QUFDbEIsU0FBU0Esc0JBQXNCQyxLQUFLLEVBQVk7UUFBVkMsTUFBQUEsaUVBQU0sRUFBRTtJQUMxQyxNQUFNQyxPQUFPRixVQUFVLE1BQU0sV0FBVyxpQkFBaUJHLElBQUksQ0FBQ0gsU0FBUyxTQUFlLE9BQU5BLFNBQVUsR0FBUyxPQUFOQSxNQUFPO0lBQ3BHLE9BQU9FLE9BQU9EO0FBQ2xCLEVBRUEscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZS5qcz9hNmZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QXNzZXRQYXRoRnJvbVJvdXRlO1xuZnVuY3Rpb24gZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKHJvdXRlLCBleHQgPSAnJykge1xuICAgIGNvbnN0IHBhdGggPSByb3V0ZSA9PT0gJy8nID8gJy9pbmRleCcgOiAvXlxcL2luZGV4KFxcL3wkKS8udGVzdChyb3V0ZSkgPyBgL2luZGV4JHtyb3V0ZX1gIDogYCR7cm91dGV9YDtcbiAgICByZXR1cm4gcGF0aCArIGV4dDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwicm91dGUiLCJleHQiLCJwYXRoIiwidGVzdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getNextPathnameInfo = getNextPathnameInfo;\nvar _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _removePathPrefix = __webpack_require__(/*! ./remove-path-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\");\nvar _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction getNextPathnameInfo(pathname, options) {\n    var _nextConfig;\n    const { basePath , i18n , trailingSlash  } = (_nextConfig = options.nextConfig) != null ? _nextConfig : {};\n    const info = {\n        pathname: pathname,\n        trailingSlash: pathname !== \"/\" ? pathname.endsWith(\"/\") : trailingSlash\n    };\n    if (basePath && (0, _pathHasPrefix).pathHasPrefix(info.pathname, basePath)) {\n        info.pathname = (0, _removePathPrefix).removePathPrefix(info.pathname, basePath);\n        info.basePath = basePath;\n    }\n    if (options.parseData === true && info.pathname.startsWith(\"/_next/data/\") && info.pathname.endsWith(\".json\")) {\n        const paths = info.pathname.replace(/^\\/_next\\/data\\//, \"\").replace(/\\.json$/, \"\").split(\"/\");\n        const buildId = paths[0];\n        info.pathname = paths[1] !== \"index\" ? \"/\".concat(paths.slice(1).join(\"/\")) : \"/\";\n        info.buildId = buildId;\n    }\n    if (i18n) {\n        const pathLocale = (0, _normalizeLocalePath).normalizeLocalePath(info.pathname, i18n.locales);\n        info.locale = pathLocale == null ? void 0 : pathLocale.detectedLocale;\n        info.pathname = (pathLocale == null ? void 0 : pathLocale.pathname) || info.pathname;\n    }\n    return info;\n} //# sourceMappingURL=get-next-pathname-info.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm8uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsMkJBQTJCLEdBQUdFO0FBQzlCLElBQUlDLHVCQUF1QkMsbUJBQU9BLENBQUMsMkdBQWtDO0FBQ3JFLElBQUlDLG9CQUFvQkQsbUJBQU9BLENBQUMsb0dBQXNCO0FBQ3RELElBQUlFLGlCQUFpQkYsbUJBQU9BLENBQUMsOEZBQW1CO0FBQ2hELFNBQVNGLG9CQUFvQkssUUFBUSxFQUFFQyxPQUFPLEVBQUU7SUFDNUMsSUFBSUM7SUFDSixNQUFNLEVBQUVDLFNBQVEsRUFBR0MsS0FBSSxFQUFHQyxjQUFhLEVBQUcsR0FBRyxDQUFDSCxjQUFjRCxRQUFRSyxVQUFVLEtBQUssSUFBSSxHQUFHSixjQUFjLENBQUMsQ0FBQztJQUMxRyxNQUFNSyxPQUFPO1FBQ1RQLFVBQVVBO1FBQ1ZLLGVBQWVMLGFBQWEsTUFBTUEsU0FBU1EsUUFBUSxDQUFDLE9BQU9ILGFBQWE7SUFDNUU7SUFDQSxJQUFJRixZQUFZLENBQUMsR0FBR0osY0FBYyxFQUFFVSxhQUFhLENBQUNGLEtBQUtQLFFBQVEsRUFBRUcsV0FBVztRQUN4RUksS0FBS1AsUUFBUSxHQUFHLENBQUMsR0FBR0YsaUJBQWlCLEVBQUVZLGdCQUFnQixDQUFDSCxLQUFLUCxRQUFRLEVBQUVHO1FBQ3ZFSSxLQUFLSixRQUFRLEdBQUdBO0lBQ3BCLENBQUM7SUFDRCxJQUFJRixRQUFRVSxTQUFTLEtBQUssSUFBSSxJQUFJSixLQUFLUCxRQUFRLENBQUNZLFVBQVUsQ0FBQyxtQkFBbUJMLEtBQUtQLFFBQVEsQ0FBQ1EsUUFBUSxDQUFDLFVBQVU7UUFDM0csTUFBTUssUUFBUU4sS0FBS1AsUUFBUSxDQUFDYyxPQUFPLENBQUMsb0JBQW9CLElBQUlBLE9BQU8sQ0FBQyxXQUFXLElBQUlDLEtBQUssQ0FBQztRQUN6RixNQUFNQyxVQUFVSCxLQUFLLENBQUMsRUFBRTtRQUN4Qk4sS0FBS1AsUUFBUSxHQUFHYSxLQUFLLENBQUMsRUFBRSxLQUFLLFVBQVUsSUFBNkIsT0FBekJBLE1BQU1JLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUMsUUFBUyxHQUFHO1FBQzNFWCxLQUFLUyxPQUFPLEdBQUdBO0lBQ25CLENBQUM7SUFDRCxJQUFJWixNQUFNO1FBQ04sTUFBTWUsYUFBYSxDQUFDLEdBQUd2QixvQkFBb0IsRUFBRXdCLG1CQUFtQixDQUFDYixLQUFLUCxRQUFRLEVBQUVJLEtBQUtpQixPQUFPO1FBQzVGZCxLQUFLZSxNQUFNLEdBQUdILGNBQWMsSUFBSSxHQUFHLEtBQUssSUFBSUEsV0FBV0ksY0FBYztRQUNyRWhCLEtBQUtQLFFBQVEsR0FBRyxDQUFDbUIsY0FBYyxJQUFJLEdBQUcsS0FBSyxJQUFJQSxXQUFXbkIsUUFBUSxLQUFLTyxLQUFLUCxRQUFRO0lBQ3hGLENBQUM7SUFDRCxPQUFPTztBQUNYLEVBRUEsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mby5qcz8wZDI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXROZXh0UGF0aG5hbWVJbmZvID0gZ2V0TmV4dFBhdGhuYW1lSW5mbztcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfcmVtb3ZlUGF0aFByZWZpeCA9IHJlcXVpcmUoXCIuL3JlbW92ZS1wYXRoLXByZWZpeFwiKTtcbnZhciBfcGF0aEhhc1ByZWZpeCA9IHJlcXVpcmUoXCIuL3BhdGgtaGFzLXByZWZpeFwiKTtcbmZ1bmN0aW9uIGdldE5leHRQYXRobmFtZUluZm8ocGF0aG5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX25leHRDb25maWc7XG4gICAgY29uc3QgeyBiYXNlUGF0aCAsIGkxOG4gLCB0cmFpbGluZ1NsYXNoICB9ID0gKF9uZXh0Q29uZmlnID0gb3B0aW9ucy5uZXh0Q29uZmlnKSAhPSBudWxsID8gX25leHRDb25maWcgOiB7fTtcbiAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgIHRyYWlsaW5nU2xhc2g6IHBhdGhuYW1lICE9PSAnLycgPyBwYXRobmFtZS5lbmRzV2l0aCgnLycpIDogdHJhaWxpbmdTbGFzaFxuICAgIH07XG4gICAgaWYgKGJhc2VQYXRoICYmICgwLCBfcGF0aEhhc1ByZWZpeCkucGF0aEhhc1ByZWZpeChpbmZvLnBhdGhuYW1lLCBiYXNlUGF0aCkpIHtcbiAgICAgICAgaW5mby5wYXRobmFtZSA9ICgwLCBfcmVtb3ZlUGF0aFByZWZpeCkucmVtb3ZlUGF0aFByZWZpeChpbmZvLnBhdGhuYW1lLCBiYXNlUGF0aCk7XG4gICAgICAgIGluZm8uYmFzZVBhdGggPSBiYXNlUGF0aDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucGFyc2VEYXRhID09PSB0cnVlICYmIGluZm8ucGF0aG5hbWUuc3RhcnRzV2l0aCgnL19uZXh0L2RhdGEvJykgJiYgaW5mby5wYXRobmFtZS5lbmRzV2l0aCgnLmpzb24nKSkge1xuICAgICAgICBjb25zdCBwYXRocyA9IGluZm8ucGF0aG5hbWUucmVwbGFjZSgvXlxcL19uZXh0XFwvZGF0YVxcLy8sICcnKS5yZXBsYWNlKC9cXC5qc29uJC8sICcnKS5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCBidWlsZElkID0gcGF0aHNbMF07XG4gICAgICAgIGluZm8ucGF0aG5hbWUgPSBwYXRoc1sxXSAhPT0gJ2luZGV4JyA/IGAvJHtwYXRocy5zbGljZSgxKS5qb2luKCcvJyl9YCA6ICcvJztcbiAgICAgICAgaW5mby5idWlsZElkID0gYnVpbGRJZDtcbiAgICB9XG4gICAgaWYgKGkxOG4pIHtcbiAgICAgICAgY29uc3QgcGF0aExvY2FsZSA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChpbmZvLnBhdGhuYW1lLCBpMThuLmxvY2FsZXMpO1xuICAgICAgICBpbmZvLmxvY2FsZSA9IHBhdGhMb2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBhdGhMb2NhbGUuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGluZm8ucGF0aG5hbWUgPSAocGF0aExvY2FsZSA9PSBudWxsID8gdm9pZCAwIDogcGF0aExvY2FsZS5wYXRobmFtZSkgfHwgaW5mby5wYXRobmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1uZXh0LXBhdGhuYW1lLWluZm8uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsIl9ub3JtYWxpemVMb2NhbGVQYXRoIiwicmVxdWlyZSIsIl9yZW1vdmVQYXRoUHJlZml4IiwiX3BhdGhIYXNQcmVmaXgiLCJwYXRobmFtZSIsIm9wdGlvbnMiLCJfbmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsInRyYWlsaW5nU2xhc2giLCJuZXh0Q29uZmlnIiwiaW5mbyIsImVuZHNXaXRoIiwicGF0aEhhc1ByZWZpeCIsInJlbW92ZVBhdGhQcmVmaXgiLCJwYXJzZURhdGEiLCJzdGFydHNXaXRoIiwicGF0aHMiLCJyZXBsYWNlIiwic3BsaXQiLCJidWlsZElkIiwic2xpY2UiLCJqb2luIiwicGF0aExvY2FsZSIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJsb2NhbGVzIiwibG9jYWxlIiwiZGV0ZWN0ZWRMb2NhbGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/index.js ***!
  \*****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getSortedRoutes\", ({\n    enumerable: true,\n    get: function() {\n        return _sortedRoutes.getSortedRoutes;\n    }\n}));\nObject.defineProperty(exports, \"isDynamicRoute\", ({\n    enumerable: true,\n    get: function() {\n        return _isDynamic.isDynamicRoute;\n    }\n}));\nvar _sortedRoutes = __webpack_require__(/*! ./sorted-routes */ \"./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\");\nvar _isDynamic = __webpack_require__(/*! ./is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\"); //# sourceMappingURL=index.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPQyxjQUFjQyxlQUFlO0lBQ3hDO0FBQ0osQ0FBQyxFQUFDO0FBQ0ZQLGtEQUFpRDtJQUM3Q0ksWUFBWSxJQUFJO0lBQ2hCQyxLQUFLLFdBQVc7UUFDWixPQUFPRyxXQUFXQyxjQUFjO0lBQ3BDO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsSUFBSUgsZ0JBQWdCSSxtQkFBT0EsQ0FBQywwRkFBaUI7QUFDN0MsSUFBSUYsYUFBYUUsbUJBQU9BLENBQUMsb0ZBQWMsR0FFdkMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaW5kZXguanM/ZjUyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFNvcnRlZFJvdXRlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NvcnRlZFJvdXRlcy5nZXRTb3J0ZWRSb3V0ZXM7XG4gICAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0R5bmFtaWNSb3V0ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2lzRHluYW1pYy5pc0R5bmFtaWNSb3V0ZTtcbiAgICB9XG59KTtcbnZhciBfc29ydGVkUm91dGVzID0gcmVxdWlyZShcIi4vc29ydGVkLXJvdXRlc1wiKTtcbnZhciBfaXNEeW5hbWljID0gcmVxdWlyZShcIi4vaXMtZHluYW1pY1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIl9zb3J0ZWRSb3V0ZXMiLCJnZXRTb3J0ZWRSb3V0ZXMiLCJfaXNEeW5hbWljIiwiaXNEeW5hbWljUm91dGUiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/is-bot.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-bot.js ***!
  \******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isBot = isBot;\nfunction isBot(userAgent) {\n    return /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i.test(userAgent);\n} //# sourceMappingURL=is-bot.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxhQUFhLEdBQUdFO0FBQ2hCLFNBQVNBLE1BQU1DLFNBQVMsRUFBRTtJQUN0QixPQUFPLG9WQUFvVkMsSUFBSSxDQUFDRDtBQUNwVyxFQUVBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWJvdC5qcz8wNzE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0JvdCA9IGlzQm90O1xuZnVuY3Rpb24gaXNCb3QodXNlckFnZW50KSB7XG4gICAgcmV0dXJuIC9Hb29nbGVib3R8TWVkaWFwYXJ0bmVycy1Hb29nbGV8QWRzQm90LUdvb2dsZXxnb29nbGV3ZWJsaWdodHxTdG9yZWJvdC1Hb29nbGV8R29vZ2xlLVBhZ2VSZW5kZXJlcnxCaW5nYm90fEJpbmdQcmV2aWV3fFNsdXJwfER1Y2tEdWNrQm90fGJhaWR1c3BpZGVyfHlhbmRleHxzb2dvdXxMaW5rZWRJbkJvdHxiaXRseWJvdHx0dW1ibHJ8dmtTaGFyZXxxdW9yYSBsaW5rIHByZXZpZXd8ZmFjZWJvb2tleHRlcm5hbGhpdHxmYWNlYm9va2NhdGFsb2d8VHdpdHRlcmJvdHxhcHBsZWJvdHxyZWRkaXRib3R8U2xhY2tib3R8RGlzY29yZGJvdHxXaGF0c0FwcHxTa3lwZVVyaVByZXZpZXd8aWFfYXJjaGl2ZXIvaS50ZXN0KHVzZXJBZ2VudCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLWJvdC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0JvdCIsInVzZXJBZ2VudCIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/is-bot.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDynamicRoute = isDynamicRoute;\n// Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n    return TEST_ROUTE.test(route);\n} //# sourceMappingURL=is-dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsc0JBQXNCLEdBQUdFO0FBQ3pCLHFDQUFxQztBQUNyQyxNQUFNQyxhQUFhO0FBQ25CLFNBQVNELGVBQWVFLEtBQUssRUFBRTtJQUMzQixPQUFPRCxXQUFXRSxJQUFJLENBQUNEO0FBQzNCLEVBRUEsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy5qcz80NmY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0R5bmFtaWNSb3V0ZSA9IGlzRHluYW1pY1JvdXRlO1xuLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvO1xuZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGUpIHtcbiAgICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZHluYW1pYy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0R5bmFtaWNSb3V0ZSIsIlRFU1RfUk9VVEUiLCJyb3V0ZSIsInRlc3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/parse-path.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-path.js ***!
  \**********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parsePath = parsePath;\nfunction parsePath(path) {\n    const hashIndex = path.indexOf(\"#\");\n    const queryIndex = path.indexOf(\"?\");\n    const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);\n    if (hasQuery || hashIndex > -1) {\n        return {\n            pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),\n            query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : undefined) : \"\",\n            hash: hashIndex > -1 ? path.slice(hashIndex) : \"\"\n        };\n    }\n    return {\n        pathname: path,\n        query: \"\",\n        hash: \"\"\n    };\n} //# sourceMappingURL=parse-path.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXBhdGguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCLFNBQVNBLFVBQVVDLElBQUksRUFBRTtJQUNyQixNQUFNQyxZQUFZRCxLQUFLRSxPQUFPLENBQUM7SUFDL0IsTUFBTUMsYUFBYUgsS0FBS0UsT0FBTyxDQUFDO0lBQ2hDLE1BQU1FLFdBQVdELGFBQWEsQ0FBQyxLQUFNRixDQUFBQSxZQUFZLEtBQUtFLGFBQWFGLFNBQVE7SUFDM0UsSUFBSUcsWUFBWUgsWUFBWSxDQUFDLEdBQUc7UUFDNUIsT0FBTztZQUNISSxVQUFVTCxLQUFLTSxTQUFTLENBQUMsR0FBR0YsV0FBV0QsYUFBYUYsU0FBUztZQUM3RE0sT0FBT0gsV0FBV0osS0FBS00sU0FBUyxDQUFDSCxZQUFZRixZQUFZLENBQUMsSUFBSUEsWUFBWU8sU0FBUyxJQUFJLEVBQUU7WUFDekZDLE1BQU1SLFlBQVksQ0FBQyxJQUFJRCxLQUFLVSxLQUFLLENBQUNULGFBQWEsRUFBRTtRQUNyRDtJQUNKLENBQUM7SUFDRCxPQUFPO1FBQ0hJLFVBQVVMO1FBQ1ZPLE9BQU87UUFDUEUsTUFBTTtJQUNWO0FBQ0osRUFFQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1wYXRoLmpzP2U1MmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnBhcnNlUGF0aCA9IHBhcnNlUGF0aDtcbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgY29uc3QgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICAgIGNvbnN0IGhhc1F1ZXJ5ID0gcXVlcnlJbmRleCA+IC0xICYmIChoYXNoSW5kZXggPCAwIHx8IHF1ZXJ5SW5kZXggPCBoYXNoSW5kZXgpO1xuICAgIGlmIChoYXNRdWVyeSB8fCBoYXNoSW5kZXggPiAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aG5hbWU6IHBhdGguc3Vic3RyaW5nKDAsIGhhc1F1ZXJ5ID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleCksXG4gICAgICAgICAgICBxdWVyeTogaGFzUXVlcnkgPyBwYXRoLnN1YnN0cmluZyhxdWVyeUluZGV4LCBoYXNoSW5kZXggPiAtMSA/IGhhc2hJbmRleCA6IHVuZGVmaW5lZCkgOiAnJyxcbiAgICAgICAgICAgIGhhc2g6IGhhc2hJbmRleCA+IC0xID8gcGF0aC5zbGljZShoYXNoSW5kZXgpIDogJydcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHBhdGgsXG4gICAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgICAgaGFzaDogJydcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS1wYXRoLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlUGF0aCIsInBhdGgiLCJoYXNoSW5kZXgiLCJpbmRleE9mIiwicXVlcnlJbmRleCIsImhhc1F1ZXJ5IiwicGF0aG5hbWUiLCJzdWJzdHJpbmciLCJxdWVyeSIsInVuZGVmaW5lZCIsImhhc2giLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/parse-path.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.parseRelativeUrl = parseRelativeUrl;\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nfunction parseRelativeUrl(url, base) {\n    const globalBase = new URL( false ? 0 : (0, _utils).getLocationOrigin());\n    const resolvedBase = base ? new URL(base, globalBase) : url.startsWith(\".\") ? new URL( false ? 0 : window.location.href) : globalBase;\n    const { pathname , searchParams , search , hash , href , origin  } = new URL(url, resolvedBase);\n    if (origin !== globalBase.origin) {\n        throw new Error(\"invariant: invalid relative URL, router received \".concat(url));\n    }\n    return {\n        pathname,\n        query: (0, _querystring).searchParamsToUrlQuery(searchParams),\n        search,\n        hash,\n        href: href.slice(globalBase.origin.length)\n    };\n} //# sourceMappingURL=parse-relative-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx3QkFBd0IsR0FBR0U7QUFDM0IsSUFBSUMsU0FBU0MsbUJBQU9BLENBQUMsaUVBQWE7QUFDbEMsSUFBSUMsZUFBZUQsbUJBQU9BLENBQUMsc0ZBQWU7QUFDMUMsU0FBU0YsaUJBQWlCSSxHQUFHLEVBQUVDLElBQUksRUFBRTtJQUNqQyxNQUFNQyxhQUFhLElBQUlDLElBQUksTUFBa0IsR0FBYyxJQUFhLENBQUMsR0FBR04sTUFBTSxFQUFFTyxpQkFBaUIsRUFBRTtJQUN2RyxNQUFNQyxlQUFlSixPQUFPLElBQUlFLElBQUlGLE1BQU1DLGNBQWNGLElBQUlNLFVBQVUsQ0FBQyxPQUFPLElBQUlILElBQUksTUFBa0IsR0FBYyxJQUFhSSxPQUFPQyxRQUFRLENBQUNDLElBQUksSUFBSVAsVUFBVTtJQUNySyxNQUFNLEVBQUVRLFNBQVEsRUFBR0MsYUFBWSxFQUFHQyxPQUFNLEVBQUdDLEtBQUksRUFBR0osS0FBSSxFQUFHSyxPQUFNLEVBQUcsR0FBRyxJQUFJWCxJQUFJSCxLQUFLSztJQUNsRixJQUFJUyxXQUFXWixXQUFXWSxNQUFNLEVBQUU7UUFDOUIsTUFBTSxJQUFJQyxNQUFNLG9EQUF3RCxPQUFKZixNQUFPO0lBQy9FLENBQUM7SUFDRCxPQUFPO1FBQ0hVO1FBQ0FNLE9BQU8sQ0FBQyxHQUFHakIsWUFBWSxFQUFFa0Isc0JBQXNCLENBQUNOO1FBQ2hEQztRQUNBQztRQUNBSixNQUFNQSxLQUFLUyxLQUFLLENBQUNoQixXQUFXWSxNQUFNLENBQUNLLE1BQU07SUFDN0M7QUFDSixFQUVBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybC5qcz80ZWRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXJzZVJlbGF0aXZlVXJsID0gcGFyc2VSZWxhdGl2ZVVybDtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG52YXIgX3F1ZXJ5c3RyaW5nID0gcmVxdWlyZShcIi4vcXVlcnlzdHJpbmdcIik7XG5mdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybCwgYmFzZSkge1xuICAgIGNvbnN0IGdsb2JhbEJhc2UgPSBuZXcgVVJMKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6ICgwLCBfdXRpbHMpLmdldExvY2F0aW9uT3JpZ2luKCkpO1xuICAgIGNvbnN0IHJlc29sdmVkQmFzZSA9IGJhc2UgPyBuZXcgVVJMKGJhc2UsIGdsb2JhbEJhc2UpIDogdXJsLnN0YXJ0c1dpdGgoJy4nKSA/IG5ldyBVUkwodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogd2luZG93LmxvY2F0aW9uLmhyZWYpIDogZ2xvYmFsQmFzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lICwgc2VhcmNoUGFyYW1zICwgc2VhcmNoICwgaGFzaCAsIGhyZWYgLCBvcmlnaW4gIH0gPSBuZXcgVVJMKHVybCwgcmVzb2x2ZWRCYXNlKTtcbiAgICBpZiAob3JpZ2luICE9PSBnbG9iYWxCYXNlLm9yaWdpbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwsIHJvdXRlciByZWNlaXZlZCAke3VybH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5OiAoMCwgX3F1ZXJ5c3RyaW5nKS5zZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaHJlZjogaHJlZi5zbGljZShnbG9iYWxCYXNlLm9yaWdpbi5sZW5ndGgpXG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtcmVsYXRpdmUtdXJsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhcnNlUmVsYXRpdmVVcmwiLCJfdXRpbHMiLCJyZXF1aXJlIiwiX3F1ZXJ5c3RyaW5nIiwidXJsIiwiYmFzZSIsImdsb2JhbEJhc2UiLCJVUkwiLCJnZXRMb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkQmFzZSIsInN0YXJ0c1dpdGgiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJwYXRobmFtZSIsInNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImhhc2giLCJvcmlnaW4iLCJFcnJvciIsInF1ZXJ5Iiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInNsaWNlIiwibGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.pathHasPrefix = pathHasPrefix;\nvar _parsePath = __webpack_require__(/*! ./parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nfunction pathHasPrefix(path, prefix) {\n    if (typeof path !== \"string\") {\n        return false;\n    }\n    const { pathname  } = (0, _parsePath).parsePath(path);\n    return pathname === prefix || pathname.startsWith(prefix + \"/\");\n} //# sourceMappingURL=path-has-prefix.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCxxQkFBcUIsR0FBR0U7QUFDeEIsSUFBSUMsYUFBYUMsbUJBQU9BLENBQUMsb0ZBQWM7QUFDdkMsU0FBU0YsY0FBY0csSUFBSSxFQUFFQyxNQUFNLEVBQUU7SUFDakMsSUFBSSxPQUFPRCxTQUFTLFVBQVU7UUFDMUIsT0FBTyxLQUFLO0lBQ2hCLENBQUM7SUFDRCxNQUFNLEVBQUVFLFNBQVEsRUFBRyxHQUFHLENBQUMsR0FBR0osVUFBVSxFQUFFSyxTQUFTLENBQUNIO0lBQ2hELE9BQU9FLGFBQWFELFVBQVVDLFNBQVNFLFVBQVUsQ0FBQ0gsU0FBUztBQUMvRCxFQUVBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhdGgtaGFzLXByZWZpeC5qcz9iNTM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5wYXRoSGFzUHJlZml4ID0gcGF0aEhhc1ByZWZpeDtcbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZShcIi4vcGFyc2UtcGF0aFwiKTtcbmZ1bmN0aW9uIHBhdGhIYXNQcmVmaXgocGF0aCwgcHJlZml4KSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHsgcGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHBhdGgpO1xuICAgIHJldHVybiBwYXRobmFtZSA9PT0gcHJlZml4IHx8IHBhdGhuYW1lLnN0YXJ0c1dpdGgocHJlZml4ICsgJy8nKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC1oYXMtcHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInBhdGhIYXNQcmVmaXgiLCJfcGFyc2VQYXRoIiwicmVxdWlyZSIsInBhdGgiLCJwcmVmaXgiLCJwYXRobmFtZSIsInBhcnNlUGF0aCIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/querystring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/querystring.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.searchParamsToUrlQuery = searchParamsToUrlQuery;\nexports.urlQueryToSearchParams = urlQueryToSearchParams;\nexports.assign = assign;\nfunction searchParamsToUrlQuery(searchParams) {\n    const query = {};\n    searchParams.forEach((value, key)=>{\n        if (typeof query[key] === \"undefined\") {\n            query[key] = value;\n        } else if (Array.isArray(query[key])) {\n            query[key].push(value);\n        } else {\n            query[key] = [\n                query[key],\n                value\n            ];\n        }\n    });\n    return query;\n}\nfunction stringifyUrlQueryParam(param) {\n    if (typeof param === \"string\" || typeof param === \"number\" && !isNaN(param) || typeof param === \"boolean\") {\n        return String(param);\n    } else {\n        return \"\";\n    }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n    const result = new URLSearchParams();\n    Object.entries(urlQuery).forEach((param)=>{\n        let [key, value] = param;\n        if (Array.isArray(value)) {\n            value.forEach((item)=>result.append(key, stringifyUrlQueryParam(item)));\n        } else {\n            result.set(key, stringifyUrlQueryParam(value));\n        }\n    });\n    return result;\n}\nfunction assign(target) {\n    for(var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        searchParamsList[_key - 1] = arguments[_key];\n    }\n    searchParamsList.forEach((searchParams)=>{\n        Array.from(searchParams.keys()).forEach((key)=>target.delete(key));\n        searchParams.forEach((value, key)=>target.append(key, value));\n    });\n    return target;\n} //# sourceMappingURL=querystring.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELDhCQUE4QixHQUFHRTtBQUNqQ0YsOEJBQThCLEdBQUdHO0FBQ2pDSCxjQUFjLEdBQUdJO0FBQ2pCLFNBQVNGLHVCQUF1QkcsWUFBWSxFQUFFO0lBQzFDLE1BQU1DLFFBQVEsQ0FBQztJQUNmRCxhQUFhRSxPQUFPLENBQUMsQ0FBQ04sT0FBT08sTUFBTTtRQUMvQixJQUFJLE9BQU9GLEtBQUssQ0FBQ0UsSUFBSSxLQUFLLGFBQWE7WUFDbkNGLEtBQUssQ0FBQ0UsSUFBSSxHQUFHUDtRQUNqQixPQUFPLElBQUlRLE1BQU1DLE9BQU8sQ0FBQ0osS0FBSyxDQUFDRSxJQUFJLEdBQUc7WUFDbENGLEtBQUssQ0FBQ0UsSUFBSSxDQUFDRyxJQUFJLENBQUNWO1FBQ3BCLE9BQU87WUFDSEssS0FBSyxDQUFDRSxJQUFJLEdBQUc7Z0JBQ1RGLEtBQUssQ0FBQ0UsSUFBSTtnQkFDVlA7YUFDSDtRQUNMLENBQUM7SUFDTDtJQUNBLE9BQU9LO0FBQ1g7QUFDQSxTQUFTTSx1QkFBdUJDLEtBQUssRUFBRTtJQUNuQyxJQUFJLE9BQU9BLFVBQVUsWUFBWSxPQUFPQSxVQUFVLFlBQVksQ0FBQ0MsTUFBTUQsVUFBVSxPQUFPQSxVQUFVLFdBQVc7UUFDdkcsT0FBT0UsT0FBT0Y7SUFDbEIsT0FBTztRQUNILE9BQU87SUFDWCxDQUFDO0FBQ0w7QUFDQSxTQUFTVix1QkFBdUJhLFFBQVEsRUFBRTtJQUN0QyxNQUFNQyxTQUFTLElBQUlDO0lBQ25CcEIsT0FBT3FCLE9BQU8sQ0FBQ0gsVUFBVVQsT0FBTyxDQUFDLFNBQWdCO1lBQWYsQ0FBQ0MsS0FBS1AsTUFBTTtRQUMxQyxJQUFJUSxNQUFNQyxPQUFPLENBQUNULFFBQVE7WUFDdEJBLE1BQU1NLE9BQU8sQ0FBQyxDQUFDYSxPQUFPSCxPQUFPSSxNQUFNLENBQUNiLEtBQUtJLHVCQUF1QlE7UUFDcEUsT0FBTztZQUNISCxPQUFPSyxHQUFHLENBQUNkLEtBQUtJLHVCQUF1Qlg7UUFDM0MsQ0FBQztJQUNMO0lBQ0EsT0FBT2dCO0FBQ1g7QUFDQSxTQUFTYixPQUFPbUIsTUFBTSxFQUF1QjtJQUFyQixxRkFBbUIsR0FBbkI7UUFBR0MsaUJBQUgsMkJBQW1CO0lBQUQ7SUFDdENBLGlCQUFpQmpCLE9BQU8sQ0FBQyxDQUFDRixlQUFlO1FBQ3JDSSxNQUFNZ0IsSUFBSSxDQUFDcEIsYUFBYXFCLElBQUksSUFBSW5CLE9BQU8sQ0FBQyxDQUFDQyxNQUFNZSxPQUFPSSxNQUFNLENBQUNuQjtRQUM3REgsYUFBYUUsT0FBTyxDQUFDLENBQUNOLE9BQU9PLE1BQU1lLE9BQU9GLE1BQU0sQ0FBQ2IsS0FBS1A7SUFDMUQ7SUFDQSxPQUFPc0I7QUFDWCxFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nLmpzPzAxNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5O1xuZXhwb3J0cy51cmxRdWVyeVRvU2VhcmNoUGFyYW1zID0gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcztcbmV4cG9ydHMuYXNzaWduID0gYXNzaWduO1xuZnVuY3Rpb24gc2VhcmNoUGFyYW1zVG9VcmxRdWVyeShzZWFyY2hQYXJhbXMpIHtcbiAgICBjb25zdCBxdWVyeSA9IHt9O1xuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBxdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5W2tleV0gPSBbXG4gICAgICAgICAgICAgICAgcXVlcnlba2V5XSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBxdWVyeTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW0pIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkgfHwgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXModXJsUXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSk9PntcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKT0+cmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgLi4uc2VhcmNoUGFyYW1zTGlzdCkge1xuICAgIHNlYXJjaFBhcmFtc0xpc3QuZm9yRWFjaCgoc2VhcmNoUGFyYW1zKT0+e1xuICAgICAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSk9PnRhcmdldC5kZWxldGUoa2V5KSk7XG4gICAgICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+dGFyZ2V0LmFwcGVuZChrZXksIHZhbHVlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlzdHJpbmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2VhcmNoUGFyYW1zVG9VcmxRdWVyeSIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJhc3NpZ24iLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImZvckVhY2giLCJrZXkiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwic3RyaW5naWZ5VXJsUXVlcnlQYXJhbSIsInBhcmFtIiwiaXNOYU4iLCJTdHJpbmciLCJ1cmxRdWVyeSIsInJlc3VsdCIsIlVSTFNlYXJjaFBhcmFtcyIsImVudHJpZXMiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwidGFyZ2V0Iiwic2VhcmNoUGFyYW1zTGlzdCIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/querystring.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js ***!
  \******************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removePathPrefix = removePathPrefix;\nvar _pathHasPrefix = __webpack_require__(/*! ./path-has-prefix */ \"./node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js\");\nfunction removePathPrefix(path, prefix) {\n    if ((0, _pathHasPrefix).pathHasPrefix(path, prefix)) {\n        const withoutPrefix = path.slice(prefix.length);\n        return withoutPrefix.startsWith(\"/\") ? withoutPrefix : \"/\".concat(withoutPrefix);\n    }\n    return path;\n} //# sourceMappingURL=remove-path-prefix.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS1wYXRoLXByZWZpeC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCx3QkFBd0IsR0FBR0U7QUFDM0IsSUFBSUMsaUJBQWlCQyxtQkFBT0EsQ0FBQyw4RkFBbUI7QUFDaEQsU0FBU0YsaUJBQWlCRyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtJQUNwQyxJQUFJLENBQUMsR0FBR0gsY0FBYyxFQUFFSSxhQUFhLENBQUNGLE1BQU1DLFNBQVM7UUFDakQsTUFBTUUsZ0JBQWdCSCxLQUFLSSxLQUFLLENBQUNILE9BQU9JLE1BQU07UUFDOUMsT0FBT0YsY0FBY0csVUFBVSxDQUFDLE9BQU9ILGdCQUFnQixJQUFrQixPQUFkQSxjQUFlO0lBQzlFLENBQUM7SUFDRCxPQUFPSDtBQUNYLEVBRUEsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVtb3ZlLXBhdGgtcHJlZml4LmpzPzYxNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnJlbW92ZVBhdGhQcmVmaXggPSByZW1vdmVQYXRoUHJlZml4O1xudmFyIF9wYXRoSGFzUHJlZml4ID0gcmVxdWlyZShcIi4vcGF0aC1oYXMtcHJlZml4XCIpO1xuZnVuY3Rpb24gcmVtb3ZlUGF0aFByZWZpeChwYXRoLCBwcmVmaXgpIHtcbiAgICBpZiAoKDAsIF9wYXRoSGFzUHJlZml4KS5wYXRoSGFzUHJlZml4KHBhdGgsIHByZWZpeCkpIHtcbiAgICAgICAgY29uc3Qgd2l0aG91dFByZWZpeCA9IHBhdGguc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB3aXRob3V0UHJlZml4LnN0YXJ0c1dpdGgoJy8nKSA/IHdpdGhvdXRQcmVmaXggOiBgLyR7d2l0aG91dFByZWZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlLXBhdGgtcHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlbW92ZVBhdGhQcmVmaXgiLCJfcGF0aEhhc1ByZWZpeCIsInJlcXVpcmUiLCJwYXRoIiwicHJlZml4IiwicGF0aEhhc1ByZWZpeCIsIndpdGhvdXRQcmVmaXgiLCJzbGljZSIsImxlbmd0aCIsInN0YXJ0c1dpdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js ***!
  \*********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.removeTrailingSlash = removeTrailingSlash;\nfunction removeTrailingSlash(route) {\n    return route.replace(/\\/$/, \"\") || \"/\";\n} //# sourceMappingURL=remove-trailing-slash.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU8sSUFBSTtBQUNmLENBQUMsRUFBQztBQUNGRCwyQkFBMkIsR0FBR0U7QUFDOUIsU0FBU0Esb0JBQW9CQyxLQUFLLEVBQUU7SUFDaEMsT0FBT0EsTUFBTUMsT0FBTyxDQUFDLE9BQU8sT0FBTztBQUN2QyxFQUVBLGlEQUFpRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JlbW92ZS10cmFpbGluZy1zbGFzaC5qcz9lYzA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZW1vdmVUcmFpbGluZ1NsYXNoID0gcmVtb3ZlVHJhaWxpbmdTbGFzaDtcbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2xhc2gocm91dGUpIHtcbiAgICByZXR1cm4gcm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLyc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZS10cmFpbGluZy1zbGFzaC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwicm91dGUiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/route-matcher.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-matcher.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getRouteMatcher = getRouteMatcher;\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nfunction getRouteMatcher(param) {\n    let { re , groups  } = param;\n    return (pathname)=>{\n        const routeMatch = re.exec(pathname);\n        if (!routeMatch) {\n            return false;\n        }\n        const decode = (param)=>{\n            try {\n                return decodeURIComponent(param);\n            } catch (_) {\n                throw new _utils.DecodeError(\"failed to decode param\");\n            }\n        };\n        const params = {};\n        Object.keys(groups).forEach((slugName)=>{\n            const g = groups[slugName];\n            const m = routeMatch[g.pos];\n            if (m !== undefined) {\n                params[slugName] = ~m.indexOf(\"/\") ? m.split(\"/\").map((entry)=>decode(entry)) : g.repeat ? [\n                    decode(m)\n                ] : decode(m);\n            }\n        });\n        return params;\n    };\n} //# sourceMappingURL=route-matcher.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDLGlFQUFhO0FBQ2xDLFNBQVNGLGdCQUFnQixLQUFnQixFQUFFO1FBQWxCLEVBQUVHLEdBQUUsRUFBR0MsT0FBTSxFQUFHLEdBQWhCO0lBQ3JCLE9BQU8sQ0FBQ0MsV0FBVztRQUNmLE1BQU1DLGFBQWFILEdBQUdJLElBQUksQ0FBQ0Y7UUFDM0IsSUFBSSxDQUFDQyxZQUFZO1lBQ2IsT0FBTyxLQUFLO1FBQ2hCLENBQUM7UUFDRCxNQUFNRSxTQUFTLENBQUNDLFFBQVE7WUFDcEIsSUFBSTtnQkFDQSxPQUFPQyxtQkFBbUJEO1lBQzlCLEVBQUUsT0FBT0UsR0FBRztnQkFDUixNQUFNLElBQUlWLE9BQU9XLFdBQVcsQ0FBQywwQkFBMEI7WUFDM0Q7UUFDSjtRQUNBLE1BQU1DLFNBQVMsQ0FBQztRQUNoQmpCLE9BQU9rQixJQUFJLENBQUNWLFFBQVFXLE9BQU8sQ0FBQyxDQUFDQyxXQUFXO1lBQ3BDLE1BQU1DLElBQUliLE1BQU0sQ0FBQ1ksU0FBUztZQUMxQixNQUFNRSxJQUFJWixVQUFVLENBQUNXLEVBQUVFLEdBQUcsQ0FBQztZQUMzQixJQUFJRCxNQUFNRSxXQUFXO2dCQUNqQlAsTUFBTSxDQUFDRyxTQUFTLEdBQUcsQ0FBQ0UsRUFBRUcsT0FBTyxDQUFDLE9BQU9ILEVBQUVJLEtBQUssQ0FBQyxLQUFLQyxHQUFHLENBQUMsQ0FBQ0MsUUFBUWhCLE9BQU9nQixVQUFVUCxFQUFFUSxNQUFNLEdBQUc7b0JBQ3ZGakIsT0FBT1U7aUJBQ1YsR0FBR1YsT0FBT1UsRUFBRTtZQUNqQixDQUFDO1FBQ0w7UUFDQSxPQUFPTDtJQUNYO0FBQ0osRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLmpzP2M4NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFJvdXRlTWF0Y2hlciA9IGdldFJvdXRlTWF0Y2hlcjtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5mdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIoeyByZSAsIGdyb3VwcyAgfSkge1xuICAgIHJldHVybiAocGF0aG5hbWUpPT57XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKT0+e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgX3V0aWxzLkRlY29kZUVycm9yKCdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lKT0+e1xuICAgICAgICAgICAgY29uc3QgZyA9IGdyb3Vwc1tzbHVnTmFtZV07XG4gICAgICAgICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc107XG4gICAgICAgICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKSA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KT0+ZGVjb2RlKGVudHJ5KSkgOiBnLnJlcGVhdCA/IFtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlKG0pXG4gICAgICAgICAgICAgICAgXSA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtbWF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRSb3V0ZU1hdGNoZXIiLCJfdXRpbHMiLCJyZXF1aXJlIiwicmUiLCJncm91cHMiLCJwYXRobmFtZSIsInJvdXRlTWF0Y2giLCJleGVjIiwiZGVjb2RlIiwicGFyYW0iLCJkZWNvZGVVUklDb21wb25lbnQiLCJfIiwiRGVjb2RlRXJyb3IiLCJwYXJhbXMiLCJrZXlzIiwiZm9yRWFjaCIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJ1bmRlZmluZWQiLCJpbmRleE9mIiwic3BsaXQiLCJtYXAiLCJlbnRyeSIsInJlcGVhdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/route-regex.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/route-regex.js ***!
  \***********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getRouteRegex = getRouteRegex;\nexports.getNamedRouteRegex = getNamedRouteRegex;\nexports.getNamedMiddlewareRegex = getNamedMiddlewareRegex;\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _escapeRegexp = __webpack_require__(/*! ../../escape-regexp */ \"./node_modules/next/dist/shared/lib/escape-regexp.js\");\nvar _removeTrailingSlash = __webpack_require__(/*! ./remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ name: 'slug', repeat: true, optional: true }`\n *   - `[foo]` -> `{ name: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ name: 'bar', repeat: false, optional: false }`\n */ function parseParameter(param) {\n    const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith(\"...\");\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split(\"/\");\n    const groups = {};\n    let groupIndex = 1;\n    return {\n        parameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith(\"[\") && segment.endsWith(\"]\")) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                groups[key] = {\n                    pos: groupIndex++,\n                    repeat,\n                    optional\n                };\n                return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n            } else {\n                return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n            }\n        }).join(\"\"),\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const { parameterizedRoute , groups  } = getParametrizedRoute(normalizedRoute);\n    return {\n        re: new RegExp(\"^\".concat(parameterizedRoute, \"(?:/)?$\")),\n        groups: groups\n    };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */ function buildGetSafeRouteKey() {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1;\n    return ()=>{\n        let routeKey = \"\";\n        for(let i = 0; i < routeKeyCharLength; i++){\n            routeKey += String.fromCharCode(routeKeyCharCode);\n            routeKeyCharCode++;\n            if (routeKeyCharCode > 122) {\n                routeKeyCharLength++;\n                routeKeyCharCode = 97;\n            }\n        }\n        return routeKey;\n    };\n}\nfunction getNamedParametrizedRoute(route) {\n    const segments = (0, _removeTrailingSlash).removeTrailingSlash(route).slice(1).split(\"/\");\n    const getSafeRouteKey = buildGetSafeRouteKey();\n    const routeKeys = {};\n    return {\n        namedParameterizedRoute: segments.map((segment)=>{\n            if (segment.startsWith(\"[\") && segment.endsWith(\"]\")) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                // replace any non-word characters since they can break\n                // the named regex\n                let cleanedKey = key.replace(/\\W/g, \"\");\n                let invalidKey = false;\n                // check if the key is still invalid and fallback to using a known\n                // safe key\n                if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                    invalidKey = true;\n                }\n                if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n                    invalidKey = true;\n                }\n                if (invalidKey) {\n                    cleanedKey = getSafeRouteKey();\n                }\n                routeKeys[cleanedKey] = key;\n                return repeat ? optional ? \"(?:/(?<\".concat(cleanedKey, \">.+?))?\") : \"/(?<\".concat(cleanedKey, \">.+?)\") : \"/(?<\".concat(cleanedKey, \">[^/]+?)\");\n            } else {\n                return \"/\".concat((0, _escapeRegexp).escapeStringRegexp(segment));\n            }\n        }).join(\"\"),\n        routeKeys\n    };\n}\nfunction getNamedRouteRegex(normalizedRoute) {\n    const result = getNamedParametrizedRoute(normalizedRoute);\n    return _extends({}, getRouteRegex(normalizedRoute), {\n        namedRegex: \"^\".concat(result.namedParameterizedRoute, \"(?:/)?$\"),\n        routeKeys: result.routeKeys\n    });\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n    const { parameterizedRoute  } = getParametrizedRoute(normalizedRoute);\n    const { catchAll =true  } = options;\n    if (parameterizedRoute === \"/\") {\n        let catchAllRegex = catchAll ? \".*\" : \"\";\n        return {\n            namedRegex: \"^/\".concat(catchAllRegex, \"$\")\n        };\n    }\n    const { namedParameterizedRoute  } = getNamedParametrizedRoute(normalizedRoute);\n    let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n    return {\n        namedRegex: \"^\".concat(namedParameterizedRoute).concat(catchAllGroupedRegex, \"$\")\n    };\n} //# sourceMappingURL=route-regex.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELHFCQUFxQixHQUFHRTtBQUN4QkYsMEJBQTBCLEdBQUdHO0FBQzdCSCwrQkFBK0IsR0FBR0k7QUFDbEMsSUFBSUMsV0FBV0MsbUhBQStDO0FBQzlELElBQUlFLGdCQUFnQkYsbUJBQU9BLENBQUMsaUZBQXFCO0FBQ2pELElBQUlHLHVCQUF1QkgsbUJBQU9BLENBQUMsMEdBQXlCO0FBQzVEOzs7Ozs7Q0FNQyxHQUFHLFNBQVNJLGVBQWVDLEtBQUssRUFBRTtJQUMvQixNQUFNQyxXQUFXRCxNQUFNRSxVQUFVLENBQUMsUUFBUUYsTUFBTUcsUUFBUSxDQUFDO0lBQ3pELElBQUlGLFVBQVU7UUFDVkQsUUFBUUEsTUFBTUksS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUM1QixDQUFDO0lBQ0QsTUFBTUMsU0FBU0wsTUFBTUUsVUFBVSxDQUFDO0lBQ2hDLElBQUlHLFFBQVE7UUFDUkwsUUFBUUEsTUFBTUksS0FBSyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxPQUFPO1FBQ0hFLEtBQUtOO1FBQ0xLO1FBQ0FKO0lBQ0o7QUFDSjtBQUNBLFNBQVNNLHFCQUFxQkMsS0FBSyxFQUFFO0lBQ2pDLE1BQU1DLFdBQVcsQ0FBQyxHQUFHWCxvQkFBb0IsRUFBRVksbUJBQW1CLENBQUNGLE9BQU9KLEtBQUssQ0FBQyxHQUFHTyxLQUFLLENBQUM7SUFDckYsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLElBQUlDLGFBQWE7SUFDakIsT0FBTztRQUNIQyxvQkFBb0JMLFNBQVNNLEdBQUcsQ0FBQyxDQUFDQyxVQUFVO1lBQ3hDLElBQUlBLFFBQVFkLFVBQVUsQ0FBQyxRQUFRYyxRQUFRYixRQUFRLENBQUMsTUFBTTtnQkFDbEQsTUFBTSxFQUFFRyxJQUFHLEVBQUdM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V1EsT0FBT1IsU0FBUztJQUMvQjtBQUNKO0FBQ0EsU0FBU3ZDLHdCQUF3QjJCLGVBQWUsRUFBRXNCLE9BQU8sRUFBRTtJQUN2RCxNQUFNLEVBQUU1QixtQkFBa0IsRUFBRyxHQUFHUCxxQkFBcUJhO0lBQ3JELE1BQU0sRUFBRXVCLFVBQVUsSUFBSSxHQUFHLEdBQUdEO0lBQzVCLElBQUk1Qix1QkFBdUIsS0FBSztRQUM1QixJQUFJOEIsZ0JBQWdCRCxXQUFXLE9BQU8sRUFBRTtRQUN4QyxPQUFPO1lBQ0hGLFlBQVksS0FBbUIsT0FBZEcsZUFBYztRQUNuQztJQUNKLENBQUM7SUFDRCxNQUFNLEVBQUVYLHdCQUF1QixFQUFHLEdBQUdILDBCQUEwQlY7SUFDL0QsSUFBSXlCLHVCQUF1QkYsV0FBVyxlQUFlLEVBQUU7SUFDdkQsT0FBTztRQUNIRixZQUFZLElBQThCSSxPQUExQloseUJBQStDLE9BQXJCWSxzQkFBcUI7SUFDbkU7QUFDSixFQUVBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzP2VhYzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4O1xuZXhwb3J0cy5nZXROYW1lZFJvdXRlUmVnZXggPSBnZXROYW1lZFJvdXRlUmVnZXg7XG5leHBvcnRzLmdldE5hbWVkTWlkZGxld2FyZVJlZ2V4ID0gZ2V0TmFtZWRNaWRkbGV3YXJlUmVnZXg7XG52YXIgX2V4dGVuZHMgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9fZXh0ZW5kcy5qc1wiKS5kZWZhdWx0O1xudmFyIF9lc2NhcGVSZWdleHAgPSByZXF1aXJlKFwiLi4vLi4vZXNjYXBlLXJlZ2V4cFwiKTtcbnZhciBfcmVtb3ZlVHJhaWxpbmdTbGFzaCA9IHJlcXVpcmUoXCIuL3JlbW92ZS10cmFpbGluZy1zbGFzaFwiKTtcbi8qKlxuICogUGFyc2VzIGEgZ2l2ZW4gcGFyYW1ldGVyIGZyb20gYSByb3V0ZSB0byBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY2FuIGJlIHVzZWRcbiAqIHRvIGdlbmVyYXRlIHRoZSBwYXJhbWV0cml6ZWQgcm91dGUuIEV4YW1wbGVzOlxuICogICAtIGBbLi4uc2x1Z11gIC0+IGB7IG5hbWU6ICdzbHVnJywgcmVwZWF0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSB9YFxuICogICAtIGBbZm9vXWAgLT4gYHsgbmFtZTogJ2ZvbycsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiB0cnVlIH1gXG4gKiAgIC0gYGJhcmAgLT4gYHsgbmFtZTogJ2JhcicsIHJlcGVhdDogZmFsc2UsIG9wdGlvbmFsOiBmYWxzZSB9YFxuICovIGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKTtcbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgxLCAtMSk7XG4gICAgfVxuICAgIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpO1xuICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgcGFyYW0gPSBwYXJhbS5zbGljZSgzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiBwYXJhbSxcbiAgICAgICAgcmVwZWF0LFxuICAgICAgICBvcHRpb25hbFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0cml6ZWRSb3V0ZShyb3V0ZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHJvdXRlKS5zbGljZSgxKS5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGdyb3VwcyA9IHt9O1xuICAgIGxldCBncm91cEluZGV4ID0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXJhbWV0ZXJpemVkUm91dGU6IHNlZ21lbnRzLm1hcCgoc2VnbWVudCk9PntcbiAgICAgICAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleSAsIG9wdGlvbmFsICwgcmVwZWF0ICB9ID0gcGFyc2VQYXJhbWV0ZXIoc2VnbWVudC5zbGljZSgxLCAtMSkpO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1trZXldID0ge1xuICAgICAgICAgICAgICAgICAgICBwb3M6IGdyb3VwSW5kZXgrKyxcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknIDogJy8oW14vXSs/KSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgLyR7KDAsIF9lc2NhcGVSZWdleHApLmVzY2FwZVN0cmluZ1JlZ2V4cChzZWdtZW50KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKCcnKSxcbiAgICAgICAgZ3JvdXBzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSB7XG4gICAgY29uc3QgeyBwYXJhbWV0ZXJpemVkUm91dGUgLCBncm91cHMgIH0gPSBnZXRQYXJhbWV0cml6ZWRSb3V0ZShub3JtYWxpemVkUm91dGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgICAgICBncm91cHM6IGdyb3Vwc1xuICAgIH07XG59XG4vKipcbiAqIEJ1aWxkcyBhIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbWluaW1hbCByb3V0ZUtleSB1c2luZyBvbmx5IGEteiBhbmQgbWluaW1hbFxuICogbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKi8gZnVuY3Rpb24gYnVpbGRHZXRTYWZlUm91dGVLZXkoKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5NztcbiAgICBsZXQgcm91dGVLZXlDaGFyTGVuZ3RoID0gMTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgbGV0IHJvdXRlS2V5ID0gJyc7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpO1xuICAgICAgICAgICAgcm91dGVLZXlDaGFyQ29kZSsrO1xuICAgICAgICAgICAgaWYgKHJvdXRlS2V5Q2hhckNvZGUgPiAxMjIpIHtcbiAgICAgICAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrKztcbiAgICAgICAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlS2V5O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKHJvdXRlKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocm91dGUpLnNsaWNlKDEpLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gYnVpbGRHZXRTYWZlUm91dGVLZXkoKTtcbiAgICBjb25zdCByb3V0ZUtleXMgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTogc2VnbWVudHMubWFwKChzZWdtZW50KT0+e1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5ICwgb3B0aW9uYWwgLCByZXBlYXQgIH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSk7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBhbnkgbm9uLXdvcmQgY2hhcmFjdGVycyBzaW5jZSB0aGV5IGNhbiBicmVha1xuICAgICAgICAgICAgICAgIC8vIHRoZSBuYW1lZCByZWdleFxuICAgICAgICAgICAgICAgIGxldCBjbGVhbmVkS2V5ID0ga2V5LnJlcGxhY2UoL1xcVy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUga2V5IGlzIHN0aWxsIGludmFsaWQgYW5kIGZhbGxiYWNrIHRvIHVzaW5nIGEga25vd25cbiAgICAgICAgICAgICAgICAvLyBzYWZlIGtleVxuICAgICAgICAgICAgICAgIGlmIChjbGVhbmVkS2V5Lmxlbmd0aCA9PT0gMCB8fCBjbGVhbmVkS2V5Lmxlbmd0aCA+IDMwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlSW50KGNsZWFuZWRLZXkuc2xpY2UoMCwgMSkpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGVhdCA/IG9wdGlvbmFsID8gYCg/Oi8oPzwke2NsZWFuZWRLZXl9Pi4rPykpP2AgOiBgLyg/PCR7Y2xlYW5lZEtleX0+Lis/KWAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+W14vXSs/KWA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBgLyR7KDAsIF9lc2NhcGVSZWdleHApLmVzY2FwZVN0cmluZ1JlZ2V4cChzZWdtZW50KX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKCcnKSxcbiAgICAgICAgcm91dGVLZXlzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE5hbWVkUm91dGVSZWdleChub3JtYWxpemVkUm91dGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBnZXRSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZSksIHtcbiAgICAgICAgbmFtZWRSZWdleDogYF4ke3Jlc3VsdC5uYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICAgICAgcm91dGVLZXlzOiByZXN1bHQucm91dGVLZXlzXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXROYW1lZE1pZGRsZXdhcmVSZWdleChub3JtYWxpemVkUm91dGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBhcmFtZXRlcml6ZWRSb3V0ZSAgfSA9IGdldFBhcmFtZXRyaXplZFJvdXRlKG5vcm1hbGl6ZWRSb3V0ZSk7XG4gICAgY29uc3QgeyBjYXRjaEFsbCA9dHJ1ZSAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHBhcmFtZXRlcml6ZWRSb3V0ZSA9PT0gJy8nKSB7XG4gICAgICAgIGxldCBjYXRjaEFsbFJlZ2V4ID0gY2F0Y2hBbGwgPyAnLionIDogJyc7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lZFJlZ2V4OiBgXi8ke2NhdGNoQWxsUmVnZXh9JGBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSAgfSA9IGdldE5hbWVkUGFyYW1ldHJpemVkUm91dGUobm9ybWFsaXplZFJvdXRlKTtcbiAgICBsZXQgY2F0Y2hBbGxHcm91cGVkUmVnZXggPSBjYXRjaEFsbCA/ICcoPzooLy4qKT8pJyA6ICcnO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0ke2NhdGNoQWxsR3JvdXBlZFJlZ2V4fSRgXG4gICAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGUtcmVnZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0Um91dGVSZWdleCIsImdldE5hbWVkUm91dGVSZWdleCIsImdldE5hbWVkTWlkZGxld2FyZVJlZ2V4IiwiX2V4dGVuZHMiLCJyZXF1aXJlIiwiZGVmYXVsdCIsIl9lc2NhcGVSZWdleHAiLCJfcmVtb3ZlVHJhaWxpbmdTbGFzaCIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0UGFyYW1ldHJpemVkUm91dGUiLCJyb3V0ZSIsInNlZ21lbnRzIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsInNwbGl0IiwiZ3JvdXBzIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIm1hcCIsInNlZ21lbnQiLCJwb3MiLCJlc2NhcGVTdHJpbmdSZWdleHAiLCJqb2luIiwibm9ybWFsaXplZFJvdXRlIiwicmUiLCJSZWdFeHAiLCJidWlsZEdldFNhZmVSb3V0ZUtleSIsInJvdXRlS2V5Q2hhckNvZGUiLCJyb3V0ZUtleUNoYXJMZW5ndGgiLCJyb3V0ZUtleSIsImkiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJnZXROYW1lZFBhcmFtZXRyaXplZFJvdXRlIiwiZ2V0U2FmZVJvdXRlS2V5Iiwicm91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJjbGVhbmVkS2V5IiwicmVwbGFjZSIsImludmFsaWRLZXkiLCJsZW5ndGgiLCJpc05hTiIsInBhcnNlSW50IiwicmVzdWx0IiwibmFtZWRSZWdleCIsIm9wdGlvbnMiLCJjYXRjaEFsbCIsImNhdGNoQWxsUmVnZXgiLCJjYXRjaEFsbEdyb3VwZWRSZWdleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/route-regex.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getSortedRoutes = getSortedRoutes;\nclass UrlNode {\n    insert(urlPath) {\n        this._insert(urlPath.split(\"/\").filter(Boolean), [], false);\n    }\n    smoosh() {\n        return this._smoosh();\n    }\n    _smoosh() {\n        let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"/\";\n        const childrenPaths = [\n            ...this.children.keys()\n        ].sort();\n        if (this.slugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[]\"), 1);\n        }\n        if (this.restSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[...]\"), 1);\n        }\n        if (this.optionalRestSlugName !== null) {\n            childrenPaths.splice(childrenPaths.indexOf(\"[[...]]\"), 1);\n        }\n        const routes = childrenPaths.map((c)=>this.children.get(c)._smoosh(\"\".concat(prefix).concat(c, \"/\"))).reduce((prev, curr)=>[\n                ...prev,\n                ...curr\n            ], []);\n        if (this.slugName !== null) {\n            routes.push(...this.children.get(\"[]\")._smoosh(\"\".concat(prefix, \"[\").concat(this.slugName, \"]/\")));\n        }\n        if (!this.placeholder) {\n            const r = prefix === \"/\" ? \"/\" : prefix.slice(0, -1);\n            if (this.optionalRestSlugName != null) {\n                throw new Error('You cannot define a route with the same specificity as a optional catch-all route (\"'.concat(r, '\" and \"').concat(r, \"[[...\").concat(this.optionalRestSlugName, ']]\").'));\n            }\n            routes.unshift(r);\n        }\n        if (this.restSlugName !== null) {\n            routes.push(...this.children.get(\"[...]\")._smoosh(\"\".concat(prefix, \"[...\").concat(this.restSlugName, \"]/\")));\n        }\n        if (this.optionalRestSlugName !== null) {\n            routes.push(...this.children.get(\"[[...]]\")._smoosh(\"\".concat(prefix, \"[[...\").concat(this.optionalRestSlugName, \"]]/\")));\n        }\n        return routes;\n    }\n    _insert(urlPaths, slugNames, isCatchAll) {\n        if (urlPaths.length === 0) {\n            this.placeholder = false;\n            return;\n        }\n        if (isCatchAll) {\n            throw new Error(\"Catch-all must be the last part of the URL.\");\n        }\n        // The next segment in the urlPaths list\n        let nextSegment = urlPaths[0];\n        // Check if the segment matches `[something]`\n        if (nextSegment.startsWith(\"[\") && nextSegment.endsWith(\"]\")) {\n            // Strip `[` and `]`, leaving only `something`\n            let segmentName = nextSegment.slice(1, -1);\n            let isOptional = false;\n            if (segmentName.startsWith(\"[\") && segmentName.endsWith(\"]\")) {\n                // Strip optional `[` and `]`, leaving only `something`\n                segmentName = segmentName.slice(1, -1);\n                isOptional = true;\n            }\n            if (segmentName.startsWith(\"...\")) {\n                // Strip `...`, leaving only `something`\n                segmentName = segmentName.substring(3);\n                isCatchAll = true;\n            }\n            if (segmentName.startsWith(\"[\") || segmentName.endsWith(\"]\")) {\n                throw new Error(\"Segment names may not start or end with extra brackets ('\".concat(segmentName, \"').\"));\n            }\n            if (segmentName.startsWith(\".\")) {\n                throw new Error(\"Segment names may not start with erroneous periods ('\".concat(segmentName, \"').\"));\n            }\n            function handleSlug(previousSlug, nextSlug) {\n                if (previousSlug !== null) {\n                    // If the specific segment already has a slug but the slug is not `something`\n                    // This prevents collisions like:\n                    // pages/[post]/index.js\n                    // pages/[id]/index.js\n                    // Because currently multiple dynamic params on the same segment level are not supported\n                    if (previousSlug !== nextSlug) {\n                        // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n                        throw new Error(\"You cannot use different slug names for the same dynamic path ('\".concat(previousSlug, \"' !== '\").concat(nextSlug, \"').\"));\n                    }\n                }\n                slugNames.forEach((slug)=>{\n                    if (slug === nextSlug) {\n                        throw new Error('You cannot have the same slug name \"'.concat(nextSlug, '\" repeat within a single dynamic path'));\n                    }\n                    if (slug.replace(/\\W/g, \"\") === nextSegment.replace(/\\W/g, \"\")) {\n                        throw new Error('You cannot have the slug names \"'.concat(slug, '\" and \"').concat(nextSlug, '\" differ only by non-word symbols within a single dynamic path'));\n                    }\n                });\n                slugNames.push(nextSlug);\n            }\n            if (isCatchAll) {\n                if (isOptional) {\n                    if (this.restSlugName != null) {\n                        throw new Error('You cannot use both an required and optional catch-all route at the same level (\"[...'.concat(this.restSlugName, ']\" and \"').concat(urlPaths[0], '\" ).'));\n                    }\n                    handleSlug(this.optionalRestSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.optionalRestSlugName = segmentName;\n                    // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n                    nextSegment = \"[[...]]\";\n                } else {\n                    if (this.optionalRestSlugName != null) {\n                        throw new Error('You cannot use both an optional and required catch-all route at the same level (\"[[...'.concat(this.optionalRestSlugName, ']]\" and \"').concat(urlPaths[0], '\").'));\n                    }\n                    handleSlug(this.restSlugName, segmentName);\n                    // slugName is kept as it can only be one particular slugName\n                    this.restSlugName = segmentName;\n                    // nextSegment is overwritten to [...] so that it can later be sorted specifically\n                    nextSegment = \"[...]\";\n                }\n            } else {\n                if (isOptional) {\n                    throw new Error('Optional route parameters are not yet supported (\"'.concat(urlPaths[0], '\").'));\n                }\n                handleSlug(this.slugName, segmentName);\n                // slugName is kept as it can only be one particular slugName\n                this.slugName = segmentName;\n                // nextSegment is overwritten to [] so that it can later be sorted specifically\n                nextSegment = \"[]\";\n            }\n        }\n        // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n        if (!this.children.has(nextSegment)) {\n            this.children.set(nextSegment, new UrlNode());\n        }\n        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);\n    }\n    constructor(){\n        this.placeholder = true;\n        this.children = new Map();\n        this.slugName = null;\n        this.restSlugName = null;\n        this.optionalRestSlugName = null;\n    }\n}\nfunction getSortedRoutes(normalizedPages) {\n    // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n    // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n    // Only 1 dynamic segment per nesting level\n    // So in the case that is test/integration/dynamic-routing it'll be this:\n    // pages/[post]/comments.js\n    // pages/blog/[post]/comment/[id].js\n    // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n    // So in this case `UrlNode` created here has `this.slugName === 'post'`\n    // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n    // Instead what has to be passed through is the upwards path's dynamic names\n    const root = new UrlNode();\n    // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n    normalizedPages.forEach((pagePath)=>root.insert(pagePath));\n    // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n    return root.smoosh();\n} //# sourceMappingURL=sorted-routes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3NvcnRlZC1yb3V0ZXMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsdUJBQXVCLEdBQUdFO0FBQzFCLE1BQU1DO0lBQ0ZDLE9BQU9DLE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ0MsT0FBTyxDQUFDRCxRQUFRRSxLQUFLLENBQUMsS0FBS0MsTUFBTSxDQUFDQyxVQUFVLEVBQUUsRUFBRSxLQUFLO0lBQzlEO0lBQ0FDLFNBQVM7UUFDTCxPQUFPLElBQUksQ0FBQ0MsT0FBTztJQUN2QjtJQUNBQSxVQUFzQjtZQUFkQyxTQUFBQSxpRUFBUyxHQUFHO1FBQ2hCLE1BQU1DLGdCQUFnQjtlQUNmLElBQUksQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJO1NBQ3hCLENBQUNDLElBQUk7UUFDTixJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLElBQUksRUFBRTtZQUN4QkosY0FBY0ssTUFBTSxDQUFDTCxjQUFjTSxPQUFPLENBQUMsT0FBTztRQUN0RCxDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUNDLFlBQVksS0FBSyxJQUFJLEVBQUU7WUFDNUJQLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFVBQVU7UUFDekQsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDRSxvQkFBb0IsS0FBSyxJQUFJLEVBQUU7WUFDcENSLGNBQWNLLE1BQU0sQ0FBQ0wsY0FBY00sT0FBTyxDQUFDLFlBQVk7UUFDM0QsQ0FBQztRQUNELE1BQU1HLFNBQVNULGNBQWNVLEdBQUcsQ0FBQyxDQUFDQyxJQUFJLElBQUksQ0FBQ1YsUUFBUSxDQUFDVyxHQUFHLENBQUNELEdBQUdiLE9BQU8sQ0FBQyxHQUFZYSxPQUFUWixRQUFXLE9BQUZZLEdBQUUsT0FBS0UsTUFBTSxDQUFDLENBQUNDLE1BQU1DLE9BQU87bUJBQ2hHRDttQkFDQUM7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NEVBQTRFO0lBQzVFLE1BQU1DLE9BQU8sSUFBSXJEO0lBQ2pCLDZGQUE2RjtJQUM3Rm9ELGdCQUFnQlAsT0FBTyxDQUFDLENBQUNTLFdBQVdELEtBQUtwRCxNQUFNLENBQUNxRDtJQUNoRCw0R0FBNEc7SUFDNUcsT0FBT0QsS0FBSzlDLE1BQU07QUFDdEIsRUFFQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3JvdXRlci91dGlscy9zb3J0ZWQtcm91dGVzLmpzPzJmNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldFNvcnRlZFJvdXRlcyA9IGdldFNvcnRlZFJvdXRlcztcbmNsYXNzIFVybE5vZGUge1xuICAgIGluc2VydCh1cmxQYXRoKSB7XG4gICAgICAgIHRoaXMuX2luc2VydCh1cmxQYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pLCBbXSwgZmFsc2UpO1xuICAgIH1cbiAgICBzbW9vc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zbW9vc2goKTtcbiAgICB9XG4gICAgX3Ntb29zaChwcmVmaXggPSAnLycpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW5QYXRocyA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuY2hpbGRyZW4ua2V5cygpXG4gICAgICAgIF0uc29ydCgpO1xuICAgICAgICBpZiAodGhpcy5zbHVnTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW5QYXRocy5zcGxpY2UoY2hpbGRyZW5QYXRocy5pbmRleE9mKCdbXScpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZignWy4uLl0nKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuUGF0aHMuc3BsaWNlKGNoaWxkcmVuUGF0aHMuaW5kZXhPZignW1suLi5dXScpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZXMgPSBjaGlsZHJlblBhdGhzLm1hcCgoYyk9PnRoaXMuY2hpbGRyZW4uZ2V0KGMpLl9zbW9vc2goYCR7cHJlZml4fSR7Y30vYCkpLnJlZHVjZSgocHJldiwgY3Vycik9PltcbiAgICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICAgIC4uLmN1cnJcbiAgICAgICAgICAgIF0sIFtdKTtcbiAgICAgICAgaWYgKHRoaXMuc2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KCdbXScpLl9zbW9vc2goYCR7cHJlZml4fVske3RoaXMuc2x1Z05hbWV9XS9gKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjb25zdCByID0gcHJlZml4ID09PSAnLycgPyAnLycgOiBwcmVmaXguc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCBkZWZpbmUgYSByb3V0ZSB3aXRoIHRoZSBzYW1lIHNwZWNpZmljaXR5IGFzIGEgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIChcIiR7cn1cIiBhbmQgXCIke3J9W1suLi4ke3RoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWV9XV1cIikuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3V0ZXMudW5zaGlmdChyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN0U2x1Z05hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJvdXRlcy5wdXNoKC4uLnRoaXMuY2hpbGRyZW4uZ2V0KCdbLi4uXScpLl9zbW9vc2goYCR7cHJlZml4fVsuLi4ke3RoaXMucmVzdFNsdWdOYW1lfV0vYCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3V0ZXMucHVzaCguLi50aGlzLmNoaWxkcmVuLmdldCgnW1suLi5dXScpLl9zbW9vc2goYCR7cHJlZml4fVtbLi4uJHt0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lfV1dL2ApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm91dGVzO1xuICAgIH1cbiAgICBfaW5zZXJ0KHVybFBhdGhzLCBzbHVnTmFtZXMsIGlzQ2F0Y2hBbGwpIHtcbiAgICAgICAgaWYgKHVybFBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhdGNoLWFsbCBtdXN0IGJlIHRoZSBsYXN0IHBhcnQgb2YgdGhlIFVSTC5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbmV4dCBzZWdtZW50IGluIHRoZSB1cmxQYXRocyBsaXN0XG4gICAgICAgIGxldCBuZXh0U2VnbWVudCA9IHVybFBhdGhzWzBdO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc2VnbWVudCBtYXRjaGVzIGBbc29tZXRoaW5nXWBcbiAgICAgICAgaWYgKG5leHRTZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBuZXh0U2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAvLyBTdHJpcCBgW2AgYW5kIGBdYCwgbGVhdmluZyBvbmx5IGBzb21ldGhpbmdgXG4gICAgICAgICAgICBsZXQgc2VnbWVudE5hbWUgPSBuZXh0U2VnbWVudC5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBsZXQgaXNPcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50TmFtZS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgb3B0aW9uYWwgYFtgIGFuZCBgXWAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgICAgIHNlZ21lbnROYW1lID0gc2VnbWVudE5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIGlzT3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoJy4uLicpKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaXAgYC4uLmAsIGxlYXZpbmcgb25seSBgc29tZXRoaW5nYFxuICAgICAgICAgICAgICAgIHNlZ21lbnROYW1lID0gc2VnbWVudE5hbWUuc3Vic3RyaW5nKDMpO1xuICAgICAgICAgICAgICAgIGlzQ2F0Y2hBbGwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoJ1snKSB8fCBzZWdtZW50TmFtZS5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWdtZW50IG5hbWVzIG1heSBub3Qgc3RhcnQgb3IgZW5kIHdpdGggZXh0cmEgYnJhY2tldHMgKCcke3NlZ21lbnROYW1lfScpLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlZ21lbnROYW1lLnN0YXJ0c1dpdGgoJy4nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VnbWVudCBuYW1lcyBtYXkgbm90IHN0YXJ0IHdpdGggZXJyb25lb3VzIHBlcmlvZHMgKCcke3NlZ21lbnROYW1lfScpLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlU2x1ZyhwcmV2aW91c1NsdWcsIG5leHRTbHVnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzU2x1ZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc3BlY2lmaWMgc2VnbWVudCBhbHJlYWR5IGhhcyBhIHNsdWcgYnV0IHRoZSBzbHVnIGlzIG5vdCBgc29tZXRoaW5nYFxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIGNvbGxpc2lvbnMgbGlrZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFnZXMvW3Bvc3RdL2luZGV4LmpzXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhZ2VzL1tpZF0vaW5kZXguanNcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBjdXJyZW50bHkgbXVsdGlwbGUgZHluYW1pYyBwYXJhbXMgb24gdGhlIHNhbWUgc2VnbWVudCBsZXZlbCBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNTbHVnICE9PSBuZXh0U2x1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBlcnJvciBzZWVtcyB0byBiZSBjb25mdXNpbmcgZm9yIHVzZXJzLCBuZWVkcyBhbiBlcnJvciBsaW5rLCB0aGUgZGVzY3JpcHRpb24gY2FuIGJlIGJhc2VkIG9uIGFib3ZlIGNvbW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIGRpZmZlcmVudCBzbHVnIG5hbWVzIGZvciB0aGUgc2FtZSBkeW5hbWljIHBhdGggKCcke3ByZXZpb3VzU2x1Z30nICE9PSAnJHtuZXh0U2x1Z30nKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzbHVnTmFtZXMuZm9yRWFjaCgoc2x1Zyk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsdWcgPT09IG5leHRTbHVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgaGF2ZSB0aGUgc2FtZSBzbHVnIG5hbWUgXCIke25leHRTbHVnfVwiIHJlcGVhdCB3aXRoaW4gYSBzaW5nbGUgZHluYW1pYyBwYXRoYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsdWcucmVwbGFjZSgvXFxXL2csICcnKSA9PT0gbmV4dFNlZ21lbnQucmVwbGFjZSgvXFxXL2csICcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IGhhdmUgdGhlIHNsdWcgbmFtZXMgXCIke3NsdWd9XCIgYW5kIFwiJHtuZXh0U2x1Z31cIiBkaWZmZXIgb25seSBieSBub24td29yZCBzeW1ib2xzIHdpdGhpbiBhIHNpbmdsZSBkeW5hbWljIHBhdGhgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHNsdWdOYW1lcy5wdXNoKG5leHRTbHVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdFNsdWdOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgYm90aCBhbiByZXF1aXJlZCBhbmQgb3B0aW9uYWwgY2F0Y2gtYWxsIHJvdXRlIGF0IHRoZSBzYW1lIGxldmVsIChcIlsuLi4ke3RoaXMucmVzdFNsdWdOYW1lfV1cIiBhbmQgXCIke3VybFBhdGhzWzBdfVwiICkuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU2x1Zyh0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lLCBzZWdtZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25hbFJlc3RTbHVnTmFtZSA9IHNlZ21lbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICAvLyBuZXh0U2VnbWVudCBpcyBvdmVyd3JpdHRlbiB0byBbWy4uLl1dIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgbmV4dFNlZ21lbnQgPSAnW1suLi5dXSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBib3RoIGFuIG9wdGlvbmFsIGFuZCByZXF1aXJlZCBjYXRjaC1hbGwgcm91dGUgYXQgdGhlIHNhbWUgbGV2ZWwgKFwiW1suLi4ke3RoaXMub3B0aW9uYWxSZXN0U2x1Z05hbWV9XV1cIiBhbmQgXCIke3VybFBhdGhzWzBdfVwiKS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVTbHVnKHRoaXMucmVzdFNsdWdOYW1lLCBzZWdtZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNsdWdOYW1lIGlzIGtlcHQgYXMgaXQgY2FuIG9ubHkgYmUgb25lIHBhcnRpY3VsYXIgc2x1Z05hbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN0U2x1Z05hbWUgPSBzZWdtZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV4dFNlZ21lbnQgaXMgb3ZlcndyaXR0ZW4gdG8gWy4uLl0gc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgc29ydGVkIHNwZWNpZmljYWxseVxuICAgICAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9ICdbLi4uXSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wdGlvbmFsIHJvdXRlIHBhcmFtZXRlcnMgYXJlIG5vdCB5ZXQgc3VwcG9ydGVkIChcIiR7dXJsUGF0aHNbMF19XCIpLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYW5kbGVTbHVnKHRoaXMuc2x1Z05hbWUsIHNlZ21lbnROYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBzbHVnTmFtZSBpcyBrZXB0IGFzIGl0IGNhbiBvbmx5IGJlIG9uZSBwYXJ0aWN1bGFyIHNsdWdOYW1lXG4gICAgICAgICAgICAgICAgdGhpcy5zbHVnTmFtZSA9IHNlZ21lbnROYW1lO1xuICAgICAgICAgICAgICAgIC8vIG5leHRTZWdtZW50IGlzIG92ZXJ3cml0dGVuIHRvIFtdIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIHNvcnRlZCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAgICAgICBuZXh0U2VnbWVudCA9ICdbXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhpcyBVcmxOb2RlIGRvZXNuJ3QgaGF2ZSB0aGUgbmV4dFNlZ21lbnQgeWV0IHdlIGNyZWF0ZSBhIG5ldyBjaGlsZCBVcmxOb2RlXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbi5oYXMobmV4dFNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNldChuZXh0U2VnbWVudCwgbmV3IFVybE5vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5nZXQobmV4dFNlZ21lbnQpLl9pbnNlcnQodXJsUGF0aHMuc2xpY2UoMSksIHNsdWdOYW1lcywgaXNDYXRjaEFsbCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNsdWdOYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXN0U2x1Z05hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLm9wdGlvbmFsUmVzdFNsdWdOYW1lID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTb3J0ZWRSb3V0ZXMobm9ybWFsaXplZFBhZ2VzKSB7XG4gICAgLy8gRmlyc3QgdGhlIFVybE5vZGUgaXMgY3JlYXRlZCwgYW5kIGV2ZXJ5IFVybE5vZGUgY2FuIGhhdmUgb25seSAxIGR5bmFtaWMgc2VnbWVudFxuICAgIC8vIEVnIHlvdSBjYW4ndCBoYXZlIHBhZ2VzL1twb3N0XS9hYmMuanMgYW5kIHBhZ2VzL1toZWxsb10vc29tZXRoaW5nLWVsc2UuanNcbiAgICAvLyBPbmx5IDEgZHluYW1pYyBzZWdtZW50IHBlciBuZXN0aW5nIGxldmVsXG4gICAgLy8gU28gaW4gdGhlIGNhc2UgdGhhdCBpcyB0ZXN0L2ludGVncmF0aW9uL2R5bmFtaWMtcm91dGluZyBpdCdsbCBiZSB0aGlzOlxuICAgIC8vIHBhZ2VzL1twb3N0XS9jb21tZW50cy5qc1xuICAgIC8vIHBhZ2VzL2Jsb2cvW3Bvc3RdL2NvbW1lbnQvW2lkXS5qc1xuICAgIC8vIEJvdGggYXJlIGZpbmUgYmVjYXVzZSBgcGFnZXMvW3Bvc3RdYCBhbmQgYHBhZ2VzL2Jsb2dgIGFyZSBvbiB0aGUgc2FtZSBsZXZlbFxuICAgIC8vIFNvIGluIHRoaXMgY2FzZSBgVXJsTm9kZWAgY3JlYXRlZCBoZXJlIGhhcyBgdGhpcy5zbHVnTmFtZSA9PT0gJ3Bvc3QnYFxuICAgIC8vIEFuZCBzaW5jZSB5b3VyIFBSIHBhc3NlZCB0aHJvdWdoIGBzbHVnTmFtZWAgYXMgYW4gYXJyYXkgYmFzaWNhbGx5IGl0J2QgaW5jbHVkaW5nIGl0IGluIHRvbyBtYW55IHBvc3NpYmlsaXRpZXNcbiAgICAvLyBJbnN0ZWFkIHdoYXQgaGFzIHRvIGJlIHBhc3NlZCB0aHJvdWdoIGlzIHRoZSB1cHdhcmRzIHBhdGgncyBkeW5hbWljIG5hbWVzXG4gICAgY29uc3Qgcm9vdCA9IG5ldyBVcmxOb2RlKCk7XG4gICAgLy8gSGVyZSB0aGUgYHJvb3RgIGdldHMgaW5qZWN0ZWQgbXVsdGlwbGUgcGF0aHMsIGFuZCBpbnNlcnQgd2lsbCBicmVhayB0aGVtIHVwIGludG8gc3VibGV2ZWxzXG4gICAgbm9ybWFsaXplZFBhZ2VzLmZvckVhY2goKHBhZ2VQYXRoKT0+cm9vdC5pbnNlcnQocGFnZVBhdGgpKTtcbiAgICAvLyBTbW9vc2ggd2lsbCB0aGVuIHNvcnQgdGhvc2Ugc3VibGV2ZWxzIHVwIHRvIHRoZSBwb2ludCB3aGVyZSB5b3UgZ2V0IHRoZSBjb3JyZWN0IHJvdXRlIGRlZmluaXRpb24gcHJpb3JpdHlcbiAgICByZXR1cm4gcm9vdC5zbW9vc2goKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydGVkLXJvdXRlcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXRTb3J0ZWRSb3V0ZXMiLCJVcmxOb2RlIiwiaW5zZXJ0IiwidXJsUGF0aCIsIl9pbnNlcnQiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJzbW9vc2giLCJfc21vb3NoIiwicHJlZml4IiwiY2hpbGRyZW5QYXRocyIsImNoaWxkcmVuIiwia2V5cyIsInNvcnQiLCJzbHVnTmFtZSIsInNwbGljZSIsImluZGV4T2YiLCJyZXN0U2x1Z05hbWUiLCJvcHRpb25hbFJlc3RTbHVnTmFtZSIsInJvdXRlcyIsIm1hcCIsImMiLCJnZXQiLCJyZWR1Y2UiLCJwcmV2IiwiY3VyciIsInB1c2giLCJwbGFjZWhvbGRlciIsInIiLCJzbGljZSIsIkVycm9yIiwidW5zaGlmdCIsInVybFBhdGhzIiwic2x1Z05hbWVzIiwiaXNDYXRjaEFsbCIsImxlbmd0aCIsIm5leHRTZWdtZW50Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic2VnbWVudE5hbWUiLCJpc09wdGlvbmFsIiwic3Vic3RyaW5nIiwiaGFuZGxlU2x1ZyIsInByZXZpb3VzU2x1ZyIsIm5leHRTbHVnIiwiZm9yRWFjaCIsInNsdWciLCJyZXBsYWNlIiwiaGFzIiwic2V0IiwiY29uc3RydWN0b3IiLCJNYXAiLCJub3JtYWxpemVkUGFnZXMiLCJyb290IiwicGFnZVBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/sorted-routes.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/runtime-config.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/runtime-config.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setConfig = setConfig;\nexports[\"default\"] = void 0;\nlet runtimeConfig;\nvar _default = ()=>{\n    return runtimeConfig;\n};\nexports[\"default\"] = _default;\nfunction setConfig(configValue) {\n    runtimeConfig = configValue;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=runtime-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcnVudGltZS1jb25maWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsaUJBQWlCLEdBQUdFO0FBQ3BCRixrQkFBZSxHQUFHLEtBQUs7QUFDdkIsSUFBSUk7QUFDSixJQUFJQyxXQUFXLElBQUk7SUFDZixPQUFPRDtBQUNYO0FBQ0FKLGtCQUFlLEdBQUdLO0FBQ2xCLFNBQVNILFVBQVVJLFdBQVcsRUFBRTtJQUM1QkYsZ0JBQWdCRTtBQUNwQjtBQUVBLElBQUksQ0FBQyxPQUFPTixRQUFRRyxPQUFPLEtBQUssY0FBZSxPQUFPSCxRQUFRRyxPQUFPLEtBQUssWUFBWUgsUUFBUUcsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPSCxRQUFRRyxPQUFPLENBQUNJLFVBQVUsS0FBSyxhQUFhO0lBQ3JLVCxPQUFPQyxjQUFjLENBQUNDLFFBQVFHLE9BQU8sRUFBRSxjQUFjO1FBQUVGLE9BQU8sSUFBSTtJQUFDO0lBQ25FSCxPQUFPVSxNQUFNLENBQUNSLFFBQVFHLE9BQU8sRUFBRUg7SUFDL0JTLE9BQU9ULE9BQU8sR0FBR0EsUUFBUUcsT0FBTztBQUNsQyxDQUFDLENBRUQsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZy5qcz9lMGEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zZXRDb25maWcgPSBzZXRDb25maWc7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5sZXQgcnVudGltZUNvbmZpZztcbnZhciBfZGVmYXVsdCA9ICgpPT57XG4gICAgcmV0dXJuIHJ1bnRpbWVDb25maWc7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG5mdW5jdGlvbiBzZXRDb25maWcoY29uZmlnVmFsdWUpIHtcbiAgICBydW50aW1lQ29uZmlnID0gY29uZmlnVmFsdWU7XG59XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ1bnRpbWUtY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldENvbmZpZyIsImRlZmF1bHQiLCJydW50aW1lQ29uZmlnIiwiX2RlZmF1bHQiLCJjb25maWdWYWx1ZSIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/runtime-config.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = SideEffect;\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _react = _interop_require_wildcard(__webpack_require__(/*! react */ \"./node_modules/next/dist/compiled/react/index.js\"));\nfunction SideEffect(props) {\n    _s();\n    const { headManager , reduceComponentsToState  } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var ref;\n        headManager == null ? void 0 : (ref = headManager.mountedInstances) == null ? void 0 : ref.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var ref1;\n        headManager == null ? void 0 : (ref1 = headManager.mountedInstances) == null ? void 0 : ref1.add(props.children);\n        return ()=>{\n            var ref;\n            headManager == null ? void 0 : (ref = headManager.mountedInstances) == null ? void 0 : ref.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n}\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nconst isServer = \"object\" === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect; //# sourceMappingURL=side-effect.js.map\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc2lkZS1lZmZlY3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGtCQUFlLEdBQUdHO0FBQ2xCLElBQUlDLDRCQUE0QkMscUpBQWdFO0FBQ2hHLElBQUlDLFNBQVNGLDBCQUEwQkMsbUJBQU9BLENBQUMsK0RBQU87QUFDdEQsU0FBU0YsV0FBV0ksS0FBSyxFQUFFOztJQUN2QixNQUFNLEVBQUVDLFlBQVcsRUFBR0Msd0JBQXVCLEVBQUcsR0FBR0Y7SUFDbkQsU0FBU0csYUFBYTtRQUNsQixJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUM3QyxNQUFNQyxlQUFlTixPQUFPTyxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBRU0sTUFBTSxDQUFDQztZQUM3RlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQ2pFLENBQUM7SUFDTDtJQUNBLElBQUlhLFVBQVU7UUFDVixJQUFJQztRQUNKYixlQUFlLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQ2EsTUFBTWIsWUFBWUcsZ0JBQWdCLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSVUsSUFBSUMsR0FBRyxDQUFDZixNQUFNZ0IsUUFBUSxDQUFDO1FBQzlHYjtJQUNKLENBQUM7SUFDRGMsMEJBQTBCLElBQUk7UUFDMUIsSUFBSUM7UUFDSmpCLGVBQWUsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDaUIsT0FBT2pCLFlBQVlHLGdCQUFnQixLQUFLLElBQUksR0FBRyxLQUFLLElBQUljLEtBQUtILEdBQUcsQ0FBQ2YsTUFBTWdCLFFBQVEsQ0FBQztRQUNoSCxPQUFPLElBQUk7WUFDUCxJQUFJRjtZQUNKYixlQUFlLElBQUksR0FBRyxLQUFLLElBQUksQ0FBQ2EsTUFBTWIsWUFBWUcsZ0JBQWdCLEtBQUssSUFBSSxHQUFHLEtBQUssSUFBSVUsSUFBSUssTUFBTSxDQUFDbkIsTUFBTWdCLFFBQVEsQ0FBQztRQUNySDtJQUNKO0lBQ0Esa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRkMsMEJBQTBCLElBQUk7UUFDMUIsSUFBSWhCLGFBQWE7WUFDYkEsWUFBWW1CLGNBQWMsR0FBR2pCO1FBQ2pDLENBQUM7UUFDRCxPQUFPLElBQUk7WUFDUCxJQUFJRixhQUFhO2dCQUNiQSxZQUFZbUIsY0FBYyxHQUFHakI7WUFDakMsQ0FBQztRQUNMO0lBQ0o7SUFDQWtCLG9CQUFvQixJQUFJO1FBQ3BCLElBQUlwQixlQUFlQSxZQUFZbUIsY0FBYyxFQUFFO1lBQzNDbkIsWUFBWW1CLGNBQWM7WUFDMUJuQixZQUFZbUIsY0FBYyxHQUFHLElBQUk7UUFDckMsQ0FBQztRQUNELE9BQU8sSUFBSTtZQUNQLElBQUluQixlQUFlQSxZQUFZbUIsY0FBYyxFQUFFO2dCQUMzQ25CLFlBQVltQixjQUFjO2dCQUMxQm5CLFlBQVltQixjQUFjLEdBQUcsSUFBSTtZQUNyQyxDQUFDO1FBQ0w7SUFDSjtJQUNBLE9BQU8sSUFBSTtBQUNmO0dBakRTeEI7O1FBYUxxQjtRQWFBQTtRQVVBSTs7O0tBcENLekI7QUFrRFQsTUFBTWlCLFdBQVcsYUFBa0I7QUFDbkMsTUFBTUksNEJBQTRCSixXQUFXLElBQUksQ0FBQyxJQUFJZCxPQUFPdUIsZUFBZTtBQUM1RSxNQUFNRCxzQkFBc0JSLFdBQVcsSUFBSSxDQUFDLElBQUlkLE9BQU93QixTQUFTLEVBRWhFLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvc2lkZS1lZmZlY3QuanM/NDA4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IFNpZGVFZmZlY3Q7XG52YXIgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuanNcIikuZGVmYXVsdDtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzKSB7XG4gICAgY29uc3QgeyBoZWFkTWFuYWdlciAsIHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlICB9ID0gcHJvcHM7XG4gICAgZnVuY3Rpb24gZW1pdENoYW5nZSgpIHtcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRFbGVtZW50cyA9IF9yZWFjdC5DaGlsZHJlbi50b0FycmF5KEFycmF5LmZyb20oaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykuZmlsdGVyKEJvb2xlYW4pKTtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLnVwZGF0ZUhlYWQocmVkdWNlQ29tcG9uZW50c1RvU3RhdGUoaGVhZEVsZW1lbnRzLCBwcm9wcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NlcnZlcikge1xuICAgICAgICB2YXIgcmVmO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKHJlZiA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuYWRkKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgZW1pdENoYW5nZSgpO1xuICAgIH1cbiAgICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIHZhciByZWYxO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKHJlZjEgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMS5hZGQocHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKHJlZiA9IGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuZGVsZXRlKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvLyBXZSBuZWVkIHRvIGNhbGwgYHVwZGF0ZUhlYWRgIG1ldGhvZCB3aGVuZXZlciB0aGUgYFNpZGVFZmZlY3RgIGlzIHRyaWdnZXIgaW4gYWxsXG4gICAgLy8gbGlmZS1jeWNsZXM6IG1vdW50LCB1cGRhdGUsIHVubW91bnQuIEhvd2V2ZXIsIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBgU2lkZUVmZmVjdGBzXG4gICAgLy8gYmVpbmcgcmVuZGVyZWQsIHdlIG9ubHkgdHJpZ2dlciB0aGUgbWV0aG9kIGZyb20gdGhlIGxhc3Qgb25lLlxuICAgIC8vIFRoaXMgaXMgZW5zdXJlZCBieSBrZWVwaW5nIHRoZSBsYXN0IHVuZmx1c2hlZCBgdXBkYXRlSGVhZGAgaW4gdGhlIGBfcGVuZGluZ1VwZGF0ZWBcbiAgICAvLyBzaW5nbGV0b24gaW4gdGhlIGxheW91dCBlZmZlY3QgcGFzcywgYW5kIGFjdHVhbGx5IHRyaWdnZXIgaXQgaW4gdGhlIGVmZmVjdCBwYXNzLlxuICAgIHVzZUNsaWVudE9ubHlMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoaGVhZE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IGVtaXRDaGFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgdXNlQ2xpZW50T25seUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKCk7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAoaGVhZE1hbmFnZXIgJiYgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5jb25zdCB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0ID0gaXNTZXJ2ZXIgPyAoKT0+e30gOiBfcmVhY3QudXNlTGF5b3V0RWZmZWN0O1xuY29uc3QgdXNlQ2xpZW50T25seUVmZmVjdCA9IGlzU2VydmVyID8gKCk9Pnt9IDogX3JlYWN0LnVzZUVmZmVjdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lkZS1lZmZlY3QuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZGVmYXVsdCIsIlNpZGVFZmZlY3QiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9yZWFjdCIsInByb3BzIiwiaGVhZE1hbmFnZXIiLCJyZWR1Y2VDb21wb25lbnRzVG9TdGF0ZSIsImVtaXRDaGFuZ2UiLCJtb3VudGVkSW5zdGFuY2VzIiwiaGVhZEVsZW1lbnRzIiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiQm9vbGVhbiIsInVwZGF0ZUhlYWQiLCJpc1NlcnZlciIsInJlZiIsImFkZCIsImNoaWxkcmVuIiwidXNlQ2xpZW50T25seUxheW91dEVmZmVjdCIsInJlZjEiLCJkZWxldGUiLCJfcGVuZGluZ1VwZGF0ZSIsInVzZUNsaWVudE9ubHlFZmZlY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.normalizeRepeatedSlashes = normalizeRepeatedSlashes;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.ST = exports.SP = exports.isAbsoluteUrl = exports.WEB_VITALS = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nconst WEB_VITALS = [\n    \"CLS\",\n    \"FCP\",\n    \"FID\",\n    \"INP\",\n    \"LCP\",\n    \"TTFB\"\n];\nexports.WEB_VITALS = WEB_VITALS;\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nexports.isAbsoluteUrl = isAbsoluteUrl;\nfunction getLocationOrigin() {\n    const { protocol , hostname , port  } = window.location;\n    return \"\".concat(protocol, \"//\").concat(hostname).concat(port ? \":\" + port : \"\");\n}\nfunction getURL() {\n    const { href  } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === \"string\" ? Component : Component.displayName || Component.name || \"Unknown\";\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split(\"?\");\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, \"/\").replace(/\\/\\/+/g, \"/\") + (urlParts[1] ? \"?\".concat(urlParts.slice(1).join(\"?\")) : \"\");\n}\nfunction loadGetInitialProps(App, ctx) {\n    return _loadGetInitialProps.apply(this, arguments);\n}\nfunction _loadGetInitialProps() {\n    _loadGetInitialProps = _async_to_generator(function*(App, ctx) {\n        if (true) {\n            var ref;\n            if ((ref = App.prototype) == null ? void 0 : ref.getInitialProps) {\n                const message = '\"'.concat(getDisplayName(App), '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.');\n                throw new Error(message);\n            }\n        }\n        // when called from _app `ctx` is nested in `ctx`\n        const res = ctx.res || ctx.ctx && ctx.ctx.res;\n        if (!App.getInitialProps) {\n            if (ctx.ctx && ctx.Component) {\n                // @ts-ignore pageProps default\n                return {\n                    pageProps: yield loadGetInitialProps(ctx.Component, ctx.ctx)\n                };\n            }\n            return {};\n        }\n        const props = yield App.getInitialProps(ctx);\n        if (res && isResSent(res)) {\n            return props;\n        }\n        if (!props) {\n            const message1 = '\"'.concat(getDisplayName(App), '.getInitialProps()\" should resolve to an object. But found \"').concat(props, '\" instead.');\n            throw new Error(message1);\n        }\n        if (true) {\n            if (Object.keys(props).length === 0 && !ctx.ctx) {\n                console.warn(\"\".concat(getDisplayName(App), \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\"));\n            }\n        }\n        return props;\n    });\n    return _loadGetInitialProps.apply(this, arguments);\n}\nconst SP = typeof performance !== \"undefined\";\nexports.SP = SP;\nconst ST = SP && [\n    \"mark\",\n    \"measure\",\n    \"getEntriesByName\"\n].every((method)=>typeof performance[method] === \"function\");\nexports.ST = ST;\nclass DecodeError extends Error {\n}\nexports.DecodeError = DecodeError;\nclass NormalizeError extends Error {\n}\nexports.NormalizeError = NormalizeError;\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find module for page: \".concat(page);\n    }\n}\nexports.PageNotFoundError = PageNotFoundError;\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \".concat(page, \" \").concat(message);\n    }\n}\nexports.MissingStaticPage = MissingStaticPage;\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = \"ENOENT\";\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nexports.MiddlewareNotFoundError = MiddlewareNotFoundError; //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQsZ0JBQWdCLEdBQUdFO0FBQ25CRix5QkFBeUIsR0FBR0c7QUFDNUJILGNBQWMsR0FBR0k7QUFDakJKLHNCQUFzQixHQUFHSztBQUN6QkwsaUJBQWlCLEdBQUdNO0FBQ3BCTixnQ0FBZ0MsR0FBR087QUFDbkNQLDJCQUEyQixHQUFHUTtBQUM5QlIsVUFBVSxHQUFHQSxVQUFVLEdBQUdBLHFCQUFxQixHQUFHQSxrQkFBa0IsR0FBRyxLQUFLO0FBQzVFLElBQUlhLHNCQUFzQkMseUlBQTBEO0FBQ3BGLE1BQU1GLGFBQWE7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDSDtBQUNEWixrQkFBa0IsR0FBR1k7QUFDckIsU0FBU1YsU0FBU2MsRUFBRSxFQUFFO0lBQ2xCLElBQUlDLE9BQU8sS0FBSztJQUNoQixJQUFJQztJQUNKLE9BQU8sV0FBVzt5Q0FBUEM7WUFBQUE7O1FBQ1AsSUFBSSxDQUFDRixNQUFNO1lBQ1BBLE9BQU8sSUFBSTtZQUNYQyxTQUFTRixNQUFNRztRQUNuQixDQUFDO1FBQ0QsT0FBT0Q7SUFDWDtBQUNKO0FBQ0EsMERBQTBEO0FBQzFELGdFQUFnRTtBQUNoRSxNQUFNRSxxQkFBcUI7QUFDM0IsTUFBTVQsZ0JBQWdCLENBQUNVLE1BQU1ELG1CQUFtQkUsSUFBSSxDQUFDRDtBQUNyRHJCLHFCQUFxQixHQUFHVztBQUN4QixTQUFTUixvQkFBb0I7SUFDekIsTUFBTSxFQUFFb0IsU0FBUSxFQUFHQyxTQUFRLEVBQUdDLEtBQUksRUFBRyxHQUFHQyxPQUFPQyxRQUFRO0lBQ3ZELE9BQU8sR0FBZ0JILE9BQWJELFVBQVMsTUFBZUUsT0FBWEQsVUFBa0MsT0FBdkJDLE9BQU8sTUFBTUEsT0FBTyxFQUFFO0FBQzVEO0FBQ0EsU0FBU3JCLFNB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T0FBTyxLQUFLO0FBQ2pEOUQsVUFBVSxHQUFHUztBQUNiLE1BQU1zRCxvQkFBb0JUO0FBQzFCO0FBQ0F0RCxtQkFBbUIsR0FBRytEO0FBQ3RCLE1BQU1DLHVCQUF1QlY7QUFDN0I7QUFDQXRELHNCQUFzQixHQUFHZ0U7QUFDekIsTUFBTUMsMEJBQTBCWDtJQUM1QlksWUFBWUMsSUFBSSxDQUFDO1FBQ2IsS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDZixPQUFPLEdBQUcsZ0NBQXFDLE9BQUxjO0lBQ25EO0FBQ0o7QUFDQW5FLHlCQUF5QixHQUFHaUU7QUFDNUIsTUFBTUksMEJBQTBCZjtJQUM1QlksWUFBWUMsSUFBSSxFQUFFZCxPQUFPLENBQUM7UUFDdEIsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFHLHdDQUFnREEsT0FBUmMsTUFBSyxLQUFXLE9BQVJkO0lBQ25FO0FBQ0o7QUFDQXJELHlCQUF5QixHQUFHcUU7QUFDNUIsTUFBTUMsZ0NBQWdDaEI7SUFDbENZLGFBQWE7UUFDVCxLQUFLO1FBQ0wsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNmLE9BQU8sR0FBSTtJQUNwQjtBQUNKO0FBQ0FyRCwrQkFBK0IsR0FBR3NFLHlCQUVsQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3V0aWxzLmpzP2U3ZmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmV4ZWNPbmNlID0gZXhlY09uY2U7XG5leHBvcnRzLmdldExvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW47XG5leHBvcnRzLmdldFVSTCA9IGdldFVSTDtcbmV4cG9ydHMuZ2V0RGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZTtcbmV4cG9ydHMuaXNSZXNTZW50ID0gaXNSZXNTZW50O1xuZXhwb3J0cy5ub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMgPSBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXM7XG5leHBvcnRzLmxvYWRHZXRJbml0aWFsUHJvcHMgPSBsb2FkR2V0SW5pdGlhbFByb3BzO1xuZXhwb3J0cy5TVCA9IGV4cG9ydHMuU1AgPSBleHBvcnRzLmlzQWJzb2x1dGVVcmwgPSBleHBvcnRzLldFQl9WSVRBTFMgPSB2b2lkIDA7XG52YXIgX2FzeW5jX3RvX2dlbmVyYXRvciA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvbGliL19hc3luY190b19nZW5lcmF0b3IuanNcIikuZGVmYXVsdDtcbmNvbnN0IFdFQl9WSVRBTFMgPSBbXG4gICAgJ0NMUycsXG4gICAgJ0ZDUCcsXG4gICAgJ0ZJRCcsXG4gICAgJ0lOUCcsXG4gICAgJ0xDUCcsXG4gICAgJ1RURkInXG5dO1xuZXhwb3J0cy5XRUJfVklUQUxTID0gV0VCX1ZJVEFMUztcbmZ1bmN0aW9uIGV4ZWNPbmNlKGZuKSB7XG4gICAgbGV0IHVzZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHJldHVybiAoLi4uYXJncyk9PntcbiAgICAgICAgaWYgKCF1c2VkKSB7XG4gICAgICAgICAgICB1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbi8vIFNjaGVtZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcbi8vIEFic29sdXRlIFVSTDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi00LjNcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKj86LztcbmNvbnN0IGlzQWJzb2x1dGVVcmwgPSAodXJsKT0+QUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QodXJsKTtcbmV4cG9ydHMuaXNBYnNvbHV0ZVVybCA9IGlzQWJzb2x1dGVVcmw7XG5mdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgICBjb25zdCB7IHByb3RvY29sICwgaG9zdG5hbWUgLCBwb3J0ICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWA7XG59XG5mdW5jdGlvbiBnZXRVUkwoKSB7XG4gICAgY29uc3QgeyBocmVmICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpO1xufVxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUoQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnID8gQ29tcG9uZW50IDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJztcbn1cbmZ1bmN0aW9uIGlzUmVzU2VudChyZXMpIHtcbiAgICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGVhdGVkU2xhc2hlcyh1cmwpIHtcbiAgICBjb25zdCB1cmxQYXJ0cyA9IHVybC5zcGxpdCgnPycpO1xuICAgIGNvbnN0IHVybE5vUXVlcnkgPSB1cmxQYXJ0c1swXTtcbiAgICByZXR1cm4gdXJsTm9RdWVyeS8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgIC8vIHRoZW4gbm9ybWFsaXplIHJlcGVhdGVkIGZvcndhcmQgc2xhc2hlc1xuICAgIC5yZXBsYWNlKC9cXFxcL2csICcvJykucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICsgKHVybFBhcnRzWzFdID8gYD8ke3VybFBhcnRzLnNsaWNlKDEpLmpvaW4oJz8nKX1gIDogJycpO1xufVxuZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGN0eCkge1xuICAgIHJldHVybiBfbG9hZEdldEluaXRpYWxQcm9wcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX2xvYWRHZXRJbml0aWFsUHJvcHMoKSB7XG4gICAgX2xvYWRHZXRJbml0aWFsUHJvcHMgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKihBcHAsIGN0eCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHJlZjtcbiAgICAgICAgICAgIGlmICgocmVmID0gQXBwLnByb3RvdHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZi5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgICAgICAgY29uc3QgcmVzID0gY3R4LnJlcyB8fCBjdHguY3R4ICYmIGN0eC5jdHgucmVzO1xuICAgICAgICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHBhZ2VQcm9wcyBkZWZhdWx0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVByb3BzOiB5aWVsZCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wcyA9IHlpZWxkIEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KTtcbiAgICAgICAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKEFwcCl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYDtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb3BzKS5sZW5ndGggPT09IDAgJiYgIWN0eC5jdHgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Z2V0RGlzcGxheU5hbWUoQXBwKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIF9sb2FkR2V0SW5pdGlhbFByb3BzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCc7XG5leHBvcnRzLlNQID0gU1A7XG5jb25zdCBTVCA9IFNQICYmIFtcbiAgICAnbWFyaycsXG4gICAgJ21lYXN1cmUnLFxuICAgICdnZXRFbnRyaWVzQnlOYW1lJ1xuXS5ldmVyeSgobWV0aG9kKT0+dHlwZW9mIHBlcmZvcm1hbmNlW21ldGhvZF0gPT09ICdmdW5jdGlvbicpO1xuZXhwb3J0cy5TVCA9IFNUO1xuY2xhc3MgRGVjb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnRzLkRlY29kZUVycm9yID0gRGVjb2RlRXJyb3I7XG5jbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuTm9ybWFsaXplRXJyb3IgPSBOb3JtYWxpemVFcnJvcjtcbmNsYXNzIFBhZ2VOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhZ2Upe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIG1vZHVsZSBmb3IgcGFnZTogJHtwYWdlfWA7XG4gICAgfVxufVxuZXhwb3J0cy5QYWdlTm90Rm91bmRFcnJvciA9IFBhZ2VOb3RGb3VuZEVycm9yO1xuY2xhc3MgTWlzc2luZ1N0YXRpY1BhZ2UgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocGFnZSwgbWVzc2FnZSl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgZmlsZSBmb3IgcGFnZTogJHtwYWdlfSAke21lc3NhZ2V9YDtcbiAgICB9XG59XG5leHBvcnRzLk1pc3NpbmdTdGF0aWNQYWdlID0gTWlzc2luZ1N0YXRpY1BhZ2U7XG5jbGFzcyBNaWRkbGV3YXJlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZWA7XG4gICAgfVxufVxuZXhwb3J0cy5NaWRkbGV3YXJlTm90Rm91bmRFcnJvciA9IE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJleGVjT25jZSIsImdldExvY2F0aW9uT3JpZ2luIiwiZ2V0VVJMIiwiZ2V0RGlzcGxheU5hbWUiLCJpc1Jlc1NlbnQiLCJub3JtYWxpemVSZXBlYXRlZFNsYXNoZXMiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiU1QiLCJTUCIsImlzQWJzb2x1dGVVcmwiLCJXRUJfVklUQUxTIiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJkZWZhdWx0IiwiZm4iLCJ1c2VkIiwicmVzdWx0IiwiYXJncyIsIkFCU09MVVRFX1VSTF9SRUdFWCIsInVybCIsInRlc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsIkNvbXBvbmVudCIsImRpc3BsYXlOYW1lIiwibmFtZSIsInJlcyIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJ1cmxQYXJ0cyIsInNwbGl0IiwidXJsTm9RdWVyeSIsInJlcGxhY2UiLCJzbGljZSIsImpvaW4iLCJBcHAiLCJjdHgiLCJfbG9hZEdldEluaXRpYWxQcm9wcyIsImFwcGx5IiwiYXJndW1lbnRzIiwicHJvY2VzcyIsInJlZiIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsIkRlY29kZUVycm9yIiwiTm9ybWFsaXplRXJyb3IiLCJQYWdlTm90Rm91bmRFcnJvciIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils/warn-once.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils/warn-once.js ***!
  \**************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.warnOnce = void 0;\nlet warnOnce = (_)=>{};\nif (true) {\n    const warnings = new Set();\n    exports.warnOnce = warnOnce = (msg)=>{\n        if (!warnings.has(msg)) {\n            console.warn(msg);\n        }\n        warnings.add(msg);\n    };\n}\nexports.warnOnce = warnOnce; //# sourceMappingURL=warn-once.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTyxJQUFJO0FBQ2YsQ0FBQyxFQUFDO0FBQ0ZELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsSUFBSUUsV0FBVyxDQUFDQyxJQUFJLENBQUM7QUFDckIsSUFBSUMsSUFBeUIsRUFBYztJQUN2QyxNQUFNQyxXQUFXLElBQUlDO0lBQ3JCTixnQkFBZ0IsR0FBR0UsV0FBVyxDQUFDSyxNQUFNO1FBQ2pDLElBQUksQ0FBQ0YsU0FBU0csR0FBRyxDQUFDRCxNQUFNO1lBQ3BCRSxRQUFRQyxJQUFJLENBQUNIO1FBQ2pCLENBQUM7UUFDREYsU0FBU00sR0FBRyxDQUFDSjtJQUNqQjtBQUNKLENBQUM7QUFDRFAsZ0JBQWdCLEdBQUdFLFVBRW5CLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMvd2Fybi1vbmNlLmpzPzczOTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLndhcm5PbmNlID0gdm9pZCAwO1xubGV0IHdhcm5PbmNlID0gKF8pPT57fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBuZXcgU2V0KCk7XG4gICAgZXhwb3J0cy53YXJuT25jZSA9IHdhcm5PbmNlID0gKG1zZyk9PntcbiAgICAgICAgaWYgKCF3YXJuaW5ncy5oYXMobXNnKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZ3MuYWRkKG1zZyk7XG4gICAgfTtcbn1cbmV4cG9ydHMud2Fybk9uY2UgPSB3YXJuT25jZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2Fybi1vbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIndhcm5PbmNlIiwiXyIsInByb2Nlc3MiLCJ3YXJuaW5ncyIsIlNldCIsIm1zZyIsImhhcyIsImNvbnNvbGUiLCJ3YXJuIiwiYWRkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils/warn-once.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n          case REACT_SUSPENSE_LIST_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_SERVER_CONTEXT_TYPE:\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n}\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar SuspenseList = REACT_SUSPENSE_LIST_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false;\nvar hasWarnedAboutDeprecatedIsConcurrentMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isConcurrentMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsConcurrentMode) {\n      hasWarnedAboutDeprecatedIsConcurrentMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isConcurrentMode() alias has been deprecated, ' + 'and will be removed in React 18+.');\n    }\n  }\n\n  return false;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\nfunction isSuspenseList(object) {\n  return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;\n}\n\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.SuspenseList = SuspenseList;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isSuspenseList = isSuspenseList;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixZQUFZO0FBQ1osY0FBYztBQUNkLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzP2VjODUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0U7XG5cbntcbiAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1vZHVsZS5yZWZlcmVuY2UnKTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBUaGlzIG5lZWRzIHRvIGluY2x1ZGUgYWxsIHBvc3NpYmxlIG1vZHVsZSByZWZlcmVuY2Ugb2JqZWN0XG4gICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgIC8vIHdpdGguXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgU3VzcGVuc2VMaXN0ID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNDb25jdXJyZW50TW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQ29uY3VycmVudE1vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VMaXN0KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbn1cblxuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLlN1c3BlbnNlTGlzdCA9IFN1c3BlbnNlTGlzdDtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1N1c3BlbnNlTGlzdCA9IGlzU3VzcGVuc2VMaXN0O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/react-is/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/compiled/react-is/index.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"./node_modules/next/dist/compiled/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSkFBeUQ7QUFDM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcy9pbmRleC5qcz80MjNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/react-is/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/web-vitals/web-vitals.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/web-vitals/web-vitals.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){\"use strict\";var n={};!function(){n.d=function(y,T){for(var C in T){if(n.o(T,C)&&!n.o(y,C)){Object.defineProperty(y,C,{enumerable:true,get:T[C]})}}}}();!function(){n.o=function(n,y){return Object.prototype.hasOwnProperty.call(n,y)}}();!function(){n.r=function(n){if(typeof Symbol!==\"undefined\"&&Symbol.toStringTag){Object.defineProperty(n,Symbol.toStringTag,{value:\"Module\"})}Object.defineProperty(n,\"__esModule\",{value:true})}}();if(typeof n!==\"undefined\")n.ab=__dirname+\"/\";var y={};n.r(y);n.d(y,{getCLS:function(){return E},getFCP:function(){return g},getFID:function(){return F},getINP:function(){return O},getLCP:function(){return _},getTTFB:function(){return G},onCLS:function(){return E},onFCP:function(){return g},onFID:function(){return F},onINP:function(){return O},onLCP:function(){return _},onTTFB:function(){return G}});var T,C,w,P,I,k=-1,o=function(n){addEventListener(\"pageshow\",(function(y){y.persisted&&(k=y.timeStamp,n(y))}),!0)},c=function(){return window.performance&&performance.getEntriesByType&&performance.getEntriesByType(\"navigation\")[0]},u=function(){var n=c();return n&&n.activationStart||0},f=function(n,y){var T=c(),C=\"navigate\";return k>=0?C=\"back-forward-cache\":T&&(C=document.prerendering||u()>0?\"prerender\":T.type.replace(/_/g,\"-\")),{name:n,value:void 0===y?-1:y,rating:\"good\",delta:0,entries:[],id:\"v3-\".concat(Date.now(),\"-\").concat(Math.floor(8999999999999*Math.random())+1e12),navigationType:C}},s=function(n,y,T){try{if(PerformanceObserver.supportedEntryTypes.includes(n)){var C=new PerformanceObserver((function(n){y(n.getEntries())}));return C.observe(Object.assign({type:n,buffered:!0},T||{})),C}}catch(n){}},d=function(n,y){var T=function t(T){\"pagehide\"!==T.type&&\"hidden\"!==document.visibilityState||(n(T),y&&(removeEventListener(\"visibilitychange\",t,!0),removeEventListener(\"pagehide\",t,!0)))};addEventListener(\"visibilitychange\",T,!0),addEventListener(\"pagehide\",T,!0)},l=function(n,y,T,C){var w,P;return function(I){y.value>=0&&(I||C)&&((P=y.value-(w||0))||void 0===w)&&(w=y.value,y.delta=P,y.rating=function(n,y){return n>y[1]?\"poor\":n>y[0]?\"needs-improvement\":\"good\"}(y.value,T),n(y))}},N=-1,v=function(){return\"hidden\"!==document.visibilityState||document.prerendering?1/0:0},m=function(){d((function(n){var y=n.timeStamp;N=y}),!0)},h=function(){return N<0&&(N=v(),m(),o((function(){setTimeout((function(){N=v(),m()}),0)}))),{get firstHiddenTime(){return N}}},g=function(n,y){y=y||{};var T,C=[1800,3e3],w=h(),P=f(\"FCP\"),c=function(n){n.forEach((function(n){\"first-contentful-paint\"===n.name&&(k&&k.disconnect(),n.startTime<w.firstHiddenTime&&(P.value=n.startTime-u(),P.entries.push(n),T(!0)))}))},I=window.performance&&window.performance.getEntriesByName&&window.performance.getEntriesByName(\"first-contentful-paint\")[0],k=I?null:s(\"paint\",c);(I||k)&&(T=l(n,P,C,y.reportAllChanges),I&&c([I]),o((function(w){P=f(\"FCP\"),T=l(n,P,C,y.reportAllChanges),requestAnimationFrame((function(){requestAnimationFrame((function(){P.value=performance.now()-w.timeStamp,T(!0)}))}))})))},j=!1,q=-1,E=function(n,y){y=y||{};var T=[.1,.25];j||(g((function(n){q=n.value})),j=!0);var C,i=function(y){q>-1&&n(y)},w=f(\"CLS\",0),P=0,I=[],p=function(n){n.forEach((function(n){if(!n.hadRecentInput){var y=I[0],T=I[I.length-1];P&&n.startTime-T.startTime<1e3&&n.startTime-y.startTime<5e3?(P+=n.value,I.push(n)):(P=n.value,I=[n]),P>w.value&&(w.value=P,w.entries=I,C())}}))},k=s(\"layout-shift\",p);k&&(C=l(i,w,T,y.reportAllChanges),d((function(){p(k.takeRecords()),C(!0)})),o((function(){P=0,q=-1,w=f(\"CLS\",0),C=l(i,w,T,y.reportAllChanges)})))},x={passive:!0,capture:!0},z=new Date,L=function(n,y){T||(T=y,C=n,w=new Date,A(removeEventListener),S())},S=function(){if(C>=0&&C<w-z){var n={entryType:\"first-input\",name:T.type,target:T.target,cancelable:T.cancelable,startTime:T.timeStamp,processingStart:T.timeStamp+C};P.forEach((function(y){y(n)})),P=[]}},b=function(n){if(n.cancelable){var y=(n.timeStamp>1e12?new Date:performance.now())-n.timeStamp;\"pointerdown\"==n.type?function(n,y){var t=function(){L(n,y),i()},r=function(){i()},i=function(){removeEventListener(\"pointerup\",t,x),removeEventListener(\"pointercancel\",r,x)};addEventListener(\"pointerup\",t,x),addEventListener(\"pointercancel\",r,x)}(y,n):L(y,n)}},A=function(n){[\"mousedown\",\"keydown\",\"touchstart\",\"pointerdown\"].forEach((function(y){return n(y,b,x)}))},F=function(n,y){y=y||{};var w,I=[100,300],k=h(),N=f(\"FID\"),v=function(n){n.startTime<k.firstHiddenTime&&(N.value=n.processingStart-n.startTime,N.entries.push(n),w(!0))},m=function(n){n.forEach(v)},j=s(\"first-input\",m);w=l(n,N,I,y.reportAllChanges),j&&d((function(){m(j.takeRecords()),j.disconnect()}),!0),j&&o((function(){var k;N=f(\"FID\"),w=l(n,N,I,y.reportAllChanges),P=[],C=-1,T=null,A(addEventListener),k=v,P.push(k),S()}))},J=0,K=1/0,Q=0,M=function(n){n.forEach((function(n){n.interactionId&&(K=Math.min(K,n.interactionId),Q=Math.max(Q,n.interactionId),J=Q?(Q-K)/7+1:0)}))},B=function(){return I?J:performance.interactionCount||0},D=function(){\"interactionCount\"in performance||I||(I=s(\"event\",M,{type:\"event\",buffered:!0,durationThreshold:0}))},U=0,R=function(){return B()-U},V=[],W={},H=function(n){var y=V[V.length-1],T=W[n.interactionId];if(T||V.length<10||n.duration>y.latency){if(T)T.entries.push(n),T.latency=Math.max(T.latency,n.duration);else{var C={id:n.interactionId,latency:n.duration,entries:[n]};W[C.id]=C,V.push(C)}V.sort((function(n,y){return y.latency-n.latency})),V.splice(10).forEach((function(n){delete W[n.id]}))}},O=function(n,y){y=y||{};var T=[200,500];D();var C,w=f(\"INP\"),a=function(n){n.forEach((function(n){(n.interactionId&&H(n),\"first-input\"===n.entryType)&&(!V.some((function(y){return y.entries.some((function(y){return n.duration===y.duration&&n.startTime===y.startTime}))}))&&H(n))}));var y,T=(y=Math.min(V.length-1,Math.floor(R()/50)),V[y]);T&&T.latency!==w.value&&(w.value=T.latency,w.entries=T.entries,C())},P=s(\"event\",a,{durationThreshold:y.durationThreshold||40});C=l(n,w,T,y.reportAllChanges),P&&(P.observe({type:\"first-input\",buffered:!0}),d((function(){a(P.takeRecords()),w.value<0&&R()>0&&(w.value=0,w.entries=[]),C(!0)})),o((function(){V=[],U=B(),w=f(\"INP\"),C=l(n,w,T,y.reportAllChanges)})))},X={},_=function(n,y){y=y||{};var T,C=[2500,4e3],w=h(),P=f(\"LCP\"),c=function(n){var y=n[n.length-1];if(y){var C=y.startTime-u();C<w.firstHiddenTime&&(P.value=C,P.entries=[y],T())}},I=s(\"largest-contentful-paint\",c);if(I){T=l(n,P,C,y.reportAllChanges);var v=function(){X[P.id]||(c(I.takeRecords()),I.disconnect(),X[P.id]=!0,T(!0))};[\"keydown\",\"click\"].forEach((function(n){addEventListener(n,v,{once:!0,capture:!0})})),d(v,!0),o((function(w){P=f(\"LCP\"),T=l(n,P,C,y.reportAllChanges),requestAnimationFrame((function(){requestAnimationFrame((function(){P.value=performance.now()-w.timeStamp,X[P.id]=!0,T(!0)}))}))}))}},Y=function e(n){document.prerendering?addEventListener(\"prerenderingchange\",(function(){return e(n)}),!0):\"complete\"!==document.readyState?addEventListener(\"load\",(function(){return e(n)}),!0):setTimeout(n,0)},G=function(n,y){y=y||{};var T=[800,1800],C=f(\"TTFB\"),w=l(n,C,T,y.reportAllChanges);Y((function(){var P=c();if(P){if(C.value=Math.max(P.responseStart-u(),0),C.value<0||C.value>performance.now())return;C.entries=[P],w(!0),o((function(){C=f(\"TTFB\",0),(w=l(n,C,T,y.reportAllChanges))(!0)}))}}))};module.exports=y})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3dlYi12aXRhbHMvd2ViLXZpdGFscy5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxhQUFhLFNBQVMsWUFBWSxrQkFBa0IsZ0JBQWdCLHdCQUF3QiwyQkFBMkIseUJBQXlCLEtBQUssR0FBRyxZQUFZLGtCQUFrQixrREFBa0QsR0FBRyxZQUFZLGdCQUFnQixvREFBb0QsNENBQTRDLGVBQWUsRUFBRSxzQ0FBc0MsV0FBVyxHQUFHLEdBQUcsK0JBQStCLFNBQVMsS0FBSyxTQUFTLE9BQU8sT0FBTyxrQkFBa0IsU0FBUyxtQkFBbUIsU0FBUyxtQkFBbUIsU0FBUyxtQkFBbUIsU0FBUyxtQkFBbUIsU0FBUyxvQkFBb0IsU0FBUyxrQkFBa0IsU0FBUyxrQkFBa0IsU0FBUyxrQkFBa0IsU0FBUyxrQkFBa0IsU0FBUyxrQkFBa0IsU0FBUyxtQkFBbUIsVUFBVSxFQUFFLGlDQUFpQyx5Q0FBeUMsa0NBQWtDLE1BQU0sY0FBYyx1R0FBdUcsY0FBYyxVQUFVLCtCQUErQixpQkFBaUIsdUJBQXVCLDZHQUE2RyxxS0FBcUssbUJBQW1CLElBQUksd0RBQXdELDJDQUEyQyxrQkFBa0IsR0FBRyxnQ0FBZ0MsbUJBQW1CLE1BQU0sTUFBTSxXQUFXLGlCQUFpQixvQkFBb0IseUpBQXlKLDRFQUE0RSxxQkFBcUIsUUFBUSxtQkFBbUIsa0dBQWtHLHVEQUF1RCxtQkFBbUIsbUJBQW1CLHVFQUF1RSxjQUFjLGVBQWUsa0JBQWtCLElBQUksTUFBTSxjQUFjLHFDQUFxQyx1QkFBdUIsVUFBVSxLQUFLLEtBQUssc0JBQXNCLFdBQVcsaUJBQWlCLFFBQVEsa0RBQWtELHVCQUF1Qix3SUFBd0ksR0FBRyxtSkFBbUosZ0VBQWdFLDJFQUEyRSxrQ0FBa0MsNENBQTRDLEdBQUcsR0FBRyxJQUFJLDJCQUEyQixRQUFRLGVBQWUsbUJBQW1CLFVBQVUsU0FBUyxvQkFBb0IsV0FBVyxxQ0FBcUMsdUJBQXVCLHNCQUFzQiwyQkFBMkIsNklBQTZJLEdBQUcsdUJBQXVCLGdEQUFnRCx5QkFBeUIsaUJBQWlCLG9EQUFvRCxJQUFJLElBQUksc0JBQXNCLDRCQUE0QixtREFBbUQsY0FBYyxnQkFBZ0IsT0FBTyxpSUFBaUksdUJBQXVCLEtBQUssU0FBUyxlQUFlLGlCQUFpQixnRUFBZ0Usb0NBQW9DLGlCQUFpQixXQUFXLGNBQWMsSUFBSSxjQUFjLCtFQUErRSx3RUFBd0UsY0FBYyxlQUFlLHdFQUF3RSxnQkFBZ0IsR0FBRyxpQkFBaUIsUUFBUSxpREFBaUQsK0ZBQStGLGVBQWUsYUFBYSxzQkFBc0IsK0NBQStDLGtDQUFrQyx1QkFBdUIsTUFBTSxnR0FBZ0csR0FBRyw2QkFBNkIsdUJBQXVCLCtGQUErRixHQUFHLGNBQWMsMkNBQTJDLGNBQWMscURBQXFELDZDQUE2QyxHQUFHLGtCQUFrQixhQUFhLFVBQVUsZUFBZSx5Q0FBeUMseUNBQXlDLGdFQUFnRSxLQUFLLE9BQU8sbURBQW1ELG9CQUFvQixzQkFBc0IsMkJBQTJCLHFDQUFxQyxlQUFlLElBQUksaUJBQWlCLFFBQVEsZ0JBQWdCLElBQUksK0JBQStCLHVCQUF1QiwyRUFBMkUsbUNBQW1DLDBEQUEwRCxHQUFHLFVBQVUsR0FBRyx5REFBeUQsb0VBQW9FLGdCQUFnQiwwQ0FBMEMsRUFBRSw2Q0FBNkMsK0JBQStCLGdCQUFnQixvRUFBb0UsaUJBQWlCLG9EQUFvRCxJQUFJLEtBQUssaUJBQWlCLFFBQVEsa0RBQWtELG9CQUFvQixNQUFNLHNCQUFzQixvREFBb0QsbUNBQW1DLE1BQU0sOEJBQThCLGlCQUFpQiwrREFBK0QseUNBQXlDLHNCQUFzQixtQkFBbUIsRUFBRSwwQkFBMEIsMkVBQTJFLGtDQUFrQyx1REFBdUQsR0FBRyxHQUFHLElBQUksaUJBQWlCLHdFQUF3RSxZQUFZLDJFQUEyRSxZQUFZLHNCQUFzQixpQkFBaUIsUUFBUSwyREFBMkQsY0FBYyxVQUFVLE1BQU0sdUZBQXVGLGtDQUFrQyxrREFBa0QsSUFBSSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3dlYi12aXRhbHMvd2ViLXZpdGFscy5qcz8wOWY0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciBuPXt9OyFmdW5jdGlvbigpe24uZD1mdW5jdGlvbih5LFQpe2Zvcih2YXIgQyBpbiBUKXtpZihuLm8oVCxDKSYmIW4ubyh5LEMpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoeSxDLHtlbnVtZXJhYmxlOnRydWUsZ2V0OlRbQ119KX19fX0oKTshZnVuY3Rpb24oKXtuLm89ZnVuY3Rpb24obix5KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4seSl9fSgpOyFmdW5jdGlvbigpe24ucj1mdW5jdGlvbihuKXtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvU3RyaW5nVGFnKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KX1PYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pfX0oKTtpZih0eXBlb2YgbiE9PVwidW5kZWZpbmVkXCIpbi5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHk9e307bi5yKHkpO24uZCh5LHtnZXRDTFM6ZnVuY3Rpb24oKXtyZXR1cm4gRX0sZ2V0RkNQOmZ1bmN0aW9uKCl7cmV0dXJuIGd9LGdldEZJRDpmdW5jdGlvbigpe3JldHVybiBGfSxnZXRJTlA6ZnVuY3Rpb24oKXtyZXR1cm4gT30sZ2V0TENQOmZ1bmN0aW9uKCl7cmV0dXJuIF99LGdldFRURkI6ZnVuY3Rpb24oKXtyZXR1cm4gR30sb25DTFM6ZnVuY3Rpb24oKXtyZXR1cm4gRX0sb25GQ1A6ZnVuY3Rpb24oKXtyZXR1cm4gZ30sb25GSUQ6ZnVuY3Rpb24oKXtyZXR1cm4gRn0sb25JTlA6ZnVuY3Rpb24oKXtyZXR1cm4gT30sb25MQ1A6ZnVuY3Rpb24oKXtyZXR1cm4gX30sb25UVEZCOmZ1bmN0aW9uKCl7cmV0dXJuIEd9fSk7dmFyIFQsQyx3LFAsSSxrPS0xLG89ZnVuY3Rpb24obil7YWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VzaG93XCIsKGZ1bmN0aW9uKHkpe3kucGVyc2lzdGVkJiYoaz15LnRpbWVTdGFtcCxuKHkpKX0pLCEwKX0sYz1mdW5jdGlvbigpe3JldHVybiB3aW5kb3cucGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUmJnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdfSx1PWZ1bmN0aW9uKCl7dmFyIG49YygpO3JldHVybiBuJiZuLmFjdGl2YXRpb25TdGFydHx8MH0sZj1mdW5jdGlvbihuLHkpe3ZhciBUPWMoKSxDPVwibmF2aWdhdGVcIjtyZXR1cm4gaz49MD9DPVwiYmFjay1mb3J3YXJkLWNhY2hlXCI6VCYmKEM9ZG9jdW1lbnQucHJlcmVuZGVyaW5nfHx1KCk+MD9cInByZXJlbmRlclwiOlQudHlwZS5yZXBsYWNlKC9fL2csXCItXCIpKSx7bmFtZTpuLHZhbHVlOnZvaWQgMD09PXk/LTE6eSxyYXRpbmc6XCJnb29kXCIsZGVsdGE6MCxlbnRyaWVzOltdLGlkOlwidjMtXCIuY29uY2F0KERhdGUubm93KCksXCItXCIpLmNvbmNhdChNYXRoLmZsb29yKDg5OTk5OTk5OTk5OTkqTWF0aC5yYW5kb20oKSkrMWUxMiksbmF2aWdhdGlvblR5cGU6Q319LHM9ZnVuY3Rpb24obix5LFQpe3RyeXtpZihQZXJmb3JtYW5jZU9ic2VydmVyLnN1cHBvcnRlZEVudHJ5VHlwZXMuaW5jbHVkZXMobikpe3ZhciBDPW5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChmdW5jdGlvbihuKXt5KG4uZ2V0RW50cmllcygpKX0pKTtyZXR1cm4gQy5vYnNlcnZlKE9iamVjdC5hc3NpZ24oe3R5cGU6bixidWZmZXJlZDohMH0sVHx8e30pKSxDfX1jYXRjaChuKXt9fSxkPWZ1bmN0aW9uKG4seSl7dmFyIFQ9ZnVuY3Rpb24gdChUKXtcInBhZ2VoaWRlXCIhPT1ULnR5cGUmJlwiaGlkZGVuXCIhPT1kb2N1bWVudC52aXNpYmlsaXR5U3RhdGV8fChuKFQpLHkmJihyZW1vdmVFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLHQsITApLHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLHQsITApKSl9O2FkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsVCwhMCksYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsVCwhMCl9LGw9ZnVuY3Rpb24obix5LFQsQyl7dmFyIHcsUDtyZXR1cm4gZnVuY3Rpb24oSSl7eS52YWx1ZT49MCYmKEl8fEMpJiYoKFA9eS52YWx1ZS0od3x8MCkpfHx2b2lkIDA9PT13KSYmKHc9eS52YWx1ZSx5LmRlbHRhPVAseS5yYXRpbmc9ZnVuY3Rpb24obix5KXtyZXR1cm4gbj55WzFdP1wicG9vclwiOm4+eVswXT9cIm5lZWRzLWltcHJvdmVtZW50XCI6XCJnb29kXCJ9KHkudmFsdWUsVCksbih5KSl9fSxOPS0xLHY9ZnVuY3Rpb24oKXtyZXR1cm5cImhpZGRlblwiIT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlfHxkb2N1bWVudC5wcmVyZW5kZXJpbmc/MS8wOjB9LG09ZnVuY3Rpb24oKXtkKChmdW5jdGlvbihuKXt2YXIgeT1uLnRpbWVTdGFtcDtOPXl9KSwhMCl9LGg9ZnVuY3Rpb24oKXtyZXR1cm4gTjwwJiYoTj12KCksbSgpLG8oKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtOPXYoKSxtKCl9KSwwKX0pKSkse2dldCBmaXJzdEhpZGRlblRpbWUoKXtyZXR1cm4gTn19fSxnPWZ1bmN0aW9uKG4seSl7eT15fHx7fTt2YXIgVCxDPVsxODAwLDNlM10sdz1oKCksUD1mKFwiRkNQXCIpLGM9ZnVuY3Rpb24obil7bi5mb3JFYWNoKChmdW5jdGlvbihuKXtcImZpcnN0LWNvbnRlbnRmdWwtcGFpbnRcIj09PW4ubmFtZSYmKGsmJmsuZGlzY29ubmVjdCgpLG4uc3RhcnRUaW1lPHcuZmlyc3RIaWRkZW5UaW1lJiYoUC52YWx1ZT1uLnN0YXJ0VGltZS11KCksUC5lbnRyaWVzLnB1c2gobiksVCghMCkpKX0pKX0sST13aW5kb3cucGVyZm9ybWFuY2UmJndpbmRvdy5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lJiZ3aW5kb3cucGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcImZpcnN0LWNvbnRlbnRmdWwtcGFpbnRcIilbMF0saz1JP251bGw6cyhcInBhaW50XCIsYyk7KEl8fGspJiYoVD1sKG4sUCxDLHkucmVwb3J0QWxsQ2hhbmdlcyksSSYmYyhbSV0pLG8oKGZ1bmN0aW9uKHcpe1A9ZihcIkZDUFwiKSxUPWwobixQLEMseS5yZXBvcnRBbGxDaGFuZ2VzKSxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKChmdW5jdGlvbigpe1AudmFsdWU9cGVyZm9ybWFuY2Uubm93KCktdy50aW1lU3RhbXAsVCghMCl9KSl9KSl9KSkpfSxqPSExLHE9LTEsRT1mdW5jdGlvbihuLHkpe3k9eXx8e307dmFyIFQ9Wy4xLC4yNV07anx8KGcoKGZ1bmN0aW9uKG4pe3E9bi52YWx1ZX0pKSxqPSEwKTt2YXIgQyxpPWZ1bmN0aW9uKHkpe3E+LTEmJm4oeSl9LHc9ZihcIkNMU1wiLDApLFA9MCxJPVtdLHA9ZnVuY3Rpb24obil7bi5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighbi5oYWRSZWNlbnRJbnB1dCl7dmFyIHk9SVswXSxUPUlbSS5sZW5ndGgtMV07UCYmbi5zdGFydFRpbWUtVC5zdGFydFRpbWU8MWUzJiZuLnN0YXJ0VGltZS15LnN0YXJ0VGltZTw1ZTM/KFArPW4udmFsdWUsSS5wdXNoKG4pKTooUD1uLnZhbHVlLEk9W25dKSxQPncudmFsdWUmJih3LnZhbHVlPVAsdy5lbnRyaWVzPUksQygpKX19KSl9LGs9cyhcImxheW91dC1zaGlmdFwiLHApO2smJihDPWwoaSx3LFQseS5yZXBvcnRBbGxDaGFuZ2VzKSxkKChmdW5jdGlvbigpe3Aoay50YWtlUmVjb3JkcygpKSxDKCEwKX0pKSxvKChmdW5jdGlvbigpe1A9MCxxPS0xLHc9ZihcIkNMU1wiLDApLEM9bChpLHcsVCx5LnJlcG9ydEFsbENoYW5nZXMpfSkpKX0seD17cGFzc2l2ZTohMCxjYXB0dXJlOiEwfSx6PW5ldyBEYXRlLEw9ZnVuY3Rpb24obix5KXtUfHwoVD15LEM9bix3PW5ldyBEYXRlLEEocmVtb3ZlRXZlbnRMaXN0ZW5lciksUygpKX0sUz1mdW5jdGlvbigpe2lmKEM+PTAmJkM8dy16KXt2YXIgbj17ZW50cnlUeXBlOlwiZmlyc3QtaW5wdXRcIixuYW1lOlQudHlwZSx0YXJnZXQ6VC50YXJnZXQsY2FuY2VsYWJsZTpULmNhbmNlbGFibGUsc3RhcnRUaW1lOlQudGltZVN0YW1wLHByb2Nlc3NpbmdTdGFydDpULnRpbWVTdGFtcCtDfTtQLmZvckVhY2goKGZ1bmN0aW9uKHkpe3kobil9KSksUD1bXX19LGI9ZnVuY3Rpb24obil7aWYobi5jYW5jZWxhYmxlKXt2YXIgeT0obi50aW1lU3RhbXA+MWUxMj9uZXcgRGF0ZTpwZXJmb3JtYW5jZS5ub3coKSktbi50aW1lU3RhbXA7XCJwb2ludGVyZG93blwiPT1uLnR5cGU/ZnVuY3Rpb24obix5KXt2YXIgdD1mdW5jdGlvbigpe0wobix5KSxpKCl9LHI9ZnVuY3Rpb24oKXtpKCl9LGk9ZnVuY3Rpb24oKXtyZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsdCx4KSxyZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLHIseCl9O2FkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIix0LHgpLGFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIscix4KX0oeSxuKTpMKHksbil9fSxBPWZ1bmN0aW9uKG4pe1tcIm1vdXNlZG93blwiLFwia2V5ZG93blwiLFwidG91Y2hzdGFydFwiLFwicG9pbnRlcmRvd25cIl0uZm9yRWFjaCgoZnVuY3Rpb24oeSl7cmV0dXJuIG4oeSxiLHgpfSkpfSxGPWZ1bmN0aW9uKG4seSl7eT15fHx7fTt2YXIgdyxJPVsxMDAsMzAwXSxrPWgoKSxOPWYoXCJGSURcIiksdj1mdW5jdGlvbihuKXtuLnN0YXJ0VGltZTxrLmZpcnN0SGlkZGVuVGltZSYmKE4udmFsdWU9bi5wcm9jZXNzaW5nU3RhcnQtbi5zdGFydFRpbWUsTi5lbnRyaWVzLnB1c2gobiksdyghMCkpfSxtPWZ1bmN0aW9uKG4pe24uZm9yRWFjaCh2KX0saj1zKFwiZmlyc3QtaW5wdXRcIixtKTt3PWwobixOLEkseS5yZXBvcnRBbGxDaGFuZ2VzKSxqJiZkKChmdW5jdGlvbigpe20oai50YWtlUmVjb3JkcygpKSxqLmRpc2Nvbm5lY3QoKX0pLCEwKSxqJiZvKChmdW5jdGlvbigpe3ZhciBrO049ZihcIkZJRFwiKSx3PWwobixOLEkseS5yZXBvcnRBbGxDaGFuZ2VzKSxQPVtdLEM9LTEsVD1udWxsLEEoYWRkRXZlbnRMaXN0ZW5lciksaz12LFAucHVzaChrKSxTKCl9KSl9LEo9MCxLPTEvMCxRPTAsTT1mdW5jdGlvbihuKXtuLmZvckVhY2goKGZ1bmN0aW9uKG4pe24uaW50ZXJhY3Rpb25JZCYmKEs9TWF0aC5taW4oSyxuLmludGVyYWN0aW9uSWQpLFE9TWF0aC5tYXgoUSxuLmludGVyYWN0aW9uSWQpLEo9UT8oUS1LKS83KzE6MCl9KSl9LEI9ZnVuY3Rpb24oKXtyZXR1cm4gST9KOnBlcmZvcm1hbmNlLmludGVyYWN0aW9uQ291bnR8fDB9LEQ9ZnVuY3Rpb24oKXtcImludGVyYWN0aW9uQ291bnRcImluIHBlcmZvcm1hbmNlfHxJfHwoST1zKFwiZXZlbnRcIixNLHt0eXBlOlwiZXZlbnRcIixidWZmZXJlZDohMCxkdXJhdGlvblRocmVzaG9sZDowfSkpfSxVPTAsUj1mdW5jdGlvbigpe3JldHVybiBCKCktVX0sVj1bXSxXPXt9LEg9ZnVuY3Rpb24obil7dmFyIHk9VltWLmxlbmd0aC0xXSxUPVdbbi5pbnRlcmFjdGlvbklkXTtpZihUfHxWLmxlbmd0aDwxMHx8bi5kdXJhdGlvbj55LmxhdGVuY3kpe2lmKFQpVC5lbnRyaWVzLnB1c2gobiksVC5sYXRlbmN5PU1hdGgubWF4KFQubGF0ZW5jeSxuLmR1cmF0aW9uKTtlbHNle3ZhciBDPXtpZDpuLmludGVyYWN0aW9uSWQsbGF0ZW5jeTpuLmR1cmF0aW9uLGVudHJpZXM6W25dfTtXW0MuaWRdPUMsVi5wdXNoKEMpfVYuc29ydCgoZnVuY3Rpb24obix5KXtyZXR1cm4geS5sYXRlbmN5LW4ubGF0ZW5jeX0pKSxWLnNwbGljZSgxMCkuZm9yRWFjaCgoZnVuY3Rpb24obil7ZGVsZXRlIFdbbi5pZF19KSl9fSxPPWZ1bmN0aW9uKG4seSl7eT15fHx7fTt2YXIgVD1bMjAwLDUwMF07RCgpO3ZhciBDLHc9ZihcIklOUFwiKSxhPWZ1bmN0aW9uKG4pe24uZm9yRWFjaCgoZnVuY3Rpb24obil7KG4uaW50ZXJhY3Rpb25JZCYmSChuKSxcImZpcnN0LWlucHV0XCI9PT1uLmVudHJ5VHlwZSkmJighVi5zb21lKChmdW5jdGlvbih5KXtyZXR1cm4geS5lbnRyaWVzLnNvbWUoKGZ1bmN0aW9uKHkpe3JldHVybiBuLmR1cmF0aW9uPT09eS5kdXJhdGlvbiYmbi5zdGFydFRpbWU9PT15LnN0YXJ0VGltZX0pKX0pKSYmSChuKSl9KSk7dmFyIHksVD0oeT1NYXRoLm1pbihWLmxlbmd0aC0xLE1hdGguZmxvb3IoUigpLzUwKSksVlt5XSk7VCYmVC5sYXRlbmN5IT09dy52YWx1ZSYmKHcudmFsdWU9VC5sYXRlbmN5LHcuZW50cmllcz1ULmVudHJpZXMsQygpKX0sUD1zKFwiZXZlbnRcIixhLHtkdXJhdGlvblRocmVzaG9sZDp5LmR1cmF0aW9uVGhyZXNob2xkfHw0MH0pO0M9bChuLHcsVCx5LnJlcG9ydEFsbENoYW5nZXMpLFAmJihQLm9ic2VydmUoe3R5cGU6XCJmaXJzdC1pbnB1dFwiLGJ1ZmZlcmVkOiEwfSksZCgoZnVuY3Rpb24oKXthKFAudGFrZVJlY29yZHMoKSksdy52YWx1ZTwwJiZSKCk+MCYmKHcudmFsdWU9MCx3LmVudHJpZXM9W10pLEMoITApfSkpLG8oKGZ1bmN0aW9uKCl7Vj1bXSxVPUIoKSx3PWYoXCJJTlBcIiksQz1sKG4sdyxULHkucmVwb3J0QWxsQ2hhbmdlcyl9KSkpfSxYPXt9LF89ZnVuY3Rpb24obix5KXt5PXl8fHt9O3ZhciBULEM9WzI1MDAsNGUzXSx3PWgoKSxQPWYoXCJMQ1BcIiksYz1mdW5jdGlvbihuKXt2YXIgeT1uW24ubGVuZ3RoLTFdO2lmKHkpe3ZhciBDPXkuc3RhcnRUaW1lLXUoKTtDPHcuZmlyc3RIaWRkZW5UaW1lJiYoUC52YWx1ZT1DLFAuZW50cmllcz1beV0sVCgpKX19LEk9cyhcImxhcmdlc3QtY29udGVudGZ1bC1wYWludFwiLGMpO2lmKEkpe1Q9bChuLFAsQyx5LnJlcG9ydEFsbENoYW5nZXMpO3ZhciB2PWZ1bmN0aW9uKCl7WFtQLmlkXXx8KGMoSS50YWtlUmVjb3JkcygpKSxJLmRpc2Nvbm5lY3QoKSxYW1AuaWRdPSEwLFQoITApKX07W1wia2V5ZG93blwiLFwiY2xpY2tcIl0uZm9yRWFjaCgoZnVuY3Rpb24obil7YWRkRXZlbnRMaXN0ZW5lcihuLHYse29uY2U6ITAsY2FwdHVyZTohMH0pfSkpLGQodiwhMCksbygoZnVuY3Rpb24odyl7UD1mKFwiTENQXCIpLFQ9bChuLFAsQyx5LnJlcG9ydEFsbENoYW5nZXMpLHJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24oKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uKCl7UC52YWx1ZT1wZXJmb3JtYW5jZS5ub3coKS13LnRpbWVTdGFtcCxYW1AuaWRdPSEwLFQoITApfSkpfSkpfSkpfX0sWT1mdW5jdGlvbiBlKG4pe2RvY3VtZW50LnByZXJlbmRlcmluZz9hZGRFdmVudExpc3RlbmVyKFwicHJlcmVuZGVyaW5nY2hhbmdlXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIGUobil9KSwhMCk6XCJjb21wbGV0ZVwiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLChmdW5jdGlvbigpe3JldHVybiBlKG4pfSksITApOnNldFRpbWVvdXQobiwwKX0sRz1mdW5jdGlvbihuLHkpe3k9eXx8e307dmFyIFQ9WzgwMCwxODAwXSxDPWYoXCJUVEZCXCIpLHc9bChuLEMsVCx5LnJlcG9ydEFsbENoYW5nZXMpO1koKGZ1bmN0aW9uKCl7dmFyIFA9YygpO2lmKFApe2lmKEMudmFsdWU9TWF0aC5tYXgoUC5yZXNwb25zZVN0YXJ0LXUoKSwwKSxDLnZhbHVlPDB8fEMudmFsdWU+cGVyZm9ybWFuY2Uubm93KCkpcmV0dXJuO0MuZW50cmllcz1bUF0sdyghMCksbygoZnVuY3Rpb24oKXtDPWYoXCJUVEZCXCIsMCksKHc9bChuLEMsVCx5LnJlcG9ydEFsbENoYW5nZXMpKSghMCl9KSl9fSkpfTttb2R1bGUuZXhwb3J0cz15fSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/web-vitals/web-vitals.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/lib/is-error.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/lib/is-error.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = isError;\nexports.getProperError = getProperError;\nvar _isPlainObject = __webpack_require__(/*! ../shared/lib/is-plain-object */ \"./node_modules/next/dist/shared/lib/is-plain-object.js\");\nfunction isError(err) {\n    return typeof err === \"object\" && err !== null && \"name\" in err && \"message\" in err;\n}\nfunction getProperError(err) {\n    if (isError(err)) {\n        return err;\n    }\n    if (true) {\n        // provide better error for case where `throw undefined`\n        // is called in development\n        if (typeof err === \"undefined\") {\n            return new Error(\"An undefined error was thrown, \" + \"see here for more info: https://nextjs.org/docs/messages/threw-undefined\");\n        }\n        if (err === null) {\n            return new Error(\"A null error was thrown, \" + \"see here for more info: https://nextjs.org/docs/messages/threw-undefined\");\n        }\n    }\n    return new Error((0, _isPlainObject).isPlainObject(err) ? JSON.stringify(err) : err + \"\");\n}\n\n//# sourceMappingURL=is-error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9pcy1lcnJvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCLHFCQUFxQixtQkFBTyxDQUFDLDZGQUErQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBc0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2xpYi9pcy1lcnJvci5qcz8xNzhlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNFcnJvcjtcbmV4cG9ydHMuZ2V0UHJvcGVyRXJyb3IgPSBnZXRQcm9wZXJFcnJvcjtcbnZhciBfaXNQbGFpbk9iamVjdCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2lzLXBsYWluLW9iamVjdFwiKTtcbmZ1bmN0aW9uIGlzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnIgPT09IFwib2JqZWN0XCIgJiYgZXJyICE9PSBudWxsICYmIFwibmFtZVwiIGluIGVyciAmJiBcIm1lc3NhZ2VcIiBpbiBlcnI7XG59XG5mdW5jdGlvbiBnZXRQcm9wZXJFcnJvcihlcnIpIHtcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIC8vIHByb3ZpZGUgYmV0dGVyIGVycm9yIGZvciBjYXNlIHdoZXJlIGB0aHJvdyB1bmRlZmluZWRgXG4gICAgICAgIC8vIGlzIGNhbGxlZCBpbiBkZXZlbG9wbWVudFxuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkFuIHVuZGVmaW5lZCBlcnJvciB3YXMgdGhyb3duLCBcIiArIFwic2VlIGhlcmUgZm9yIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvdGhyZXctdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXCJBIG51bGwgZXJyb3Igd2FzIHRocm93biwgXCIgKyBcInNlZSBoZXJlIGZvciBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3RocmV3LXVuZGVmaW5lZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCgwLCBfaXNQbGFpbk9iamVjdCkuaXNQbGFpbk9iamVjdChlcnIpID8gSlNPTi5zdHJpbmdpZnkoZXJyKSA6IGVyciArIFwiXCIpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/lib/is-error.js\n"));

/***/ }),

/***/ "?506d":
/*!******************************************!*\
  !*** ./utils/resolve-rewrites (ignored) ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ })

});